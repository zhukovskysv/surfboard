/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
(function () {
  (function (global, factory) {

    "use strict";

    if (typeof module === "object" && typeof module.exports === "object") {

      // For CommonJS and CommonJS-like environments where a proper `window`
      // is present, execute the factory and get jQuery.
      // For environments that do not have a `window` with a `document`
      // (such as Node.js), expose a factory as module.exports.
      // This accentuates the need for the creation of a real `window`.
      // e.g. var jQuery = require("jquery")(window);
      // See ticket trac-14549 for more info.
      module.exports = global.document ?
        factory(global, true) :
        function (w) {
          if (!w.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w);
        };
    } else {
      factory(global);
    }

    // Pass this if window is not defined yet
  })(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

    // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
    // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
    // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
    // enough that all such attempts are guarded in a try block.
    "use strict";

    var arr = [];

    var getProto = Object.getPrototypeOf;

    var slice = arr.slice;

    var flat = arr.flat ? function (array) {
      return arr.flat.call(array);
    } : function (array) {
      return arr.concat.apply([], array);
    };


    var push = arr.push;

    var indexOf = arr.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var fnToString = hasOwn.toString;

    var ObjectFunctionString = fnToString.call(Object);

    var support = {};

    var isFunction = function isFunction(obj) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
      // Plus for old WebKit, typeof returns "function" for HTML collections
      // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
      return typeof obj === "function" && typeof obj.nodeType !== "number" &&
        typeof obj.item !== "function";
    };


    var isWindow = function isWindow(obj) {
      return obj != null && obj === obj.window;
    };


    var document = window.document;



    var preservedScriptAttributes = {
      type: true,
      src: true,
      nonce: true,
      noModule: true
    };

    function DOMEval(code, node, doc) {
      doc = doc || document;

      var i, val,
        script = doc.createElement("script");

      script.text = code;
      if (node) {
        for (i in preservedScriptAttributes) {

          // Support: Firefox 64+, Edge 18+
          // Some browsers don't support the "nonce" property on scripts.
          // On the other hand, just using `getAttribute` is not enough as
          // the `nonce` attribute is reset to an empty string whenever it
          // becomes browsing-context connected.
          // See https://github.com/whatwg/html/issues/2369
          // See https://html.spec.whatwg.org/#nonce-attributes
          // The `node.getAttribute` check was added for the sake of
          // `jQuery.globalEval` so that it can fake a nonce-containing node
          // via an object.
          val = node[i] || node.getAttribute && node.getAttribute(i);
          if (val) {
            script.setAttribute(i, val);
          }
        }
      }
      doc.head.appendChild(script).parentNode.removeChild(script);
    }


    function toType(obj) {
      if (obj == null) {
        return obj + "";
      }

      // Support: Android <=2.3 only (functionish RegExp)
      return typeof obj === "object" || typeof obj === "function" ?
        class2type[toString.call(obj)] || "object" :
        typeof obj;
    }
    /* global Symbol */
    // Defining this global in .eslintrc.json would create a danger of using the global
    // unguarded in another place, it seems safer to define global only for this module



    var version = "3.7.1",

      rhtmlSuffix = /HTML$/i,

      // Define a local copy of jQuery
      jQuery = function (selector, context) {

        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init(selector, context);
      };

    jQuery.fn = jQuery.prototype = {

      // The current version of jQuery being used
      jquery: version,

      constructor: jQuery,

      // The default length of a jQuery object is 0
      length: 0,

      toArray: function () {
        return slice.call(this);
      },

      // Get the Nth element in the matched element set OR
      // Get the whole matched element set as a clean array
      get: function (num) {

        // Return all the elements in a clean array
        if (num == null) {
          return slice.call(this);
        }

        // Return just the one element from the set
        return num < 0 ? this[num + this.length] : this[num];
      },

      // Take an array of elements and push it onto the stack
      // (returning the new matched element set)
      pushStack: function (elems) {

        // Build a new jQuery matched element set
        var ret = jQuery.merge(this.constructor(), elems);

        // Add the old object onto the stack (as a reference)
        ret.prevObject = this;

        // Return the newly-formed element set
        return ret;
      },

      // Execute a callback for every element in the matched set.
      each: function (callback) {
        return jQuery.each(this, callback);
      },

      map: function (callback) {
        return this.pushStack(jQuery.map(this, function (elem, i) {
          return callback.call(elem, i, elem);
        }));
      },

      slice: function () {
        return this.pushStack(slice.apply(this, arguments));
      },

      first: function () {
        return this.eq(0);
      },

      last: function () {
        return this.eq(-1);
      },

      even: function () {
        return this.pushStack(jQuery.grep(this, function (_elem, i) {
          return (i + 1) % 2;
        }));
      },

      odd: function () {
        return this.pushStack(jQuery.grep(this, function (_elem, i) {
          return i % 2;
        }));
      },

      eq: function (i) {
        var len = this.length,
          j = +i + (i < 0 ? len : 0);
        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
      },

      end: function () {
        return this.prevObject || this.constructor();
      },

      // For internal use only.
      // Behaves like an Array's method, not like a jQuery method.
      push: push,
      sort: arr.sort,
      splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function () {
      var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

      // Handle a deep copy situation
      if (typeof target === "boolean") {
        deep = target;

        // Skip the boolean and the target
        target = arguments[i] || {};
        i++;
      }

      // Handle case when target is a string or something (possible in deep copy)
      if (typeof target !== "object" && !isFunction(target)) {
        target = {};
      }

      // Extend jQuery itself if only one argument is passed
      if (i === length) {
        target = this;
        i--;
      }

      for (; i < length; i++) {

        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null) {

          // Extend the base object
          for (name in options) {
            copy = options[name];

            // Prevent Object.prototype pollution
            // Prevent never-ending loop
            if (name === "__proto__" || target === copy) {
              continue;
            }

            // Recurse if we're merging plain objects or arrays
            if (deep && copy && (jQuery.isPlainObject(copy) ||
              (copyIsArray = Array.isArray(copy)))) {
              src = target[name];

              // Ensure proper type for the source value
              if (copyIsArray && !Array.isArray(src)) {
                clone = [];
              } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                clone = {};
              } else {
                clone = src;
              }
              copyIsArray = false;

              // Never move original objects, clone them
              target[name] = jQuery.extend(deep, clone, copy);

              // Don't bring in undefined values
            } else if (copy !== undefined) {
              target[name] = copy;
            }
          }
        }
      }

      // Return the modified object
      return target;
    };

    jQuery.extend({

      // Unique for each copy of jQuery on the page
      expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

      // Assume jQuery is ready without the ready module
      isReady: true,

      error: function (msg) {
        throw new Error(msg);
      },

      noop: function () { },

      isPlainObject: function (obj) {
        var proto, Ctor;

        // Detect obvious negatives
        // Use toString instead of jQuery.type to catch host objects
        if (!obj || toString.call(obj) !== "[object Object]") {
          return false;
        }

        proto = getProto(obj);

        // Objects with no prototype (e.g., `Object.create( null )`) are plain
        if (!proto) {
          return true;
        }

        // Objects with prototype are plain iff they were constructed by a global Object function
        Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
      },

      isEmptyObject: function (obj) {
        var name;

        for (name in obj) {
          return false;
        }
        return true;
      },

      // Evaluates a script in a provided context; falls back to the global one
      // if not specified.
      globalEval: function (code, options, doc) {
        DOMEval(code, { nonce: options && options.nonce }, doc);
      },

      each: function (obj, callback) {
        var length, i = 0;

        if (isArrayLike(obj)) {
          length = obj.length;
          for (; i < length; i++) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        }

        return obj;
      },


      // Retrieve the text value of an array of DOM nodes
      text: function (elem) {
        var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

        if (!nodeType) {

          // If no nodeType, this is expected to be an array
          while ((node = elem[i++])) {

            // Do not traverse comment nodes
            ret += jQuery.text(node);
          }
        }
        if (nodeType === 1 || nodeType === 11) {
          return elem.textContent;
        }
        if (nodeType === 9) {
          return elem.documentElement.textContent;
        }
        if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        }

        // Do not include comment or processing instruction nodes

        return ret;
      },

      // results is for internal usage only
      makeArray: function (arr, results) {
        var ret = results || [];

        if (arr != null) {
          if (isArrayLike(Object(arr))) {
            jQuery.merge(ret,
              typeof arr === "string" ?
                [arr] : arr
            );
          } else {
            push.call(ret, arr);
          }
        }

        return ret;
      },

      inArray: function (elem, arr, i) {
        return arr == null ? -1 : indexOf.call(arr, elem, i);
      },

      isXMLDoc: function (elem) {
        var namespace = elem && elem.namespaceURI,
          docElem = elem && (elem.ownerDocument || elem).documentElement;

        // Assume HTML when documentElement doesn't yet exist, such as inside
        // document fragments.
        return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
      },

      // Support: Android <=4.0 only, PhantomJS 1 only
      // push.apply(_, arraylike) throws on ancient WebKit
      merge: function (first, second) {
        var len = +second.length,
          j = 0,
          i = first.length;

        for (; j < len; j++) {
          first[i++] = second[j];
        }

        first.length = i;

        return first;
      },

      grep: function (elems, callback, invert) {
        var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert;

        // Go through the array, only saving the items
        // that pass the validator function
        for (; i < length; i++) {
          callbackInverse = !callback(elems[i], i);
          if (callbackInverse !== callbackExpect) {
            matches.push(elems[i]);
          }
        }

        return matches;
      },

      // arg is for internal usage only
      map: function (elems, callback, arg) {
        var length, value,
          i = 0,
          ret = [];

        // Go through the array, translating each of the items to their new values
        if (isArrayLike(elems)) {
          length = elems.length;
          for (; i < length; i++) {
            value = callback(elems[i], i, arg);

            if (value != null) {
              ret.push(value);
            }
          }

          // Go through every key on the object,
        } else {
          for (i in elems) {
            value = callback(elems[i], i, arg);

            if (value != null) {
              ret.push(value);
            }
          }
        }

        // Flatten any nested arrays
        return flat(ret);
      },

      // A global GUID counter for objects
      guid: 1,

      // jQuery.support is not used in Core but other projects attach their
      // properties to it so it needs to exist.
      support: support
    });

    if (typeof Symbol === "function") {
      jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }

    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
      function (_i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
      });

    function isArrayLike(obj) {

      // Support: real iOS 8.2 only (not reproducible in simulator)
      // `in` check used to prevent JIT error (gh-2145)
      // hasOwn isn't used here due to false negatives
      // regarding Nodelist length in IE
      var length = !!obj && "length" in obj && obj.length,
        type = toType(obj);

      if (isFunction(obj) || isWindow(obj)) {
        return false;
      }

      return type === "array" || length === 0 ||
        typeof length === "number" && length > 0 && (length - 1) in obj;
    }


    function nodeName(elem, name) {

      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

    }
    var pop = arr.pop;


    var sort = arr.sort;


    var splice = arr.splice;


    var whitespace = "[\\x20\\t\\r\\n\\f]";


    var rtrimCSS = new RegExp(
      "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
      "g"
    );




    // Note: an element does not contain itself
    jQuery.contains = function (a, b) {
      var bup = b && b.parentNode;

      return a === bup || !!(bup && bup.nodeType === 1 && (

        // Support: IE 9 - 11+
        // IE doesn't have `contains` on SVG.
        a.contains ?
          a.contains(bup) :
          a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
      ));
    };




    // CSS string/identifier serialization
    // https://drafts.csswg.org/cssom/#common-serializing-idioms
    var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

    function fcssescape(ch, asCodePoint) {
      if (asCodePoint) {

        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
        if (ch === "\0") {
          return "\uFFFD";
        }

        // Control characters and (dependent upon position) numbers get escaped as code points
        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
      }

      // Other potentially-special ASCII characters get backslash-escaped
      return "\\" + ch;
    }

    jQuery.escapeSelector = function (sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };




    var preferredDoc = document,
      pushNative = push;

    (function () {

      var i,
        Expr,
        outermostContext,
        sortInput,
        hasDuplicate,
        push = pushNative,

        // Local document vars
        document,
        documentElement,
        documentIsHTML,
        rbuggyQSA,
        matches,

        // Instance-specific data
        expando = jQuery.expando,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        nonnativeSelectorCache = createCache(),
        sortOrder = function (a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },

        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
          "loop|multiple|open|readonly|required|scoped",

        // Regular expressions

        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
        identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
          "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

        // Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

          // Operator (capture 2)
          "*([*^$|!~]?=)" + whitespace +

          // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
          "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
          whitespace + "*\\]",

        pseudos = ":(" + identifier + ")(?:\\((" +

          // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
          // 1. quoted (capture 3; capture 4 or capture 5)
          "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

          // 2. simple (capture 6)
          "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

          // 3. anything else (capture 2)
          ".*" +
          ")\\)|)",

        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+", "g"),

        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" +
          whitespace + "*"),
        rdescend = new RegExp(whitespace + "|>"),

        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),

        matchExpr = {
          ID: new RegExp("^#(" + identifier + ")"),
          CLASS: new RegExp("^\\.(" + identifier + ")"),
          TAG: new RegExp("^(" + identifier + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp(
            "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
            whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
            whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),

          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          needsContext: new RegExp("^" + whitespace +
            "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
            "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },

        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,

        // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

        rsibling = /[+~]/,

        // CSS escapes
        // https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace +
          "?|\\\\([^\\r\\n\\f])", "g"),
        funescape = function (escape, nonHex) {
          var high = "0x" + escape.slice(1) - 0x10000;

          if (nonHex) {

            // Strip the backslash prefix from a non-hex escape sequence
            return nonHex;
          }

          // Replace a hexadecimal escape sequence with the encoded Unicode code point
          // Support: IE <=11+
          // For values outside the Basic Multilingual Plane (BMP), manually construct a
          // surrogate pair
          return high < 0 ?
            String.fromCharCode(high + 0x10000) :
            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },

        // Used for iframes; see `setDocument`.
        // Support: IE 9 - 11+, Edge 12 - 18+
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE/Edge.
        unloadHandler = function () {
          setDocument();
        },

        inDisabledFieldset = addCombinator(
          function (elem) {
            return elem.disabled === true && nodeName(elem, "fieldset");
          },
          { dir: "parentNode", next: "legend" }
        );

      // Support: IE <=9 only
      // Accessing document.activeElement can throw unexpectedly
      // https://bugs.jquery.com/ticket/13393
      function safeActiveElement() {
        try {
          return document.activeElement;
        } catch (err) { }
      }

      // Optimize for push.apply( _, NodeList )
      try {
        push.apply(
          (arr = slice.call(preferredDoc.childNodes)),
          preferredDoc.childNodes
        );

        // Support: Android <=4.0
        // Detect silently failing push.apply
        // eslint-disable-next-line no-unused-expressions
        arr[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push = {
          apply: function (target, els) {
            pushNative.apply(target, slice.call(els));
          },
          call: function (target) {
            pushNative.apply(target, slice.call(arguments, 1));
          }
        };
      }

      function find(selector, context, results, seed) {
        var m, i, elem, nid, match, groups, newSelector,
          newContext = context && context.ownerDocument,

          // nodeType defaults to 9, since context defaults to document
          nodeType = context ? context.nodeType : 9;

        results = results || [];

        // Return early from calls with invalid selector or context
        if (typeof selector !== "string" || !selector ||
          nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

          return results;
        }

        // Try to shortcut find operations (as opposed to filters) in HTML documents
        if (!seed) {
          setDocument(context);
          context = context || document;

          if (documentIsHTML) {

            // If the selector is sufficiently simple, try using a "get*By*" DOM method
            // (excepting DocumentFragment context, where the methods don't exist)
            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

              // ID selector
              if ((m = match[1])) {

                // Document context
                if (nodeType === 9) {
                  if ((elem = context.getElementById(m))) {

                    // Support: IE 9 only
                    // getElementById can match elements by name instead of ID
                    if (elem.id === m) {
                      push.call(results, elem);
                      return results;
                    }
                  } else {
                    return results;
                  }

                  // Element context
                } else {

                  // Support: IE 9 only
                  // getElementById can match elements by name instead of ID
                  if (newContext && (elem = newContext.getElementById(m)) &&
                    find.contains(context, elem) &&
                    elem.id === m) {

                    push.call(results, elem);
                    return results;
                  }
                }

                // Type selector
              } else if (match[2]) {
                push.apply(results, context.getElementsByTagName(selector));
                return results;

                // Class selector
              } else if ((m = match[3]) && context.getElementsByClassName) {
                push.apply(results, context.getElementsByClassName(m));
                return results;
              }
            }

            // Take advantage of querySelectorAll
            if (!nonnativeSelectorCache[selector + " "] &&
              (!rbuggyQSA || !rbuggyQSA.test(selector))) {

              newSelector = selector;
              newContext = context;

              // qSA considers elements outside a scoping root when evaluating child or
              // descendant combinators, which is not what we want.
              // In such cases, we work around the behavior by prefixing every selector in the
              // list with an ID selector referencing the scope context.
              // The technique has to be used as well when a leading combinator is used
              // as such selectors are not recognized by querySelectorAll.
              // Thanks to Andrew Dupont for this technique.
              if (nodeType === 1 &&
                (rdescend.test(selector) || rleadingCombinator.test(selector))) {

                // Expand context for sibling selectors
                newContext = rsibling.test(selector) && testContext(context.parentNode) ||
                  context;

                // We can use :scope instead of the ID hack if the browser
                // supports it & if we're not changing the context.
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when
                // strict-comparing two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                if (newContext != context || !support.scope) {

                  // Capture the context ID, setting it first if necessary
                  if ((nid = context.getAttribute("id"))) {
                    nid = jQuery.escapeSelector(nid);
                  } else {
                    context.setAttribute("id", (nid = expando));
                  }
                }

                // Prefix every selector in the list
                groups = tokenize(selector);
                i = groups.length;
                while (i--) {
                  groups[i] = (nid ? "#" + nid : ":scope") + " " +
                    toSelector(groups[i]);
                }
                newSelector = groups.join(",");
              }

              try {
                push.apply(results,
                  newContext.querySelectorAll(newSelector)
                );
                return results;
              } catch (qsaError) {
                nonnativeSelectorCache(selector, true);
              } finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }

        // All others
        return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
      }

      /**
       * Create key-value caches of limited size
       * @returns {function(string, object)} Returns the Object data after storing it on itself with
       *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
       *	deleting the oldest entry
       */
      function createCache() {
        var keys = [];

        function cache(key, value) {

          // Use (key + " ") to avoid collision with native prototype properties
          // (see https://github.com/jquery/sizzle/issues/157)
          if (keys.push(key + " ") > Expr.cacheLength) {

            // Only keep the most recent entries
            delete cache[keys.shift()];
          }
          return (cache[key + " "] = value);
        }
        return cache;
      }

      /**
       * Mark a function for special use by jQuery selector module
       * @param {Function} fn The function to mark
       */
      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }

      /**
       * Support testing using an element
       * @param {Function} fn Passed the created element and returns a boolean result
       */
      function assert(fn) {
        var el = document.createElement("fieldset");

        try {
          return !!fn(el);
        } catch (e) {
          return false;
        } finally {

          // Remove from its parent by default
          if (el.parentNode) {
            el.parentNode.removeChild(el);
          }

          // release memory in IE
          el = null;
        }
      }

      /**
       * Returns a function to use in pseudos for input types
       * @param {String} type
       */
      function createInputPseudo(type) {
        return function (elem) {
          return nodeName(elem, "input") && elem.type === type;
        };
      }

      /**
       * Returns a function to use in pseudos for buttons
       * @param {String} type
       */
      function createButtonPseudo(type) {
        return function (elem) {
          return (nodeName(elem, "input") || nodeName(elem, "button")) &&
            elem.type === type;
        };
      }

      /**
       * Returns a function to use in pseudos for :enabled/:disabled
       * @param {Boolean} disabled true for :disabled; false for :enabled
       */
      function createDisabledPseudo(disabled) {

        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
        return function (elem) {

          // Only certain elements can match :enabled or :disabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
          if ("form" in elem) {

            // Check for inherited disabledness on relevant non-disabled elements:
            // * listed form-associated elements in a disabled fieldset
            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
            // * option elements in a disabled optgroup
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
            // All such elements have a "form" property.
            if (elem.parentNode && elem.disabled === false) {

              // Option elements defer to a parent optgroup if present
              if ("label" in elem) {
                if ("label" in elem.parentNode) {
                  return elem.parentNode.disabled === disabled;
                } else {
                  return elem.disabled === disabled;
                }
              }

              // Support: IE 6 - 11+
              // Use the isDisabled shortcut property to check for disabled fieldset ancestors
              return elem.isDisabled === disabled ||

                // Where there is no isDisabled, check manually
                elem.isDisabled !== !disabled &&
                inDisabledFieldset(elem) === disabled;
            }

            return elem.disabled === disabled;

            // Try to winnow out elements that can't be disabled before trusting the disabled property.
            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
            // even exist on them, let alone have a boolean value.
          } else if ("label" in elem) {
            return elem.disabled === disabled;
          }

          // Remaining elements are neither :enabled nor :disabled
          return false;
        };
      }

      /**
       * Returns a function to use in pseudos for positionals
       * @param {Function} fn
       */
      function createPositionalPseudo(fn) {
        return markFunction(function (argument) {
          argument = +argument;
          return markFunction(function (seed, matches) {
            var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;

            // Match elements found at the specified indexes
            while (i--) {
              if (seed[(j = matchIndexes[i])]) {
                seed[j] = !(matches[j] = seed[j]);
              }
            }
          });
        });
      }

      /**
       * Checks a node for validity as a jQuery selector context
       * @param {Element|Object=} context
       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
       */
      function testContext(context) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
      }

      /**
       * Sets document-related variables once based on the current document
       * @param {Element|Object} [node] An element or document object to use to set the document
       * @returns {Object} Returns the current document
       */
      function setDocument(node) {
        var subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc;

        // Return early if doc is invalid or already selected
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
          return document;
        }

        // Update global variables
        document = doc;
        documentElement = document.documentElement;
        documentIsHTML = !jQuery.isXMLDoc(document);

        // Support: iOS 7 only, IE 9 - 11+
        // Older browsers didn't support unprefixed `matches`.
        matches = documentElement.matches ||
          documentElement.webkitMatchesSelector ||
          documentElement.msMatchesSelector;

        // Support: IE 9 - 11+, Edge 12 - 18+
        // Accessing iframe documents after unload throws "permission denied" errors
        // (see trac-13936).
        // Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
        // all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
        if (documentElement.msMatchesSelector &&

          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          preferredDoc != document &&
          (subWindow = document.defaultView) && subWindow.top !== subWindow) {

          // Support: IE 9 - 11+, Edge 12 - 18+
          subWindow.addEventListener("unload", unloadHandler);
        }

        // Support: IE <10
        // Check if getElementById returns elements by name
        // The broken getElementById methods don't pick up programmatically-set names,
        // so use a roundabout getElementsByName test
        support.getById = assert(function (el) {
          documentElement.appendChild(el).id = jQuery.expando;
          return !document.getElementsByName ||
            !document.getElementsByName(jQuery.expando).length;
        });

        // Support: IE 9 only
        // Check to see if it's possible to do matchesSelector
        // on a disconnected node.
        support.disconnectedMatch = assert(function (el) {
          return matches.call(el, "*");
        });

        // Support: IE 9 - 11+, Edge 12 - 18+
        // IE/Edge don't support the :scope pseudo-class.
        support.scope = assert(function () {
          return document.querySelectorAll(":scope");
        });

        // Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
        // Make sure the `:has()` argument is parsed unforgivingly.
        // We include `*` in the test to detect buggy implementations that are
        // _selectively_ forgiving (specifically when the list includes at least
        // one valid selector).
        // Note that we treat complete lack of support for `:has()` as if it were
        // spec-compliant support, which is fine because use of `:has()` in such
        // environments will fail in the qSA path and fall back to jQuery traversal
        // anyway.
        support.cssHas = assert(function () {
          try {
            document.querySelector(":has(*,:jqfake)");
            return false;
          } catch (e) {
            return true;
          }
        });

        // ID filter and find
        if (support.getById) {
          Expr.filter.ID = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              return elem.getAttribute("id") === attrId;
            };
          };
          Expr.find.ID = function (id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var elem = context.getElementById(id);
              return elem ? [elem] : [];
            }
          };
        } else {
          Expr.filter.ID = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              var node = typeof elem.getAttributeNode !== "undefined" &&
                elem.getAttributeNode("id");
              return node && node.value === attrId;
            };
          };

          // Support: IE 6 - 7 only
          // getElementById is not reliable as a find shortcut
          Expr.find.ID = function (id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var node, i, elems,
                elem = context.getElementById(id);

              if (elem) {

                // Verify the id attribute
                node = elem.getAttributeNode("id");
                if (node && node.value === id) {
                  return [elem];
                }

                // Fall back on getElementsByName
                elems = context.getElementsByName(id);
                i = 0;
                while ((elem = elems[i++])) {
                  node = elem.getAttributeNode("id");
                  if (node && node.value === id) {
                    return [elem];
                  }
                }
              }

              return [];
            }
          };
        }

        // Tag
        Expr.find.TAG = function (tag, context) {
          if (typeof context.getElementsByTagName !== "undefined") {
            return context.getElementsByTagName(tag);

            // DocumentFragment nodes don't have gEBTN
          } else {
            return context.querySelectorAll(tag);
          }
        };

        // Class
        Expr.find.CLASS = function (className, context) {
          if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };

        /* QSA/matchesSelector
        ---------------------------------------------------------------------- */

        // QSA and matchesSelector support

        rbuggyQSA = [];

        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function (el) {

          var input;

          documentElement.appendChild(el).innerHTML =
            "<a id='" + expando + "' href='' disabled='disabled'></a>" +
            "<select id='" + expando + "-\r\\' disabled='disabled'>" +
            "<option selected=''></option></select>";

          // Support: iOS <=7 - 8 only
          // Boolean attributes and "value" are not treated correctly in some XML documents
          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }

          // Support: iOS <=7 - 8 only
          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }

          // Support: iOS 8 only
          // https://bugs.webkit.org/show_bug.cgi?id=136851
          // In-page `selector#id sibling-combinator selector` fails
          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }

          // Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
          // In some of the document kinds, these selectors wouldn't work natively.
          // This is probably OK but for backwards compatibility we want to maintain
          // handling them through jQuery traversal in jQuery 3.x.
          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }

          // Support: Windows 8 Native Apps
          // The type and name attributes are restricted during .innerHTML assignment
          input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D");

          // Support: IE 9 - 11+
          // IE's :disabled selector does not pick up the children of disabled fieldsets
          // Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
          // In some of the document kinds, these selectors wouldn't work natively.
          // This is probably OK but for backwards compatibility we want to maintain
          // handling them through jQuery traversal in jQuery 3.x.
          documentElement.appendChild(el).disabled = true;
          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }

          // Support: IE 11+, Edge 15 - 18+
          // IE 11/Edge don't find elements on a `[name='']` query in some cases.
          // Adding a temporary attribute to the document before the selection works
          // around the issue.
          // Interestingly, IE 10 & older don't seem to have the issue.
          input = document.createElement("input");
          input.setAttribute("name", "");
          el.appendChild(input);
          if (!el.querySelectorAll("[name='']").length) {
            rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" +
              whitespace + "*(?:''|\"\")");
          }
        });

        if (!support.cssHas) {

          // Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
          // Our regular `try-catch` mechanism fails to detect natively-unsupported
          // pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
          // in browsers that parse the `:has()` argument as a forgiving selector list.
          // https://drafts.csswg.org/selectors/#relational now requires the argument
          // to be parsed unforgivingly, but browsers have not yet fully adjusted.
          rbuggyQSA.push(":has");
        }

        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));

        /* Sorting
        ---------------------------------------------------------------------- */

        // Document order sorting
        sortOrder = function (a, b) {

          // Flag for duplicate removal
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }

          // Sort on method existence if only one input has compareDocumentPosition
          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
          if (compare) {
            return compare;
          }

          // Calculate position if both inputs belong to the same document
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          compare = (a.ownerDocument || a) == (b.ownerDocument || b) ?
            a.compareDocumentPosition(b) :

            // Otherwise we know they are disconnected
            1;

          // Disconnected nodes
          if (compare & 1 ||
            (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

            // Choose the first element that is related to our preferred document
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if (a === document || a.ownerDocument == preferredDoc &&
              find.contains(preferredDoc, a)) {
              return -1;
            }

            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if (b === document || b.ownerDocument == preferredDoc &&
              find.contains(preferredDoc, b)) {
              return 1;
            }

            // Maintain original order
            return sortInput ?
              (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
              0;
          }

          return compare & 4 ? -1 : 1;
        };

        return document;
      }

      find.matches = function (expr, elements) {
        return find(expr, null, null, elements);
      };

      find.matchesSelector = function (elem, expr) {
        setDocument(elem);

        if (documentIsHTML &&
          !nonnativeSelectorCache[expr + " "] &&
          (!rbuggyQSA || !rbuggyQSA.test(expr))) {

          try {
            var ret = matches.call(elem, expr);

            // IE 9's matchesSelector returns false on disconnected nodes
            if (ret || support.disconnectedMatch ||

              // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
              return ret;
            }
          } catch (e) {
            nonnativeSelectorCache(expr, true);
          }
        }

        return find(expr, document, null, [elem]).length > 0;
      };

      find.contains = function (context, elem) {

        // Set document vars if needed
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if ((context.ownerDocument || context) != document) {
          setDocument(context);
        }
        return jQuery.contains(context, elem);
      };


      find.attr = function (elem, name) {

        // Set document vars if needed
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if ((elem.ownerDocument || elem) != document) {
          setDocument(elem);
        }

        var fn = Expr.attrHandle[name.toLowerCase()],

          // Don't get fooled by Object.prototype properties (see trac-13807)
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
            fn(elem, name, !documentIsHTML) :
            undefined;

        if (val !== undefined) {
          return val;
        }

        return elem.getAttribute(name);
      };

      find.error = function (msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };

      /**
       * Document sorting and removing duplicates
       * @param {ArrayLike} results
       */
      jQuery.uniqueSort = function (results) {
        var elem,
          duplicates = [],
          j = 0,
          i = 0;

        // Unless we *know* we can detect duplicates, assume their presence
        //
        // Support: Android <=4.0+
        // Testing for detecting duplicates is unpredictable so instead assume we can't
        // depend on duplicate detection in all browsers without a stable sort.
        hasDuplicate = !support.sortStable;
        sortInput = !support.sortStable && slice.call(results, 0);
        sort.call(results, sortOrder);

        if (hasDuplicate) {
          while ((elem = results[i++])) {
            if (elem === results[i]) {
              j = duplicates.push(i);
            }
          }
          while (j--) {
            splice.call(results, duplicates[j], 1);
          }
        }

        // Clear input after sorting to release objects
        // See https://github.com/jquery/sizzle/pull/225
        sortInput = null;

        return results;
      };

      jQuery.fn.uniqueSort = function () {
        return this.pushStack(jQuery.uniqueSort(slice.apply(this)));
      };

      Expr = jQuery.expr = {

        // Can be adjusted by the user
        cacheLength: 50,

        createPseudo: markFunction,

        match: matchExpr,

        attrHandle: {},

        find: {},

        relative: {
          ">": { dir: "parentNode", first: true },
          " ": { dir: "parentNode" },
          "+": { dir: "previousSibling", first: true },
          "~": { dir: "previousSibling" }
        },

        preFilter: {
          ATTR: function (match) {
            match[1] = match[1].replace(runescape, funescape);

            // Move the given value to match[3] whether quoted or unquoted
            match[3] = (match[3] || match[4] || match[5] || "")
              .replace(runescape, funescape);

            if (match[2] === "~=") {
              match[3] = " " + match[3] + " ";
            }

            return match.slice(0, 4);
          },

          CHILD: function (match) {

            /* matches from matchExpr["CHILD"]
              1 type (only|nth|...)
              2 what (child|of-type)
              3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
              4 xn-component of xn+y argument ([+-]?\d*n|)
              5 sign of xn-component
              6 x of xn-component
              7 sign of y-component
              8 y of y-component
            */
            match[1] = match[1].toLowerCase();

            if (match[1].slice(0, 3) === "nth") {

              // nth-* requires argument
              if (!match[3]) {
                find.error(match[0]);
              }

              // numeric x and y parameters for Expr.filter.CHILD
              // remember that false/true cast respectively to 0/1
              match[4] = +(match[4] ?
                match[5] + (match[6] || 1) :
                2 * (match[3] === "even" || match[3] === "odd")
              );
              match[5] = +((match[7] + match[8]) || match[3] === "odd");

              // other types prohibit arguments
            } else if (match[3]) {
              find.error(match[0]);
            }

            return match;
          },

          PSEUDO: function (match) {
            var excess,
              unquoted = !match[6] && match[2];

            if (matchExpr.CHILD.test(match[0])) {
              return null;
            }

            // Accept quoted arguments as-is
            if (match[3]) {
              match[2] = match[4] || match[5] || "";

              // Strip excess characters from unquoted arguments
            } else if (unquoted && rpseudo.test(unquoted) &&

              // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) &&

              // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

              // excess is a negative index
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            }

            // Return only captures needed by the pseudo filter method (type and argument)
            return match.slice(0, 3);
          }
        },

        filter: {

          TAG: function (nodeNameSelector) {
            var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === "*" ?
              function () {
                return true;
              } :
              function (elem) {
                return nodeName(elem, expectedNodeName);
              };
          },

          CLASS: function (className) {
            var pattern = classCache[className + " "];

            return pattern ||
              (pattern = new RegExp("(^|" + whitespace + ")" + className +
                "(" + whitespace + "|$)")) &&
              classCache(className, function (elem) {
                return pattern.test(
                  typeof elem.className === "string" && elem.className ||
                  typeof elem.getAttribute !== "undefined" &&
                  elem.getAttribute("class") ||
                  ""
                );
              });
          },

          ATTR: function (name, operator, check) {
            return function (elem) {
              var result = find.attr(elem, name);

              if (result == null) {
                return operator === "!=";
              }
              if (!operator) {
                return true;
              }

              result += "";

              if (operator === "=") {
                return result === check;
              }
              if (operator === "!=") {
                return result !== check;
              }
              if (operator === "^=") {
                return check && result.indexOf(check) === 0;
              }
              if (operator === "*=") {
                return check && result.indexOf(check) > -1;
              }
              if (operator === "$=") {
                return check && result.slice(-check.length) === check;
              }
              if (operator === "~=") {
                return (" " + result.replace(rwhitespace, " ") + " ")
                  .indexOf(check) > -1;
              }
              if (operator === "|=") {
                return result === check || result.slice(0, check.length + 1) === check + "-";
              }

              return false;
            };
          },

          CHILD: function (type, what, _argument, first, last) {
            var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";

            return first === 1 && last === 0 ?

              // Shortcut for :nth-*(n)
              function (elem) {
                return !!elem.parentNode;
              } :

              function (elem, _context, xml) {
                var cache, outerCache, node, nodeIndex, start,
                  dir = simple !== forward ? "nextSibling" : "previousSibling",
                  parent = elem.parentNode,
                  name = ofType && elem.nodeName.toLowerCase(),
                  useCache = !xml && !ofType,
                  diff = false;

                if (parent) {

                  // :(first|last|only)-(child|of-type)
                  if (simple) {
                    while (dir) {
                      node = elem;
                      while ((node = node[dir])) {
                        if (ofType ?
                          nodeName(node, name) :
                          node.nodeType === 1) {

                          return false;
                        }
                      }

                      // Reverse direction for :only-* (if we haven't yet done so)
                      start = dir = type === "only" && !start && "nextSibling";
                    }
                    return true;
                  }

                  start = [forward ? parent.firstChild : parent.lastChild];

                  // non-xml :nth-child(...) stores cache data on `parent`
                  if (forward && useCache) {

                    // Seek `elem` from a previously-cached index
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache = outerCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];

                    while ((node = ++nodeIndex && node && node[dir] ||

                      // Fallback to seeking `elem` from the start
                      (diff = nodeIndex = 0) || start.pop())) {

                      // When found, cache indexes on `parent` and break
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        outerCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }

                  } else {

                    // Use previously-cached element index if available
                    if (useCache) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      cache = outerCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex;
                    }

                    // xml :nth-child(...)
                    // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                    if (diff === false) {

                      // Use the same loop as above to seek `elem` from the start
                      while ((node = ++nodeIndex && node && node[dir] ||
                        (diff = nodeIndex = 0) || start.pop())) {

                        if ((ofType ?
                          nodeName(node, name) :
                          node.nodeType === 1) &&
                          ++diff) {

                          // Cache the index of each encountered element
                          if (useCache) {
                            outerCache = node[expando] ||
                              (node[expando] = {});
                            outerCache[type] = [dirruns, diff];
                          }

                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }

                  // Incorporate the offset, then check against cycle size
                  diff -= last;
                  return diff === first || (diff % first === 0 && diff / first >= 0);
                }
              };
          },

          PSEUDO: function (pseudo, argument) {

            // pseudo-class names are case-insensitive
            // https://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
                find.error("unsupported pseudo: " + pseudo);

            // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as jQuery does
            if (fn[expando]) {
              return fn(argument);
            }

            // But maintain support for old signatures
            if (fn.length > 1) {
              args = [pseudo, pseudo, "", argument];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                markFunction(function (seed, matches) {
                  var idx,
                    matched = fn(seed, argument),
                    i = matched.length;
                  while (i--) {
                    idx = indexOf.call(seed, matched[i]);
                    seed[idx] = !(matches[idx] = matched[i]);
                  }
                }) :
                function (elem) {
                  return fn(elem, 0, args);
                };
            }

            return fn;
          }
        },

        pseudos: {

          // Potentially complex pseudos
          not: markFunction(function (selector) {

            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
              results = [],
              matcher = compile(selector.replace(rtrimCSS, "$1"));

            return matcher[expando] ?
              markFunction(function (seed, matches, _context, xml) {
                var elem,
                  unmatched = matcher(seed, null, xml, []),
                  i = seed.length;

                // Match elements unmatched by `matcher`
                while (i--) {
                  if ((elem = unmatched[i])) {
                    seed[i] = !(matches[i] = elem);
                  }
                }
              }) :
              function (elem, _context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);

                // Don't keep the element
                // (see https://github.com/jquery/sizzle/issues/299)
                input[0] = null;
                return !results.pop();
              };
          }),

          has: markFunction(function (selector) {
            return function (elem) {
              return find(selector, elem).length > 0;
            };
          }),

          contains: markFunction(function (text) {
            text = text.replace(runescape, funescape);
            return function (elem) {
              return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;
            };
          }),

          // "Whether an element is represented by a :lang() selector
          // is based solely on the element's language value
          // being equal to the identifier C,
          // or beginning with the identifier C immediately followed by "-".
          // The matching of C against the element's language value is performed case-insensitively.
          // The identifier C does not have to be a valid language name."
          // https://www.w3.org/TR/selectors/#lang-pseudo
          lang: markFunction(function (lang) {

            // lang value must be a valid identifier
            if (!ridentifier.test(lang || "")) {
              find.error("unsupported lang: " + lang);
            }
            lang = lang.replace(runescape, funescape).toLowerCase();
            return function (elem) {
              var elemLang;
              do {
                if ((elemLang = documentIsHTML ?
                  elem.lang :
                  elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);
              return false;
            };
          }),

          // Miscellaneous
          target: function (elem) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice(1) === elem.id;
          },

          root: function (elem) {
            return elem === documentElement;
          },

          focus: function (elem) {
            return elem === safeActiveElement() &&
              document.hasFocus() &&
              !!(elem.type || elem.href || ~elem.tabIndex);
          },

          // Boolean properties
          enabled: createDisabledPseudo(false),
          disabled: createDisabledPseudo(true),

          checked: function (elem) {

            // In CSS3, :checked should return both checked and selected elements
            // https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            return (nodeName(elem, "input") && !!elem.checked) ||
              (nodeName(elem, "option") && !!elem.selected);
          },

          selected: function (elem) {

            // Support: IE <=11+
            // Accessing the selectedIndex property
            // forces the browser to treat the default option as
            // selected when in an optgroup.
            if (elem.parentNode) {
              // eslint-disable-next-line no-unused-expressions
              elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
          },

          // Contents
          empty: function (elem) {

            // https://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
            //   but not by others (comment: 8; processing instruction: 7; etc.)
            // nodeType < 6 works because attributes (2) do not appear as children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }
            return true;
          },

          parent: function (elem) {
            return !Expr.pseudos.empty(elem);
          },

          // Element/input types
          header: function (elem) {
            return rheader.test(elem.nodeName);
          },

          input: function (elem) {
            return rinputs.test(elem.nodeName);
          },

          button: function (elem) {
            return nodeName(elem, "input") && elem.type === "button" ||
              nodeName(elem, "button");
          },

          text: function (elem) {
            var attr;
            return nodeName(elem, "input") && elem.type === "text" &&

              // Support: IE <10 only
              // New HTML5 attribute values (e.g., "search") appear
              // with elem.type === "text"
              ((attr = elem.getAttribute("type")) == null ||
                attr.toLowerCase() === "text");
          },

          // Position-in-collection
          first: createPositionalPseudo(function () {
            return [0];
          }),

          last: createPositionalPseudo(function (_matchIndexes, length) {
            return [length - 1];
          }),

          eq: createPositionalPseudo(function (_matchIndexes, length, argument) {
            return [argument < 0 ? argument + length : argument];
          }),

          even: createPositionalPseudo(function (matchIndexes, length) {
            var i = 0;
            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),

          odd: createPositionalPseudo(function (matchIndexes, length) {
            var i = 1;
            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),

          lt: createPositionalPseudo(function (matchIndexes, length, argument) {
            var i;

            if (argument < 0) {
              i = argument + length;
            } else if (argument > length) {
              i = length;
            } else {
              i = argument;
            }

            for (; --i >= 0;) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),

          gt: createPositionalPseudo(function (matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for (; ++i < length;) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          })
        }
      };

      Expr.pseudos.nth = Expr.pseudos.eq;

      // Add button/input type pseudos
      for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }
      for (i in { submit: true, reset: true }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      }

      // Easy API for creating new setFilters
      function setFilters() { }
      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();

      function tokenize(selector, parseOnly) {
        var matched, match, tokens, type,
          soFar, groups, preFilters,
          cached = tokenCache[selector + " "];

        if (cached) {
          return parseOnly ? 0 : cached.slice(0);
        }

        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;

        while (soFar) {

          // Comma and first run
          if (!matched || (match = rcomma.exec(soFar))) {
            if (match) {

              // Don't consume trailing commas as valid
              soFar = soFar.slice(match[0].length) || soFar;
            }
            groups.push((tokens = []));
          }

          matched = false;

          // Combinators
          if ((match = rleadingCombinator.exec(soFar))) {
            matched = match.shift();
            tokens.push({
              value: matched,

              // Cast descendant combinators to space
              type: match[0].replace(rtrimCSS, " ")
            });
            soFar = soFar.slice(matched.length);
          }

          // Filters
          for (type in Expr.filter) {
            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
              (match = preFilters[type](match)))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match
              });
              soFar = soFar.slice(matched.length);
            }
          }

          if (!matched) {
            break;
          }
        }

        // Return the length of the invalid excess
        // if we're just parsing
        // Otherwise, throw an error or return tokens
        if (parseOnly) {
          return soFar.length;
        }

        return soFar ?
          find.error(selector) :

          // Cache the tokens
          tokenCache(selector, groups).slice(0);
      }

      function toSelector(tokens) {
        var i = 0,
          len = tokens.length,
          selector = "";
        for (; i < len; i++) {
          selector += tokens[i].value;
        }
        return selector;
      }

      function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;

        return combinator.first ?

          // Check against closest ancestor/preceding element
          function (elem, context, xml) {
            while ((elem = elem[dir])) {
              if (elem.nodeType === 1 || checkNonElements) {
                return matcher(elem, context, xml);
              }
            }
            return false;
          } :

          // Check against all ancestor/preceding elements
          function (elem, context, xml) {
            var oldCache, outerCache,
              newCache = [dirruns, doneName];

            // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
            if (xml) {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  if (matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            } else {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  outerCache = elem[expando] || (elem[expando] = {});

                  if (skip && nodeName(elem, skip)) {
                    elem = elem[dir] || elem;
                  } else if ((oldCache = outerCache[key]) &&
                    oldCache[0] === dirruns && oldCache[1] === doneName) {

                    // Assign to newCache so results back-propagate to previous elements
                    return (newCache[2] = oldCache[2]);
                  } else {

                    // Reuse newcache so results back-propagate to previous elements
                    outerCache[key] = newCache;

                    // A match means we're done; a fail means we have to keep checking
                    if ((newCache[2] = matcher(elem, context, xml))) {
                      return true;
                    }
                  }
                }
              }
            }
            return false;
          };
      }

      function elementMatcher(matchers) {
        return matchers.length > 1 ?
          function (elem, context, xml) {
            var i = matchers.length;
            while (i--) {
              if (!matchers[i](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } :
          matchers[0];
      }

      function multipleContexts(selector, contexts, results) {
        var i = 0,
          len = contexts.length;
        for (; i < len; i++) {
          find(selector, contexts[i], results);
        }
        return results;
      }

      function condense(unmatched, map, filter, context, xml) {
        var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

        for (; i < len; i++) {
          if ((elem = unmatched[i])) {
            if (!filter || filter(elem, context, xml)) {
              newUnmatched.push(elem);
              if (mapped) {
                map.push(i);
              }
            }
          }
        }

        return newUnmatched;
      }

      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }
        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }
        return markFunction(function (seed, results, context, xml) {
          var temp, i, elem, matcherOut,
            preMap = [],
            postMap = [],
            preexisting = results.length,

            // Get initial elements from seed or context
            elems = seed ||
              multipleContexts(selector || "*",
                context.nodeType ? [context] : context, []),

            // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn = preFilter && (seed || !selector) ?
              condense(elems, preMap, preFilter, context, xml) :
              elems;

          if (matcher) {

            // If we have a postFinder, or filtered seed, or non-seed postFilter
            // or preexisting results,
            matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ?

              // ...intermediate processing is necessary
              [] :

              // ...otherwise use results directly
              results;

            // Find primary matches
            matcher(matcherIn, matcherOut, context, xml);
          } else {
            matcherOut = matcherIn;
          }

          // Apply postFilter
          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml);

            // Un-match failing elements by moving them back to matcherIn
            i = temp.length;
            while (i--) {
              if ((elem = temp[i])) {
                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
              }
            }
          }

          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {

                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                temp = [];
                i = matcherOut.length;
                while (i--) {
                  if ((elem = matcherOut[i])) {

                    // Restore matcherIn since elem is not yet a final match
                    temp.push((matcherIn[i] = elem));
                  }
                }
                postFinder(null, (matcherOut = []), temp, xml);
              }

              // Move matched elements from seed to results to keep them synchronized
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i]) &&
                  (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {

                  seed[temp] = !(results[temp] = elem);
                }
              }
            }

            // Add elements to results, through postFinder if defined
          } else {
            matcherOut = condense(
              matcherOut === results ?
                matcherOut.splice(preexisting, matcherOut.length) :
                matcherOut
            );
            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push.apply(results, matcherOut);
            }
          }
        });
      }

      function matcherFromTokens(tokens) {
        var checkContext, matcher, j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,

          // The foundational matcher ensures that elements are reachable from top-level context(s)
          matchContext = addCombinator(function (elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function (elem) {
            return indexOf.call(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function (elem, context, xml) {

            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            var ret = (!leadingRelative && (xml || context != outermostContext)) || (
              (checkContext = context).nodeType ?
                matchContext(elem, context, xml) :
                matchAnyContext(elem, context, xml));

            // Avoid hanging onto element
            // (see https://github.com/jquery/sizzle/issues/299)
            checkContext = null;
            return ret;
          }];

        for (; i < len; i++) {
          if ((matcher = Expr.relative[tokens[i].type])) {
            matchers = [addCombinator(elementMatcher(matchers), matcher)];
          } else {
            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

            // Return special upon seeing a positional matcher
            if (matcher[expando]) {

              // Find the next relative operator (if any) for proper handling
              j = ++i;
              for (; j < len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }
              return setMatcher(
                i > 1 && elementMatcher(matchers),
                i > 1 && toSelector(

                  // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                  tokens.slice(0, i - 1)
                    .concat({ value: tokens[i - 2].type === " " ? "*" : "" })
                ).replace(rtrimCSS, "$1"),
                matcher,
                i < j && matcherFromTokens(tokens.slice(i, j)),
                j < len && matcherFromTokens((tokens = tokens.slice(j))),
                j < len && toSelector(tokens)
              );
            }
            matchers.push(matcher);
          }
        }

        return elementMatcher(matchers);
      }

      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function (seed, context, xml, results, outermost) {
            var elem, j, matcher,
              matchedCount = 0,
              i = "0",
              unmatched = seed && [],
              setMatched = [],
              contextBackup = outermostContext,

              // We must always have either seed elements or outermost context
              elems = seed || byElement && Expr.find.TAG("*", outermost),

              // Use integer dirruns iff this is the outermost matcher
              dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
              len = elems.length;

            if (outermost) {

              // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              // eslint-disable-next-line eqeqeq
              outermostContext = context == document || context || outermost;
            }

            // Add elements passing elementMatchers directly to results
            // Support: iOS <=7 - 9 only
            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
            // elements by id. (see trac-14142)
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;

                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                if (!context && elem.ownerDocument != document) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context || document, xml)) {
                    push.call(results, elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }

              // Track unmatched elements for set filters
              if (bySet) {

                // They will have gone through all possible matchers
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }

                // Lengthen the array for every element, matched or not
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }

            // `i` is now the count of elements visited above, and adding it to `matchedCount`
            // makes the latter nonnegative.
            matchedCount += i;

            // Apply set filters to unmatched elements
            // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
            // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
            // no element matchers and no seed.
            // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
            // case, which will result in a "00" `matchedCount` that differs from `i` but is also
            // numerically zero.
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }

              if (seed) {

                // Reintegrate element matches to eliminate the need for sorting
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }

                // Discard index placeholder values to get only actual matches
                setMatched = condense(setMatched);
              }

              // Add matches to results
              push.apply(results, setMatched);

              // Seedless set matches succeeding multiple successful matchers stipulate sorting
              if (outermost && !seed && setMatched.length > 0 &&
                (matchedCount + setMatchers.length) > 1) {

                jQuery.uniqueSort(results);
              }
            }

            // Override manipulation of globals by nested matchers
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }

            return unmatched;
          };

        return bySet ?
          markFunction(superMatcher) :
          superMatcher;
      }

      function compile(selector, match /* Internal Use Only */) {
        var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];

        if (!cached) {

          // Generate a function of recursive functions that can be used to check each element
          if (!match) {
            match = tokenize(selector);
          }
          i = match.length;
          while (i--) {
            cached = matcherFromTokens(match[i]);
            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          }

          // Cache the compiled function
          cached = compilerCache(selector,
            matcherFromGroupMatchers(elementMatchers, setMatchers));

          // Save selector and tokenization
          cached.selector = selector;
        }
        return cached;
      }

      /**
       * A low-level selection function that works with jQuery's compiled
       *  selector functions
       * @param {String|Function} selector A selector or a pre-compiled
       *  selector function built with jQuery selector compile
       * @param {Element} context
       * @param {Array} [results]
       * @param {Array} [seed] A set of elements to match against
       */
      function select(selector, context, results, seed) {
        var i, tokens, token, type, find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));

        results = results || [];

        // Try to minimize operations if there is only one selector in the list and no seed
        // (the latter of which guarantees us context)
        if (match.length === 1) {

          // Reduce context if the leading compound selector is an ID
          tokens = match[0] = match[0].slice(0);
          if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
            context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

            context = (Expr.find.ID(
              token.matches[0].replace(runescape, funescape),
              context
            ) || [])[0];
            if (!context) {
              return results;

              // Precompiled matchers will still verify ancestry, so step up a level
            } else if (compiled) {
              context = context.parentNode;
            }

            selector = selector.slice(tokens.shift().value.length);
          }

          // Fetch a seed set for right-to-left matching
          i = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];

            // Abort if we hit a combinator
            if (Expr.relative[(type = token.type)]) {
              break;
            }
            if ((find = Expr.find[type])) {

              // Search, expanding context for leading sibling combinators
              if ((seed = find(
                token.matches[0].replace(runescape, funescape),
                rsibling.test(tokens[0].type) &&
                testContext(context.parentNode) || context
              ))) {

                // If seed is empty or no tokens remain, we can return early
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }

                break;
              }
            }
          }
        }

        // Compile and execute a filtering function if one is not provided
        // Provide `match` to avoid retokenization if we modified the selector above
        (compiled || compile(selector, match))(
          seed,
          context,
          !documentIsHTML,
          results,
          !context || rsibling.test(selector) && testContext(context.parentNode) || context
        );
        return results;
      }

      // One-time assignments

      // Support: Android <=4.0 - 4.1+
      // Sort stability
      support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

      // Initialize against the default document
      setDocument();

      // Support: Android <=4.0 - 4.1+
      // Detached nodes confoundingly follow *each other*
      support.sortDetached = assert(function (el) {

        // Should return 1, but returns 4 (following)
        return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
      });

      jQuery.find = find;

      // Deprecated
      jQuery.expr[":"] = jQuery.expr.pseudos;
      jQuery.unique = jQuery.uniqueSort;

      // These have always been private, but they used to be documented as part of
      // Sizzle so let's maintain them for now for backwards compatibility purposes.
      find.compile = compile;
      find.select = select;
      find.setDocument = setDocument;
      find.tokenize = tokenize;

      find.escape = jQuery.escapeSelector;
      find.getText = jQuery.text;
      find.isXML = jQuery.isXMLDoc;
      find.selectors = jQuery.expr;
      find.support = jQuery.support;
      find.uniqueSort = jQuery.uniqueSort;

      /* eslint-enable */

    })();


    var dir = function (elem, dir, until) {
      var matched = [],
        truncate = until !== undefined;

      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    };


    var siblings = function (n, elem) {
      var matched = [];

      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }

      return matched;
    };


    var rneedsContext = jQuery.expr.match.needsContext;

    var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);



    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
      if (isFunction(qualifier)) {
        return jQuery.grep(elements, function (elem, i) {
          return !!qualifier.call(elem, i, elem) !== not;
        });
      }

      // Single element
      if (qualifier.nodeType) {
        return jQuery.grep(elements, function (elem) {
          return (elem === qualifier) !== not;
        });
      }

      // Arraylike of elements (jQuery, arguments, Array)
      if (typeof qualifier !== "string") {
        return jQuery.grep(elements, function (elem) {
          return (indexOf.call(qualifier, elem) > -1) !== not;
        });
      }

      // Filtered directly for both simple and complex selectors
      return jQuery.filter(qualifier, elements, not);
    }

    jQuery.filter = function (expr, elems, not) {
      var elem = elems[0];

      if (not) {
        expr = ":not(" + expr + ")";
      }

      if (elems.length === 1 && elem.nodeType === 1) {
        return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
      }

      return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
        return elem.nodeType === 1;
      }));
    };

    jQuery.fn.extend({
      find: function (selector) {
        var i, ret,
          len = this.length,
          self = this;

        if (typeof selector !== "string") {
          return this.pushStack(jQuery(selector).filter(function () {
            for (i = 0; i < len; i++) {
              if (jQuery.contains(self[i], this)) {
                return true;
              }
            }
          }));
        }

        ret = this.pushStack([]);

        for (i = 0; i < len; i++) {
          jQuery.find(selector, self[i], ret);
        }

        return len > 1 ? jQuery.uniqueSort(ret) : ret;
      },
      filter: function (selector) {
        return this.pushStack(winnow(this, selector || [], false));
      },
      not: function (selector) {
        return this.pushStack(winnow(this, selector || [], true));
      },
      is: function (selector) {
        return !!winnow(
          this,

          // If this is a positional/relative selector, check membership in the returned set
          // so $("p:first").is("p:last") won't return true for a doc with two "p".
          typeof selector === "string" && rneedsContext.test(selector) ?
            jQuery(selector) :
            selector || [],
          false
        ).length;
      }
    });


    // Initialize a jQuery object


    // A central reference to the root jQuery(document)
    var rootjQuery,

      // A simple way to check for HTML strings
      // Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
      // Strict HTML recognition (trac-11290: must start with <)
      // Shortcut simple #id case for speed
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

      init = jQuery.fn.init = function (selector, context, root) {
        var match, elem;

        // HANDLE: $(""), $(null), $(undefined), $(false)
        if (!selector) {
          return this;
        }

        // Method init() accepts an alternate rootjQuery
        // so migrate can support jQuery.sub (gh-2101)
        root = root || rootjQuery;

        // Handle HTML strings
        if (typeof selector === "string") {
          if (selector[0] === "<" &&
            selector[selector.length - 1] === ">" &&
            selector.length >= 3) {

            // Assume that strings that start and end with <> are HTML and skip the regex check
            match = [null, selector, null];

          } else {
            match = rquickExpr.exec(selector);
          }

          // Match html or make sure no context is specified for #id
          if (match && (match[1] || !context)) {

            // HANDLE: $(html) -> $(array)
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;

              // Option to run scripts is true for back-compat
              // Intentionally let the error be thrown if parseHTML is not present
              jQuery.merge(this, jQuery.parseHTML(
                match[1],
                context && context.nodeType ? context.ownerDocument || context : document,
                true
              ));

              // HANDLE: $(html, props)
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {

                  // Properties of context are called as methods if possible
                  if (isFunction(this[match])) {
                    this[match](context[match]);

                    // ...and otherwise set as attributes
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }

              return this;

              // HANDLE: $(#id)
            } else {
              elem = document.getElementById(match[2]);

              if (elem) {

                // Inject the element directly into the jQuery object
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }

            // HANDLE: $(expr, $(...))
          } else if (!context || context.jquery) {
            return (context || root).find(selector);

            // HANDLE: $(expr, context)
            // (which is just equivalent to: $(context).find(expr)
          } else {
            return this.constructor(context).find(selector);
          }

          // HANDLE: $(DOMElement)
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;

          // HANDLE: $(function)
          // Shortcut for document ready
        } else if (isFunction(selector)) {
          return root.ready !== undefined ?
            root.ready(selector) :

            // Execute immediately if ready is not present
            selector(jQuery);
        }

        return jQuery.makeArray(selector, this);
      };

    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

    // Initialize central reference
    rootjQuery = jQuery(document);


    var rparentsprev = /^(?:parents|prev(?:Until|All))/,

      // Methods guaranteed to produce a unique set when starting from a unique set
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };

    jQuery.fn.extend({
      has: function (target) {
        var targets = jQuery(target, this),
          l = targets.length;

        return this.filter(function () {
          var i = 0;
          for (; i < l; i++) {
            if (jQuery.contains(this, targets[i])) {
              return true;
            }
          }
        });
      },

      closest: function (selectors, context) {
        var cur,
          i = 0,
          l = this.length,
          matched = [],
          targets = typeof selectors !== "string" && jQuery(selectors);

        // Positional selectors never match, since there's no _selection_ context
        if (!rneedsContext.test(selectors)) {
          for (; i < l; i++) {
            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

              // Always skip document fragments
              if (cur.nodeType < 11 && (targets ?
                targets.index(cur) > -1 :

                // Don't pass non-elements to jQuery#find
                cur.nodeType === 1 &&
                jQuery.find.matchesSelector(cur, selectors))) {

                matched.push(cur);
                break;
              }
            }
          }
        }

        return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
      },

      // Determine the position of an element within the set
      index: function (elem) {

        // No argument, return index in parent
        if (!elem) {
          return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
        }

        // Index in selector
        if (typeof elem === "string") {
          return indexOf.call(jQuery(elem), this[0]);
        }

        // Locate the position of the desired element
        return indexOf.call(this,

          // If it receives a jQuery object, the first element is used
          elem.jquery ? elem[0] : elem
        );
      },

      add: function (selector, context) {
        return this.pushStack(
          jQuery.uniqueSort(
            jQuery.merge(this.get(), jQuery(selector, context))
          )
        );
      },

      addBack: function (selector) {
        return this.add(selector == null ?
          this.prevObject : this.prevObject.filter(selector)
        );
      }
    });

    function sibling(cur, dir) {
      while ((cur = cur[dir]) && cur.nodeType !== 1) { }
      return cur;
    }

    jQuery.each({
      parent: function (elem) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function (elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function (elem, _i, until) {
        return dir(elem, "parentNode", until);
      },
      next: function (elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function (elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function (elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function (elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function (elem, _i, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function (elem, _i, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function (elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function (elem) {
        return siblings(elem.firstChild);
      },
      contents: function (elem) {
        if (elem.contentDocument != null &&

          // Support: IE 11+
          // <object> elements with no `data` attribute has an object
          // `contentDocument` with a `null` prototype.
          getProto(elem.contentDocument)) {

          return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if (nodeName(elem, "template")) {
          elem = elem.content || elem;
        }

        return jQuery.merge([], elem.childNodes);
      }
    }, function (name, fn) {
      jQuery.fn[name] = function (until, selector) {
        var matched = jQuery.map(this, fn, until);

        if (name.slice(-5) !== "Until") {
          selector = until;
        }

        if (selector && typeof selector === "string") {
          matched = jQuery.filter(selector, matched);
        }

        if (this.length > 1) {

          // Remove duplicates
          if (!guaranteedUnique[name]) {
            jQuery.uniqueSort(matched);
          }

          // Reverse order for parents* and prev-derivatives
          if (rparentsprev.test(name)) {
            matched.reverse();
          }
        }

        return this.pushStack(matched);
      };
    });
    var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);



    // Convert String-formatted options into Object-formatted ones
    function createOptions(options) {
      var object = {};
      jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
        object[flag] = true;
      });
      return object;
    }

    /*
     * Create a callback list using the following parameters:
     *
     *	options: an optional list of space-separated options that will change how
     *			the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
    jQuery.Callbacks = function (options) {

      // Convert options from String-formatted to Object-formatted if needed
      // (we check in cache first)
      options = typeof options === "string" ?
        createOptions(options) :
        jQuery.extend({}, options);

      var // Flag to know if list is currently firing
        firing,

        // Last fire value for non-forgettable lists
        memory,

        // Flag to know if list was already fired
        fired,

        // Flag to prevent firing
        locked,

        // Actual callback list
        list = [],

        // Queue of execution data for repeatable lists
        queue = [],

        // Index of currently firing callback (modified by add/remove as needed)
        firingIndex = -1,

        // Fire callbacks
        fire = function () {

          // Enforce single-firing
          locked = locked || options.once;

          // Execute callbacks for all pending executions,
          // respecting firingIndex overrides and runtime changes
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {

              // Run callback and check for early termination
              if (list[firingIndex].apply(memory[0], memory[1]) === false &&
                options.stopOnFalse) {

                // Jump to end and forget the data so .add doesn't re-fire
                firingIndex = list.length;
                memory = false;
              }
            }
          }

          // Forget the data if we're done with it
          if (!options.memory) {
            memory = false;
          }

          firing = false;

          // Clean up if we're done firing for good
          if (locked) {

            // Keep an empty list if we have data for future add calls
            if (memory) {
              list = [];

              // Otherwise, this object is spent
            } else {
              list = "";
            }
          }
        },

        // Actual Callbacks object
        self = {

          // Add a callback or a collection of callbacks to the list
          add: function () {
            if (list) {

              // If we have memory from a past run, we should fire after adding
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }

              (function add(args) {
                jQuery.each(args, function (_, arg) {
                  if (isFunction(arg)) {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && toType(arg) !== "string") {

                    // Inspect recursively
                    add(arg);
                  }
                });
              })(arguments);

              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },

          // Remove a callback from the list
          remove: function () {
            jQuery.each(arguments, function (_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);

                // Handle firing indexes
                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },

          // Check if a given callback is in the list.
          // If no argument is given, return whether or not list has callbacks attached.
          has: function (fn) {
            return fn ?
              jQuery.inArray(fn, list) > -1 :
              list.length > 0;
          },

          // Remove all callbacks from the list
          empty: function () {
            if (list) {
              list = [];
            }
            return this;
          },

          // Disable .fire and .add
          // Abort any current/pending executions
          // Clear all callbacks and values
          disable: function () {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function () {
            return !list;
          },

          // Disable .fire
          // Also disable .add unless we have memory (since it would have no effect)
          // Abort any pending executions
          lock: function () {
            locked = queue = [];
            if (!memory && !firing) {
              list = memory = "";
            }
            return this;
          },
          locked: function () {
            return !!locked;
          },

          // Call all callbacks with the given context and arguments
          fireWith: function (context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },

          // Call all the callbacks with the given arguments
          fire: function () {
            self.fireWith(this, arguments);
            return this;
          },

          // To know if the callbacks have already been called at least once
          fired: function () {
            return !!fired;
          }
        };

      return self;
    };


    function Identity(v) {
      return v;
    }
    function Thrower(ex) {
      throw ex;
    }

    function adoptValue(value, resolve, reject, noValue) {
      var method;

      try {

        // Check for promise aspect first to privilege synchronous behavior
        if (value && isFunction((method = value.promise))) {
          method.call(value).done(resolve).fail(reject);

          // Other thenables
        } else if (value && isFunction((method = value.then))) {
          method.call(value, resolve, reject);

          // Other non-thenables
        } else {

          // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
          // * false: [ value ].slice( 0 ) => resolve( value )
          // * true: [ value ].slice( 1 ) => resolve()
          resolve.apply(undefined, [value].slice(noValue));
        }

        // For Promises/A+, convert exceptions into rejections
        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
        // Deferred#then to conditionally suppress rejection.
      } catch (value) {

        // Support: Android 4.0 only
        // Strict mode functions invoked without .call/.apply get global-object context
        reject.apply(undefined, [value]);
      }
    }

    jQuery.extend({

      Deferred: function (func) {
        var tuples = [

          // action, add listener, callbacks,
          // ... .then handlers, argument index, [final state]
          ["notify", "progress", jQuery.Callbacks("memory"),
            jQuery.Callbacks("memory"), 2],
          ["resolve", "done", jQuery.Callbacks("once memory"),
            jQuery.Callbacks("once memory"), 0, "resolved"],
          ["reject", "fail", jQuery.Callbacks("once memory"),
            jQuery.Callbacks("once memory"), 1, "rejected"]
        ],
          state = "pending",
          promise = {
            state: function () {
              return state;
            },
            always: function () {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function (fn) {
              return promise.then(null, fn);
            },

            // Keep pipe for back-compat
            pipe: function ( /* fnDone, fnFail, fnProgress */) {
              var fns = arguments;

              return jQuery.Deferred(function (newDefer) {
                jQuery.each(tuples, function (_i, tuple) {

                  // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                  var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];

                  // deferred.progress(function() { bind to newDefer or newDefer.notify })
                  // deferred.done(function() { bind to newDefer or newDefer.resolve })
                  // deferred.fail(function() { bind to newDefer or newDefer.reject })
                  deferred[tuple[1]](function () {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && isFunction(returned.promise)) {
                      returned.promise()
                        .progress(newDefer.notify)
                        .done(newDefer.resolve)
                        .fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](
                        this,
                        fn ? [returned] : arguments
                      );
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function (onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve(depth, deferred, handler, special) {
                return function () {
                  var that = this,
                    args = arguments,
                    mightThrow = function () {
                      var returned, then;

                      // Support: Promises/A+ section 2.3.3.3.3
                      // https://promisesaplus.com/#point-59
                      // Ignore double-resolution attempts
                      if (depth < maxDepth) {
                        return;
                      }

                      returned = handler.apply(that, args);

                      // Support: Promises/A+ section 2.3.1
                      // https://promisesaplus.com/#point-48
                      if (returned === deferred.promise()) {
                        throw new TypeError("Thenable self-resolution");
                      }

                      // Support: Promises/A+ sections 2.3.3.1, 3.5
                      // https://promisesaplus.com/#point-54
                      // https://promisesaplus.com/#point-75
                      // Retrieve `then` only once
                      then = returned &&

                        // Support: Promises/A+ section 2.3.4
                        // https://promisesaplus.com/#point-64
                        // Only check objects and functions for thenability
                        (typeof returned === "object" ||
                          typeof returned === "function") &&
                        returned.then;

                      // Handle a returned thenable
                      if (isFunction(then)) {

                        // Special processors (notify) just wait for resolution
                        if (special) {
                          then.call(
                            returned,
                            resolve(maxDepth, deferred, Identity, special),
                            resolve(maxDepth, deferred, Thrower, special)
                          );

                          // Normal processors (resolve) also hook into progress
                        } else {

                          // ...and disregard older resolution values
                          maxDepth++;

                          then.call(
                            returned,
                            resolve(maxDepth, deferred, Identity, special),
                            resolve(maxDepth, deferred, Thrower, special),
                            resolve(maxDepth, deferred, Identity,
                              deferred.notifyWith)
                          );
                        }

                        // Handle all other returned values
                      } else {

                        // Only substitute handlers pass on context
                        // and multiple values (non-spec behavior)
                        if (handler !== Identity) {
                          that = undefined;
                          args = [returned];
                        }

                        // Process the value(s)
                        // Default process is resolve
                        (special || deferred.resolveWith)(that, args);
                      }
                    },

                    // Only normal processors (resolve) catch and reject exceptions
                    process = special ?
                      mightThrow :
                      function () {
                        try {
                          mightThrow();
                        } catch (e) {

                          if (jQuery.Deferred.exceptionHook) {
                            jQuery.Deferred.exceptionHook(e,
                              process.error);
                          }

                          // Support: Promises/A+ section 2.3.3.3.4.1
                          // https://promisesaplus.com/#point-61
                          // Ignore post-resolution exceptions
                          if (depth + 1 >= maxDepth) {

                            // Only substitute handlers pass on context
                            // and multiple values (non-spec behavior)
                            if (handler !== Thrower) {
                              that = undefined;
                              args = [e];
                            }

                            deferred.rejectWith(that, args);
                          }
                        }
                      };

                  // Support: Promises/A+ section 2.3.3.3.1
                  // https://promisesaplus.com/#point-57
                  // Re-resolve promises immediately to dodge false rejection from
                  // subsequent errors
                  if (depth) {
                    process();
                  } else {

                    // Call an optional hook to record the error, in case of exception
                    // since it's otherwise lost when execution goes async
                    if (jQuery.Deferred.getErrorHook) {
                      process.error = jQuery.Deferred.getErrorHook();

                      // The deprecated alias of the above. While the name suggests
                      // returning the stack, not an error instance, jQuery just passes
                      // it directly to `console.warn` so both will work; an instance
                      // just better cooperates with source maps.
                    } else if (jQuery.Deferred.getStackHook) {
                      process.error = jQuery.Deferred.getStackHook();
                    }
                    window.setTimeout(process);
                  }
                };
              }

              return jQuery.Deferred(function (newDefer) {

                // progress_handlers.add( ... )
                tuples[0][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction(onProgress) ?
                      onProgress :
                      Identity,
                    newDefer.notifyWith
                  )
                );

                // fulfilled_handlers.add( ... )
                tuples[1][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction(onFulfilled) ?
                      onFulfilled :
                      Identity
                  )
                );

                // rejected_handlers.add( ... )
                tuples[2][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction(onRejected) ?
                      onRejected :
                      Thrower
                  )
                );
              }).promise();
            },

            // Get a promise for this deferred
            // If obj is provided, the promise aspect is added to the object
            promise: function (obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          },
          deferred = {};

        // Add list-specific methods
        jQuery.each(tuples, function (i, tuple) {
          var list = tuple[2],
            stateString = tuple[5];

          // promise.progress = list.add
          // promise.done = list.add
          // promise.fail = list.add
          promise[tuple[1]] = list.add;

          // Handle state
          if (stateString) {
            list.add(
              function () {

                // state = "resolved" (i.e., fulfilled)
                // state = "rejected"
                state = stateString;
              },

              // rejected_callbacks.disable
              // fulfilled_callbacks.disable
              tuples[3 - i][2].disable,

              // rejected_handlers.disable
              // fulfilled_handlers.disable
              tuples[3 - i][3].disable,

              // progress_callbacks.lock
              tuples[0][2].lock,

              // progress_handlers.lock
              tuples[0][3].lock
            );
          }

          // progress_handlers.fire
          // fulfilled_handlers.fire
          // rejected_handlers.fire
          list.add(tuple[3].fire);

          // deferred.notify = function() { deferred.notifyWith(...) }
          // deferred.resolve = function() { deferred.resolveWith(...) }
          // deferred.reject = function() { deferred.rejectWith(...) }
          deferred[tuple[0]] = function () {
            deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
            return this;
          };

          // deferred.notifyWith = list.fireWith
          // deferred.resolveWith = list.fireWith
          // deferred.rejectWith = list.fireWith
          deferred[tuple[0] + "With"] = list.fireWith;
        });

        // Make the deferred a promise
        promise.promise(deferred);

        // Call given func if any
        if (func) {
          func.call(deferred, deferred);
        }

        // All done!
        return deferred;
      },

      // Deferred helper
      when: function (singleValue) {
        var

          // count of uncompleted subordinates
          remaining = arguments.length,

          // count of unprocessed arguments
          i = remaining,

          // subordinate fulfillment data
          resolveContexts = Array(i),
          resolveValues = slice.call(arguments),

          // the primary Deferred
          primary = jQuery.Deferred(),

          // subordinate callback factory
          updateFunc = function (i) {
            return function (value) {
              resolveContexts[i] = this;
              resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
              if (!(--remaining)) {
                primary.resolveWith(resolveContexts, resolveValues);
              }
            };
          };

        // Single- and empty arguments are adopted like Promise.resolve
        if (remaining <= 1) {
          adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject,
            !remaining);

          // Use .then() to unwrap secondary thenables (cf. gh-3000)
          if (primary.state() === "pending" ||
            isFunction(resolveValues[i] && resolveValues[i].then)) {

            return primary.then();
          }
        }

        // Multiple arguments are aggregated like Promise.all array elements
        while (i--) {
          adoptValue(resolveValues[i], updateFunc(i), primary.reject);
        }

        return primary.promise();
      }
    });


    // These usually indicate a programmer mistake during development,
    // warn about them ASAP rather than swallowing them by default.
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

    // If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
    // captured before the async barrier to get the original error cause
    // which may otherwise be hidden.
    jQuery.Deferred.exceptionHook = function (error, asyncError) {

      // Support: IE 8 - 9 only
      // Console exists when dev tools are open, which can happen at any time
      if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
        window.console.warn("jQuery.Deferred exception: " + error.message,
          error.stack, asyncError);
      }
    };




    jQuery.readyException = function (error) {
      window.setTimeout(function () {
        throw error;
      });
    };




    // The deferred used on DOM ready
    var readyList = jQuery.Deferred();

    jQuery.fn.ready = function (fn) {

      readyList
        .then(fn)

        // Wrap jQuery.readyException in a function so that the lookup
        // happens at the time of error handling instead of callback
        // registration.
        .catch(function (error) {
          jQuery.readyException(error);
        });

      return this;
    };

    jQuery.extend({

      // Is the DOM ready to be used? Set to true once it occurs.
      isReady: false,

      // A counter to track how many items to wait for before
      // the ready event fires. See trac-6781
      readyWait: 1,

      // Handle when the DOM is ready
      ready: function (wait) {

        // Abort if there are pending holds or we're already ready
        if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
          return;
        }

        // Remember that the DOM is ready
        jQuery.isReady = true;

        // If a normal DOM Ready event fired, decrement, and wait if need be
        if (wait !== true && --jQuery.readyWait > 0) {
          return;
        }

        // If there are functions bound, to execute
        readyList.resolveWith(document, [jQuery]);
      }
    });

    jQuery.ready.then = readyList.then;

    // The ready event handler and self cleanup method
    function completed() {
      document.removeEventListener("DOMContentLoaded", completed);
      window.removeEventListener("load", completed);
      jQuery.ready();
    }

    // Catch cases where $(document).ready() is called
    // after the browser event has already occurred.
    // Support: IE <=9 - 10 only
    // Older IE sometimes signals "interactive" too soon
    if (document.readyState === "complete" ||
      (document.readyState !== "loading" && !document.documentElement.doScroll)) {

      // Handle it asynchronously to allow scripts the opportunity to delay ready
      window.setTimeout(jQuery.ready);

    } else {

      // Use the handy event callback
      document.addEventListener("DOMContentLoaded", completed);

      // A fallback to window.onload, that will always work
      window.addEventListener("load", completed);
    }




    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0,
        len = elems.length,
        bulk = key == null;

      // Sets many values
      if (toType(key) === "object") {
        chainable = true;
        for (i in key) {
          access(elems, fn, i, key[i], true, emptyGet, raw);
        }

        // Sets one value
      } else if (value !== undefined) {
        chainable = true;

        if (!isFunction(value)) {
          raw = true;
        }

        if (bulk) {

          // Bulk operations run against the entire set
          if (raw) {
            fn.call(elems, value);
            fn = null;

            // ...except when executing function values
          } else {
            bulk = fn;
            fn = function (elem, _key, value) {
              return bulk.call(jQuery(elem), value);
            };
          }
        }

        if (fn) {
          for (; i < len; i++) {
            fn(
              elems[i], key, raw ?
              value :
              value.call(elems[i], i, fn(elems[i], key))
            );
          }
        }
      }

      if (chainable) {
        return elems;
      }

      // Gets
      if (bulk) {
        return fn.call(elems);
      }

      return len ? fn(elems[0], key) : emptyGet;
    };


    // Matches dashed string for camelizing
    var rmsPrefix = /^-ms-/,
      rdashAlpha = /-([a-z])/g;

    // Used by camelCase as callback to replace()
    function fcamelCase(_all, letter) {
      return letter.toUpperCase();
    }

    // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 15
    // Microsoft forgot to hump their vendor prefix (trac-9572)
    function camelCase(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function (owner) {

      // Accepts only:
      //  - Node
      //    - Node.ELEMENT_NODE
      //    - Node.DOCUMENT_NODE
      //  - Object
      //    - Any
      return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
    };




    function Data() {
      this.expando = jQuery.expando + Data.uid++;
    }

    Data.uid = 1;

    Data.prototype = {

      cache: function (owner) {

        // Check if the owner object already has a cache
        var value = owner[this.expando];

        // If not, create one
        if (!value) {
          value = {};

          // We can accept data for non-element nodes in modern browsers,
          // but we should not, see trac-8335.
          // Always return an empty object.
          if (acceptData(owner)) {

            // If it is a node unlikely to be stringify-ed or looped over
            // use plain assignment
            if (owner.nodeType) {
              owner[this.expando] = value;

              // Otherwise secure it in a non-enumerable property
              // configurable must be true to allow the property to be
              // deleted when data is removed
            } else {
              Object.defineProperty(owner, this.expando, {
                value: value,
                configurable: true
              });
            }
          }
        }

        return value;
      },
      set: function (owner, data, value) {
        var prop,
          cache = this.cache(owner);

        // Handle: [ owner, key, value ] args
        // Always use camelCase key (gh-2257)
        if (typeof data === "string") {
          cache[camelCase(data)] = value;

          // Handle: [ owner, { properties } ] args
        } else {

          // Copy the properties one-by-one to the cache object
          for (prop in data) {
            cache[camelCase(prop)] = data[prop];
          }
        }
        return cache;
      },
      get: function (owner, key) {
        return key === undefined ?
          this.cache(owner) :

          // Always use camelCase key (gh-2257)
          owner[this.expando] && owner[this.expando][camelCase(key)];
      },
      access: function (owner, key, value) {

        // In cases where either:
        //
        //   1. No key was specified
        //   2. A string key was specified, but no value provided
        //
        // Take the "read" path and allow the get method to determine
        // which value to return, respectively either:
        //
        //   1. The entire cache object
        //   2. The data stored at the key
        //
        if (key === undefined ||
          ((key && typeof key === "string") && value === undefined)) {

          return this.get(owner, key);
        }

        // When the key is not a string, or both a key and value
        // are specified, set or extend (existing objects) with either:
        //
        //   1. An object of properties
        //   2. A key and value
        //
        this.set(owner, key, value);

        // Since the "set" path can have two possible entry points
        // return the expected data based on which path was taken[*]
        return value !== undefined ? value : key;
      },
      remove: function (owner, key) {
        var i,
          cache = owner[this.expando];

        if (cache === undefined) {
          return;
        }

        if (key !== undefined) {

          // Support array or space separated string of keys
          if (Array.isArray(key)) {

            // If key is an array of keys...
            // We always set camelCase keys, so remove that.
            key = key.map(camelCase);
          } else {
            key = camelCase(key);

            // If a key with the spaces exists, use it.
            // Otherwise, create an array by matching non-whitespace
            key = key in cache ?
              [key] :
              (key.match(rnothtmlwhite) || []);
          }

          i = key.length;

          while (i--) {
            delete cache[key[i]];
          }
        }

        // Remove the expando if there's no more data
        if (key === undefined || jQuery.isEmptyObject(cache)) {

          // Support: Chrome <=35 - 45
          // Webkit & Blink performance suffers when deleting properties
          // from DOM nodes, so set to undefined instead
          // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
          if (owner.nodeType) {
            owner[this.expando] = undefined;
          } else {
            delete owner[this.expando];
          }
        }
      },
      hasData: function (owner) {
        var cache = owner[this.expando];
        return cache !== undefined && !jQuery.isEmptyObject(cache);
      }
    };
    var dataPriv = new Data();

    var dataUser = new Data();



    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;

    function getData(data) {
      if (data === "true") {
        return true;
      }

      if (data === "false") {
        return false;
      }

      if (data === "null") {
        return null;
      }

      // Only convert to a number if it doesn't change the string
      if (data === +data + "") {
        return +data;
      }

      if (rbrace.test(data)) {
        return JSON.parse(data);
      }

      return data;
    }

    function dataAttr(elem, key, data) {
      var name;

      // If nothing was found internally, try to fetch any
      // data from the HTML5 data-* attribute
      if (data === undefined && elem.nodeType === 1) {
        name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
        data = elem.getAttribute(name);

        if (typeof data === "string") {
          try {
            data = getData(data);
          } catch (e) { }

          // Make sure we set the data so it isn't changed later
          dataUser.set(elem, key, data);
        } else {
          data = undefined;
        }
      }
      return data;
    }

    jQuery.extend({
      hasData: function (elem) {
        return dataUser.hasData(elem) || dataPriv.hasData(elem);
      },

      data: function (elem, name, data) {
        return dataUser.access(elem, name, data);
      },

      removeData: function (elem, name) {
        dataUser.remove(elem, name);
      },

      // TODO: Now that all calls to _data and _removeData have been replaced
      // with direct calls to dataPriv methods, these can be deprecated.
      _data: function (elem, name, data) {
        return dataPriv.access(elem, name, data);
      },

      _removeData: function (elem, name) {
        dataPriv.remove(elem, name);
      }
    });

    jQuery.fn.extend({
      data: function (key, value) {
        var i, name, data,
          elem = this[0],
          attrs = elem && elem.attributes;

        // Gets all values
        if (key === undefined) {
          if (this.length) {
            data = dataUser.get(elem);

            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
              i = attrs.length;
              while (i--) {

                // Support: IE 11 only
                // The attrs elements can be null (trac-14894)
                if (attrs[i]) {
                  name = attrs[i].name;
                  if (name.indexOf("data-") === 0) {
                    name = camelCase(name.slice(5));
                    dataAttr(elem, name, data[name]);
                  }
                }
              }
              dataPriv.set(elem, "hasDataAttrs", true);
            }
          }

          return data;
        }

        // Sets multiple values
        if (typeof key === "object") {
          return this.each(function () {
            dataUser.set(this, key);
          });
        }

        return access(this, function (value) {
          var data;

          // The calling jQuery object (element matches) is not empty
          // (and therefore has an element appears at this[ 0 ]) and the
          // `value` parameter was not undefined. An empty jQuery object
          // will result in `undefined` for elem = this[ 0 ] which will
          // throw an exception if an attempt to read a data cache is made.
          if (elem && value === undefined) {

            // Attempt to get data from the cache
            // The key will always be camelCased in Data
            data = dataUser.get(elem, key);
            if (data !== undefined) {
              return data;
            }

            // Attempt to "discover" the data in
            // HTML5 custom data-* attrs
            data = dataAttr(elem, key);
            if (data !== undefined) {
              return data;
            }

            // We tried really hard, but the data doesn't exist.
            return;
          }

          // Set the data...
          this.each(function () {

            // We always store the camelCased key
            dataUser.set(this, key, value);
          });
        }, null, value, arguments.length > 1, null, true);
      },

      removeData: function (key) {
        return this.each(function () {
          dataUser.remove(this, key);
        });
      }
    });


    jQuery.extend({
      queue: function (elem, type, data) {
        var queue;

        if (elem) {
          type = (type || "fx") + "queue";
          queue = dataPriv.get(elem, type);

          // Speed up dequeue by getting out quickly if this is just a lookup
          if (data) {
            if (!queue || Array.isArray(data)) {
              queue = dataPriv.access(elem, type, jQuery.makeArray(data));
            } else {
              queue.push(data);
            }
          }
          return queue || [];
        }
      },

      dequeue: function (elem, type) {
        type = type || "fx";

        var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function () {
            jQuery.dequeue(elem, type);
          };

        // If the fx queue is dequeued, always remove the progress sentinel
        if (fn === "inprogress") {
          fn = queue.shift();
          startLength--;
        }

        if (fn) {

          // Add a progress sentinel to prevent the fx queue from being
          // automatically dequeued
          if (type === "fx") {
            queue.unshift("inprogress");
          }

          // Clear up the last queue stop function
          delete hooks.stop;
          fn.call(elem, next, hooks);
        }

        if (!startLength && hooks) {
          hooks.empty.fire();
        }
      },

      // Not public - generate a queueHooks object, or return the current one
      _queueHooks: function (elem, type) {
        var key = type + "queueHooks";
        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
          empty: jQuery.Callbacks("once memory").add(function () {
            dataPriv.remove(elem, [type + "queue", key]);
          })
        });
      }
    });

    jQuery.fn.extend({
      queue: function (type, data) {
        var setter = 2;

        if (typeof type !== "string") {
          data = type;
          type = "fx";
          setter--;
        }

        if (arguments.length < setter) {
          return jQuery.queue(this[0], type);
        }

        return data === undefined ?
          this :
          this.each(function () {
            var queue = jQuery.queue(this, type, data);

            // Ensure a hooks for this queue
            jQuery._queueHooks(this, type);

            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery.dequeue(this, type);
            }
          });
      },
      dequeue: function (type) {
        return this.each(function () {
          jQuery.dequeue(this, type);
        });
      },
      clearQueue: function (type) {
        return this.queue(type || "fx", []);
      },

      // Get a promise resolved when queues of a certain type
      // are emptied (fx is the type by default)
      promise: function (type, obj) {
        var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function () {
            if (!(--count)) {
              defer.resolveWith(elements, [elements]);
            }
          };

        if (typeof type !== "string") {
          obj = type;
          type = undefined;
        }
        type = type || "fx";

        while (i--) {
          tmp = dataPriv.get(elements[i], type + "queueHooks");
          if (tmp && tmp.empty) {
            count++;
            tmp.empty.add(resolve);
          }
        }
        resolve();
        return defer.promise(obj);
      }
    });
    var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");


    var cssExpand = ["Top", "Right", "Bottom", "Left"];

    var documentElement = document.documentElement;



    var isAttached = function (elem) {
      return jQuery.contains(elem.ownerDocument, elem);
    },
      composed = { composed: true };

    // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
    // Check attachment across shadow DOM boundaries when possible (gh-3504)
    // Support: iOS 10.0-10.2 only
    // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
    // leading to errors. We need to check for `getRootNode`.
    if (documentElement.getRootNode) {
      isAttached = function (elem) {
        return jQuery.contains(elem.ownerDocument, elem) ||
          elem.getRootNode(composed) === elem.ownerDocument;
      };
    }
    var isHiddenWithinTree = function (elem, el) {

      // isHiddenWithinTree might be called from jQuery#filter function;
      // in that case, element will be second argument
      elem = el || elem;

      // Inline style trumps all
      return elem.style.display === "none" ||
        elem.style.display === "" &&

        // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) &&

        jQuery.css(elem, "display") === "none";
    };



    function adjustCSS(elem, prop, valueParts, tween) {
      var adjusted, scale,
        maxIterations = 20,
        currentValue = tween ?
          function () {
            return tween.cur();
          } :
          function () {
            return jQuery.css(elem, prop, "");
          },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),

        // Starting value computation is required for potential unit mismatches
        initialInUnit = elem.nodeType &&
          (jQuery.cssNumber[prop] || unit !== "px" && +initial) &&
          rcssNum.exec(jQuery.css(elem, prop));

      if (initialInUnit && initialInUnit[3] !== unit) {

        // Support: Firefox <=54
        // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
        initial = initial / 2;

        // Trust units reported by jQuery.css
        unit = unit || initialInUnit[3];

        // Iteratively approximate from a nonzero starting point
        initialInUnit = +initial || 1;

        while (maxIterations--) {

          // Evaluate and update our best guess (doubling guesses that zero out).
          // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
          jQuery.style(elem, prop, initialInUnit + unit);
          if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
            maxIterations = 0;
          }
          initialInUnit = initialInUnit / scale;

        }

        initialInUnit = initialInUnit * 2;
        jQuery.style(elem, prop, initialInUnit + unit);

        // Make sure we update the tween properties later on
        valueParts = valueParts || [];
      }

      if (valueParts) {
        initialInUnit = +initialInUnit || +initial || 0;

        // Apply relative offset (+=/-=) if specified
        adjusted = valueParts[1] ?
          initialInUnit + (valueParts[1] + 1) * valueParts[2] :
          +valueParts[2];
        if (tween) {
          tween.unit = unit;
          tween.start = initialInUnit;
          tween.end = adjusted;
        }
      }
      return adjusted;
    }


    var defaultDisplayMap = {};

    function getDefaultDisplay(elem) {
      var temp,
        doc = elem.ownerDocument,
        nodeName = elem.nodeName,
        display = defaultDisplayMap[nodeName];

      if (display) {
        return display;
      }

      temp = doc.body.appendChild(doc.createElement(nodeName));
      display = jQuery.css(temp, "display");

      temp.parentNode.removeChild(temp);

      if (display === "none") {
        display = "block";
      }
      defaultDisplayMap[nodeName] = display;

      return display;
    }

    function showHide(elements, show) {
      var display, elem,
        values = [],
        index = 0,
        length = elements.length;

      // Determine new display value for elements that need to change
      for (; index < length; index++) {
        elem = elements[index];
        if (!elem.style) {
          continue;
        }

        display = elem.style.display;
        if (show) {

          // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
          // check is required in this first loop unless we have a nonempty display value (either
          // inline or about-to-be-restored)
          if (display === "none") {
            values[index] = dataPriv.get(elem, "display") || null;
            if (!values[index]) {
              elem.style.display = "";
            }
          }
          if (elem.style.display === "" && isHiddenWithinTree(elem)) {
            values[index] = getDefaultDisplay(elem);
          }
        } else {
          if (display !== "none") {
            values[index] = "none";

            // Remember what we're overwriting
            dataPriv.set(elem, "display", display);
          }
        }
      }

      // Set the display of the elements in a second loop to avoid constant reflow
      for (index = 0; index < length; index++) {
        if (values[index] != null) {
          elements[index].style.display = values[index];
        }
      }

      return elements;
    }

    jQuery.fn.extend({
      show: function () {
        return showHide(this, true);
      },
      hide: function () {
        return showHide(this);
      },
      toggle: function (state) {
        if (typeof state === "boolean") {
          return state ? this.show() : this.hide();
        }

        return this.each(function () {
          if (isHiddenWithinTree(this)) {
            jQuery(this).show();
          } else {
            jQuery(this).hide();
          }
        });
      }
    });
    var rcheckableType = (/^(?:checkbox|radio)$/i);

    var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]*)/i);

    var rscriptType = (/^$|^module$|\/(?:java|ecma)script/i);



    (function () {
      var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input");

      // Support: Android 4.0 - 4.3 only
      // Check state lost if the name is set (trac-11217)
      // Support: Windows Web Apps (WWA)
      // `name` and `type` must use .setAttribute for WWA (trac-14901)
      input.setAttribute("type", "radio");
      input.setAttribute("checked", "checked");
      input.setAttribute("name", "t");

      div.appendChild(input);

      // Support: Android <=4.1 only
      // Older WebKit doesn't clone checked state correctly in fragments
      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

      // Support: IE <=11 only
      // Make sure textarea (and checkbox) defaultValue is properly cloned
      div.innerHTML = "<textarea>x</textarea>";
      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;

      // Support: IE <=9 only
      // IE <=9 replaces <option> tags with their contents when inserted outside of
      // the select element.
      div.innerHTML = "<option></option>";
      support.option = !!div.lastChild;
    })();


    // We have to close these tags to support XHTML (trac-13200)
    var wrapMap = {

      // XHTML parsers do not magically insert elements in the
      // same way that tag soup parsers do. So we cannot shorten
      // this by omitting <tbody> or other required elements.
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

      _default: [0, "", ""]
    };

    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // Support: IE <=9 only
    if (!support.option) {
      wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
    }


    function getAll(context, tag) {

      // Support: IE <=9 - 11 only
      // Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
      var ret;

      if (typeof context.getElementsByTagName !== "undefined") {
        ret = context.getElementsByTagName(tag || "*");

      } else if (typeof context.querySelectorAll !== "undefined") {
        ret = context.querySelectorAll(tag || "*");

      } else {
        ret = [];
      }

      if (tag === undefined || tag && nodeName(context, tag)) {
        return jQuery.merge([context], ret);
      }

      return ret;
    }


    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
      var i = 0,
        l = elems.length;

      for (; i < l; i++) {
        dataPriv.set(
          elems[i],
          "globalEval",
          !refElements || dataPriv.get(refElements[i], "globalEval")
        );
      }
    }


    var rhtml = /<|&#?\w+;/;

    function buildFragment(elems, context, scripts, selection, ignored) {
      var elem, tmp, tag, wrap, attached, j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;

      for (; i < l; i++) {
        elem = elems[i];

        if (elem || elem === 0) {

          // Add nodes directly
          if (toType(elem) === "object") {

            // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

            // Convert non-html into a text node
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));

            // Convert html into DOM nodes
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));

            // Deserialize a standard representation
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

            // Descend through wrappers to the right content
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }

            // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit
            jQuery.merge(nodes, tmp.childNodes);

            // Remember the top-level container
            tmp = fragment.firstChild;

            // Ensure the created nodes are orphaned (trac-12392)
            tmp.textContent = "";
          }
        }
      }

      // Remove wrapper from fragment
      fragment.textContent = "";

      i = 0;
      while ((elem = nodes[i++])) {

        // Skip elements already in the context collection (trac-4087)
        if (selection && jQuery.inArray(elem, selection) > -1) {
          if (ignored) {
            ignored.push(elem);
          }
          continue;
        }

        attached = isAttached(elem);

        // Append to fragment
        tmp = getAll(fragment.appendChild(elem), "script");

        // Preserve script evaluation history
        if (attached) {
          setGlobalEval(tmp);
        }

        // Capture executables
        if (scripts) {
          j = 0;
          while ((elem = tmp[j++])) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }

      return fragment;
    }


    var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

    function returnTrue() {
      return true;
    }

    function returnFalse() {
      return false;
    }

    function on(elem, types, selector, data, fn, one) {
      var origFn, type;

      // Types can be a map of types/handlers
      if (typeof types === "object") {

        // ( types-Object, selector, data )
        if (typeof selector !== "string") {

          // ( types-Object, data )
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          on(elem, type, selector, data, types[type], one);
        }
        return elem;
      }

      if (data == null && fn == null) {

        // ( types, fn )
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {

          // ( types, selector, fn )
          fn = data;
          data = undefined;
        } else {

          // ( types, data, fn )
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return elem;
      }

      if (one === 1) {
        origFn = fn;
        fn = function (event) {

          // Can use an empty set, since event contains the info
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };

        // Use same guid so caller can remove using origFn
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return elem.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    }

    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
    jQuery.event = {

      global: {},

      add: function (elem, types, handler, data, selector) {

        var handleObjIn, eventHandle, tmp,
          events, t, handleObj,
          special, handlers, type, namespaces, origType,
          elemData = dataPriv.get(elem);

        // Only attach events to objects that accept data
        if (!acceptData(elem)) {
          return;
        }

        // Caller can pass in an object of custom data in lieu of the handler
        if (handler.handler) {
          handleObjIn = handler;
          handler = handleObjIn.handler;
          selector = handleObjIn.selector;
        }

        // Ensure that invalid selectors throw exceptions at attach time
        // Evaluate against documentElement in case elem is a non-element node (e.g., document)
        if (selector) {
          jQuery.find.matchesSelector(documentElement, selector);
        }

        // Make sure that the handler has a unique ID, used to find/remove it later
        if (!handler.guid) {
          handler.guid = jQuery.guid++;
        }

        // Init the element's event structure and main handler, if this is the first
        if (!(events = elemData.events)) {
          events = elemData.events = Object.create(null);
        }
        if (!(eventHandle = elemData.handle)) {
          eventHandle = elemData.handle = function (e) {

            // Discard the second event of a jQuery.event.trigger() and
            // when an event is called after a page has unloaded
            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
              jQuery.event.dispatch.apply(elem, arguments) : undefined;
          };
        }

        // Handle multiple events separated by a space
        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();

          // There *must* be a type, no attaching namespace-only handlers
          if (!type) {
            continue;
          }

          // If event changes its type, use the special event handlers for the changed type
          special = jQuery.event.special[type] || {};

          // If selector defined, determine special event api type, otherwise given type
          type = (selector ? special.delegateType : special.bindType) || type;

          // Update special based on newly reset type
          special = jQuery.event.special[type] || {};

          // handleObj is passed to all event handlers
          handleObj = jQuery.extend({
            type: type,
            origType: origType,
            data: data,
            handler: handler,
            guid: handler.guid,
            selector: selector,
            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
            namespace: namespaces.join(".")
          }, handleObjIn);

          // Init the event handler queue if we're the first
          if (!(handlers = events[type])) {
            handlers = events[type] = [];
            handlers.delegateCount = 0;

            // Only use addEventListener if the special events handler returns false
            if (!special.setup ||
              special.setup.call(elem, data, namespaces, eventHandle) === false) {

              if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle);
              }
            }
          }

          if (special.add) {
            special.add.call(elem, handleObj);

            if (!handleObj.handler.guid) {
              handleObj.handler.guid = handler.guid;
            }
          }

          // Add to the element's handler list, delegates in front
          if (selector) {
            handlers.splice(handlers.delegateCount++, 0, handleObj);
          } else {
            handlers.push(handleObj);
          }

          // Keep track of which events have ever been used, for event optimization
          jQuery.event.global[type] = true;
        }

      },

      // Detach an event or set of events from an element
      remove: function (elem, types, handler, selector, mappedTypes) {

        var j, origCount, tmp,
          events, t, handleObj,
          special, handlers, type, namespaces, origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

        if (!elemData || !(events = elemData.events)) {
          return;
        }

        // Once for each type.namespace in types; type may be omitted
        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();

          // Unbind all events (on this namespace, if provided) for the element
          if (!type) {
            for (type in events) {
              jQuery.event.remove(elem, type + types[t], handler, selector, true);
            }
            continue;
          }

          special = jQuery.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          handlers = events[type] || [];
          tmp = tmp[2] &&
            new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

          // Remove matching events
          origCount = j = handlers.length;
          while (j--) {
            handleObj = handlers[j];

            if ((mappedTypes || origType === handleObj.origType) &&
              (!handler || handler.guid === handleObj.guid) &&
              (!tmp || tmp.test(handleObj.namespace)) &&
              (!selector || selector === handleObj.selector ||
                selector === "**" && handleObj.selector)) {
              handlers.splice(j, 1);

              if (handleObj.selector) {
                handlers.delegateCount--;
              }
              if (special.remove) {
                special.remove.call(elem, handleObj);
              }
            }
          }

          // Remove generic event handler if we removed something and no more handlers exist
          // (avoids potential for endless recursion during removal of special event handlers)
          if (origCount && !handlers.length) {
            if (!special.teardown ||
              special.teardown.call(elem, namespaces, elemData.handle) === false) {

              jQuery.removeEvent(elem, type, elemData.handle);
            }

            delete events[type];
          }
        }

        // Remove data and the expando if it's no longer used
        if (jQuery.isEmptyObject(events)) {
          dataPriv.remove(elem, "handle events");
        }
      },

      dispatch: function (nativeEvent) {

        var i, j, ret, matched, handleObj, handlerQueue,
          args = new Array(arguments.length),

          // Make a writable jQuery.Event from the native event object
          event = jQuery.event.fix(nativeEvent),

          handlers = (
            dataPriv.get(this, "events") || Object.create(null)
          )[event.type] || [],
          special = jQuery.event.special[event.type] || {};

        // Use the fix-ed jQuery.Event rather than the (read-only) native event
        args[0] = event;

        for (i = 1; i < arguments.length; i++) {
          args[i] = arguments[i];
        }

        event.delegateTarget = this;

        // Call the preDispatch hook for the mapped type, and let it bail if desired
        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
          return;
        }

        // Determine handlers
        handlerQueue = jQuery.event.handlers.call(this, event, handlers);

        // Run delegates first; they may want to stop propagation beneath us
        i = 0;
        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
          event.currentTarget = matched.elem;

          j = 0;
          while ((handleObj = matched.handlers[j++]) &&
            !event.isImmediatePropagationStopped()) {

            // If the event is namespaced, then each handler is only invoked if it is
            // specially universal or its namespaces are a superset of the event's.
            if (!event.rnamespace || handleObj.namespace === false ||
              event.rnamespace.test(handleObj.namespace)) {

              event.handleObj = handleObj;
              event.data = handleObj.data;

              ret = ((jQuery.event.special[handleObj.origType] || {}).handle ||
                handleObj.handler).apply(matched.elem, args);

              if (ret !== undefined) {
                if ((event.result = ret) === false) {
                  event.preventDefault();
                  event.stopPropagation();
                }
              }
            }
          }
        }

        // Call the postDispatch hook for the mapped type
        if (special.postDispatch) {
          special.postDispatch.call(this, event);
        }

        return event.result;
      },

      handlers: function (event, handlers) {
        var i, handleObj, sel, matchedHandlers, matchedSelectors,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target;

        // Find delegate handlers
        if (delegateCount &&

          // Support: IE <=9
          // Black-hole SVG <use> instance trees (trac-13180)
          cur.nodeType &&

          // Support: Firefox <=42
          // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
          // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
          // Support: IE 11 only
          // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
          !(event.type === "click" && event.button >= 1)) {

          for (; cur !== this; cur = cur.parentNode || this) {

            // Don't check non-elements (trac-13208)
            // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
              matchedHandlers = [];
              matchedSelectors = {};
              for (i = 0; i < delegateCount; i++) {
                handleObj = handlers[i];

                // Don't conflict with Object.prototype properties (trac-13203)
                sel = handleObj.selector + " ";

                if (matchedSelectors[sel] === undefined) {
                  matchedSelectors[sel] = handleObj.needsContext ?
                    jQuery(sel, this).index(cur) > -1 :
                    jQuery.find(sel, this, null, [cur]).length;
                }
                if (matchedSelectors[sel]) {
                  matchedHandlers.push(handleObj);
                }
              }
              if (matchedHandlers.length) {
                handlerQueue.push({ elem: cur, handlers: matchedHandlers });
              }
            }
          }
        }

        // Add the remaining (directly-bound) handlers
        cur = this;
        if (delegateCount < handlers.length) {
          handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
        }

        return handlerQueue;
      },

      addProp: function (name, hook) {
        Object.defineProperty(jQuery.Event.prototype, name, {
          enumerable: true,
          configurable: true,

          get: isFunction(hook) ?
            function () {
              if (this.originalEvent) {
                return hook(this.originalEvent);
              }
            } :
            function () {
              if (this.originalEvent) {
                return this.originalEvent[name];
              }
            },

          set: function (value) {
            Object.defineProperty(this, name, {
              enumerable: true,
              configurable: true,
              writable: true,
              value: value
            });
          }
        });
      },

      fix: function (originalEvent) {
        return originalEvent[jQuery.expando] ?
          originalEvent :
          new jQuery.Event(originalEvent);
      },

      special: {
        load: {

          // Prevent triggered image.load events from bubbling to window.load
          noBubble: true
        },
        click: {

          // Utilize native event to ensure correct state for checkable inputs
          setup: function (data) {

            // For mutual compressibility with _default, replace `this` access with a local var.
            // `|| data` is dead code meant only to preserve the variable through minification.
            var el = this || data;

            // Claim the first handler
            if (rcheckableType.test(el.type) &&
              el.click && nodeName(el, "input")) {

              // dataPriv.set( el, "click", ... )
              leverageNative(el, "click", true);
            }

            // Return false to allow normal processing in the caller
            return false;
          },
          trigger: function (data) {

            // For mutual compressibility with _default, replace `this` access with a local var.
            // `|| data` is dead code meant only to preserve the variable through minification.
            var el = this || data;

            // Force setup before triggering a click
            if (rcheckableType.test(el.type) &&
              el.click && nodeName(el, "input")) {

              leverageNative(el, "click");
            }

            // Return non-false to allow normal event-path propagation
            return true;
          },

          // For cross-browser consistency, suppress native .click() on links
          // Also prevent it if we're currently inside a leveraged native-event stack
          _default: function (event) {
            var target = event.target;
            return rcheckableType.test(target.type) &&
              target.click && nodeName(target, "input") &&
              dataPriv.get(target, "click") ||
              nodeName(target, "a");
          }
        },

        beforeunload: {
          postDispatch: function (event) {

            // Support: Firefox 20+
            // Firefox doesn't alert if the returnValue field is not set.
            if (event.result !== undefined && event.originalEvent) {
              event.originalEvent.returnValue = event.result;
            }
          }
        }
      }
    };

    // Ensure the presence of an event listener that handles manually-triggered
    // synthetic events by interrupting progress until reinvoked in response to
    // *native* events that it fires directly, ensuring that state changes have
    // already occurred before other listeners are invoked.
    function leverageNative(el, type, isSetup) {

      // Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
      if (!isSetup) {
        if (dataPriv.get(el, type) === undefined) {
          jQuery.event.add(el, type, returnTrue);
        }
        return;
      }

      // Register the controller as a special universal handler for all event namespaces
      dataPriv.set(el, type, false);
      jQuery.event.add(el, type, {
        namespace: false,
        handler: function (event) {
          var result,
            saved = dataPriv.get(this, type);

          if ((event.isTrigger & 1) && this[type]) {

            // Interrupt processing of the outer synthetic .trigger()ed event
            if (!saved) {

              // Store arguments for use when handling the inner native event
              // There will always be at least one argument (an event object), so this array
              // will not be confused with a leftover capture object.
              saved = slice.call(arguments);
              dataPriv.set(this, type, saved);

              // Trigger the native event and capture its result
              this[type]();
              result = dataPriv.get(this, type);
              dataPriv.set(this, type, false);

              if (saved !== result) {

                // Cancel the outer synthetic event
                event.stopImmediatePropagation();
                event.preventDefault();

                return result;
              }

              // If this is an inner synthetic event for an event with a bubbling surrogate
              // (focus or blur), assume that the surrogate already propagated from triggering
              // the native event and prevent that from happening again here.
              // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
              // bubbling surrogate propagates *after* the non-bubbling base), but that seems
              // less bad than duplication.
            } else if ((jQuery.event.special[type] || {}).delegateType) {
              event.stopPropagation();
            }

            // If this is a native event triggered above, everything is now in order
            // Fire an inner synthetic event with the original arguments
          } else if (saved) {

            // ...and capture the result
            dataPriv.set(this, type, jQuery.event.trigger(
              saved[0],
              saved.slice(1),
              this
            ));

            // Abort handling of the native event by all jQuery handlers while allowing
            // native handlers on the same element to run. On target, this is achieved
            // by stopping immediate propagation just on the jQuery event. However,
            // the native event is re-wrapped by a jQuery one on each level of the
            // propagation so the only way to stop it for jQuery is to stop it for
            // everyone via native `stopPropagation()`. This is not a problem for
            // focus/blur which don't bubble, but it does also stop click on checkboxes
            // and radios. We accept this limitation.
            event.stopPropagation();
            event.isImmediatePropagationStopped = returnTrue;
          }
        }
      });
    }

    jQuery.removeEvent = function (elem, type, handle) {

      // This "if" is needed for plain objects
      if (elem.removeEventListener) {
        elem.removeEventListener(type, handle);
      }
    };

    jQuery.Event = function (src, props) {

      // Allow instantiation without the 'new' keyword
      if (!(this instanceof jQuery.Event)) {
        return new jQuery.Event(src, props);
      }

      // Event object
      if (src && src.type) {
        this.originalEvent = src;
        this.type = src.type;

        // Events bubbling up the document may have been marked as prevented
        // by a handler lower down the tree; reflect the correct value.
        this.isDefaultPrevented = src.defaultPrevented ||
          src.defaultPrevented === undefined &&

          // Support: Android <=2.3 only
          src.returnValue === false ?
          returnTrue :
          returnFalse;

        // Create target properties
        // Support: Safari <=6 - 7 only
        // Target should not be a text node (trac-504, trac-13143)
        this.target = (src.target && src.target.nodeType === 3) ?
          src.target.parentNode :
          src.target;

        this.currentTarget = src.currentTarget;
        this.relatedTarget = src.relatedTarget;

        // Event type
      } else {
        this.type = src;
      }

      // Put explicitly provided properties onto the event object
      if (props) {
        jQuery.extend(this, props);
      }

      // Create a timestamp if incoming event doesn't have one
      this.timeStamp = src && src.timeStamp || Date.now();

      // Mark it as fixed
      this[jQuery.expando] = true;
    };

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
      constructor: jQuery.Event,
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse,
      isSimulated: false,

      preventDefault: function () {
        var e = this.originalEvent;

        this.isDefaultPrevented = returnTrue;

        if (e && !this.isSimulated) {
          e.preventDefault();
        }
      },
      stopPropagation: function () {
        var e = this.originalEvent;

        this.isPropagationStopped = returnTrue;

        if (e && !this.isSimulated) {
          e.stopPropagation();
        }
      },
      stopImmediatePropagation: function () {
        var e = this.originalEvent;

        this.isImmediatePropagationStopped = returnTrue;

        if (e && !this.isSimulated) {
          e.stopImmediatePropagation();
        }

        this.stopPropagation();
      }
    };

    // Includes all common event props including KeyEvent and MouseEvent specific props
    jQuery.each({
      altKey: true,
      bubbles: true,
      cancelable: true,
      changedTouches: true,
      ctrlKey: true,
      detail: true,
      eventPhase: true,
      metaKey: true,
      pageX: true,
      pageY: true,
      shiftKey: true,
      view: true,
      "char": true,
      code: true,
      charCode: true,
      key: true,
      keyCode: true,
      button: true,
      buttons: true,
      clientX: true,
      clientY: true,
      offsetX: true,
      offsetY: true,
      pointerId: true,
      pointerType: true,
      screenX: true,
      screenY: true,
      targetTouches: true,
      toElement: true,
      touches: true,
      which: true
    }, jQuery.event.addProp);

    jQuery.each({ focus: "focusin", blur: "focusout" }, function (type, delegateType) {

      function focusMappedHandler(nativeEvent) {
        if (document.documentMode) {

          // Support: IE 11+
          // Attach a single focusin/focusout handler on the document while someone wants
          // focus/blur. This is because the former are synchronous in IE while the latter
          // are async. In other browsers, all those handlers are invoked synchronously.

          // `handle` from private data would already wrap the event, but we need
          // to change the `type` here.
          var handle = dataPriv.get(this, "handle"),
            event = jQuery.event.fix(nativeEvent);
          event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
          event.isSimulated = true;

          // First, handle focusin/focusout
          handle(nativeEvent);

          // ...then, handle focus/blur
          //
          // focus/blur don't bubble while focusin/focusout do; simulate the former by only
          // invoking the handler at the lower level.
          if (event.target === event.currentTarget) {

            // The setup part calls `leverageNative`, which, in turn, calls
            // `jQuery.event.add`, so event handle will already have been set
            // by this point.
            handle(event);
          }
        } else {

          // For non-IE browsers, attach a single capturing handler on the document
          // while someone wants focusin/focusout.
          jQuery.event.simulate(delegateType, nativeEvent.target,
            jQuery.event.fix(nativeEvent));
        }
      }

      jQuery.event.special[type] = {

        // Utilize native event if possible so blur/focus sequence is correct
        setup: function () {

          var attaches;

          // Claim the first handler
          // dataPriv.set( this, "focus", ... )
          // dataPriv.set( this, "blur", ... )
          leverageNative(this, type, true);

          if (document.documentMode) {

            // Support: IE 9 - 11+
            // We use the same native handler for focusin & focus (and focusout & blur)
            // so we need to coordinate setup & teardown parts between those events.
            // Use `delegateType` as the key as `type` is already used by `leverageNative`.
            attaches = dataPriv.get(this, delegateType);
            if (!attaches) {
              this.addEventListener(delegateType, focusMappedHandler);
            }
            dataPriv.set(this, delegateType, (attaches || 0) + 1);
          } else {

            // Return false to allow normal processing in the caller
            return false;
          }
        },
        trigger: function () {

          // Force setup before trigger
          leverageNative(this, type);

          // Return non-false to allow normal event-path propagation
          return true;
        },

        teardown: function () {
          var attaches;

          if (document.documentMode) {
            attaches = dataPriv.get(this, delegateType) - 1;
            if (!attaches) {
              this.removeEventListener(delegateType, focusMappedHandler);
              dataPriv.remove(this, delegateType);
            } else {
              dataPriv.set(this, delegateType, attaches);
            }
          } else {

            // Return false to indicate standard teardown should be applied
            return false;
          }
        },

        // Suppress native focus or blur if we're currently inside
        // a leveraged native-event stack
        _default: function (event) {
          return dataPriv.get(event.target, type);
        },

        delegateType: delegateType
      };

      // Support: Firefox <=44
      // Firefox doesn't have focus(in | out) events
      // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
      //
      // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
      // focus(in | out) events fire after focus & blur events,
      // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
      // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
      //
      // Support: IE 9 - 11+
      // To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
      // attach a single handler for both events in IE.
      jQuery.event.special[delegateType] = {
        setup: function () {

          // Handle: regular nodes (via `this.ownerDocument`), window
          // (via `this.document`) & document (via `this`).
          var doc = this.ownerDocument || this.document || this,
            dataHolder = document.documentMode ? this : doc,
            attaches = dataPriv.get(dataHolder, delegateType);

          // Support: IE 9 - 11+
          // We use the same native handler for focusin & focus (and focusout & blur)
          // so we need to coordinate setup & teardown parts between those events.
          // Use `delegateType` as the key as `type` is already used by `leverageNative`.
          if (!attaches) {
            if (document.documentMode) {
              this.addEventListener(delegateType, focusMappedHandler);
            } else {
              doc.addEventListener(type, focusMappedHandler, true);
            }
          }
          dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
        },
        teardown: function () {
          var doc = this.ownerDocument || this.document || this,
            dataHolder = document.documentMode ? this : doc,
            attaches = dataPriv.get(dataHolder, delegateType) - 1;

          if (!attaches) {
            if (document.documentMode) {
              this.removeEventListener(delegateType, focusMappedHandler);
            } else {
              doc.removeEventListener(type, focusMappedHandler, true);
            }
            dataPriv.remove(dataHolder, delegateType);
          } else {
            dataPriv.set(dataHolder, delegateType, attaches);
          }
        }
      };
    });

    // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    }, function (orig, fix) {
      jQuery.event.special[orig] = {
        delegateType: fix,
        bindType: fix,

        handle: function (event) {
          var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;

          // For mouseenter/leave call the handler if related is outside the target.
          // NB: No relatedTarget if the mouse left/entered the browser window
          if (!related || (related !== target && !jQuery.contains(target, related))) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }
          return ret;
        }
      };
    });

    jQuery.fn.extend({

      on: function (types, selector, data, fn) {
        return on(this, types, selector, data, fn);
      },
      one: function (types, selector, data, fn) {
        return on(this, types, selector, data, fn, 1);
      },
      off: function (types, selector, fn) {
        var handleObj, type;
        if (types && types.preventDefault && types.handleObj) {

          // ( event )  dispatched jQuery.Event
          handleObj = types.handleObj;
          jQuery(types.delegateTarget).off(
            handleObj.namespace ?
              handleObj.origType + "." + handleObj.namespace :
              handleObj.origType,
            handleObj.selector,
            handleObj.handler
          );
          return this;
        }
        if (typeof types === "object") {

          // ( types-object [, selector] )
          for (type in types) {
            this.off(type, selector, types[type]);
          }
          return this;
        }
        if (selector === false || typeof selector === "function") {

          // ( types [, fn] )
          fn = selector;
          selector = undefined;
        }
        if (fn === false) {
          fn = returnFalse;
        }
        return this.each(function () {
          jQuery.event.remove(this, types, fn, selector);
        });
      }
    });


    var

      // Support: IE <=10 - 11, Edge 12 - 13 only
      // In IE/Edge using regex groups here causes severe slowdowns.
      // See https://connect.microsoft.com/IE/feedback/details/1736512/
      rnoInnerhtml = /<script|<style|<link/i,

      // checked="checked" or checked
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

      rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

    // Prefer a tbody over its parent table for containing new rows
    function manipulationTarget(elem, content) {
      if (nodeName(elem, "table") &&
        nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {

        return jQuery(elem).children("tbody")[0] || elem;
      }

      return elem;
    }

    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
      elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
      return elem;
    }
    function restoreScript(elem) {
      if ((elem.type || "").slice(0, 5) === "true/") {
        elem.type = elem.type.slice(5);
      } else {
        elem.removeAttribute("type");
      }

      return elem;
    }

    function cloneCopyEvent(src, dest) {
      var i, l, type, pdataOld, udataOld, udataCur, events;

      if (dest.nodeType !== 1) {
        return;
      }

      // 1. Copy private data: events, handlers, etc.
      if (dataPriv.hasData(src)) {
        pdataOld = dataPriv.get(src);
        events = pdataOld.events;

        if (events) {
          dataPriv.remove(dest, "handle events");

          for (type in events) {
            for (i = 0, l = events[type].length; i < l; i++) {
              jQuery.event.add(dest, type, events[type][i]);
            }
          }
        }
      }

      // 2. Copy user data
      if (dataUser.hasData(src)) {
        udataOld = dataUser.access(src);
        udataCur = jQuery.extend({}, udataOld);

        dataUser.set(dest, udataCur);
      }
    }

    // Fix IE bugs, see support tests
    function fixInput(src, dest) {
      var nodeName = dest.nodeName.toLowerCase();

      // Fails to persist the checked state of a cloned checkbox or radio button.
      if (nodeName === "input" && rcheckableType.test(src.type)) {
        dest.checked = src.checked;

        // Fails to return the selected option to the default selected state when cloning options
      } else if (nodeName === "input" || nodeName === "textarea") {
        dest.defaultValue = src.defaultValue;
      }
    }

    function domManip(collection, args, callback, ignored) {

      // Flatten any nested arrays
      args = flat(args);

      var fragment, first, scripts, hasScripts, node, doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        valueIsFunction = isFunction(value);

      // We can't cloneNode fragments that contain checked, in WebKit
      if (valueIsFunction ||
        (l > 1 && typeof value === "string" &&
          !support.checkClone && rchecked.test(value))) {
        return collection.each(function (index) {
          var self = collection.eq(index);
          if (valueIsFunction) {
            args[0] = value.call(this, index, self.html());
          }
          domManip(self, args, callback, ignored);
        });
      }

      if (l) {
        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
        first = fragment.firstChild;

        if (fragment.childNodes.length === 1) {
          fragment = first;
        }

        // Require either new content or an interest in ignored elements to invoke the callback
        if (first || ignored) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;

          // Use the original fragment for the last item
          // instead of the first because it can end up
          // being emptied incorrectly in certain situations (trac-8070).
          for (; i < l; i++) {
            node = fragment;

            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);

              // Keep references to cloned scripts for later restoration
              if (hasScripts) {

                // Support: Android <=4.0 only, PhantomJS 1 only
                // push.apply(_, arraylike) throws on ancient WebKit
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }

            callback.call(collection[i], node, i);
          }

          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;

            // Re-enable scripts
            jQuery.map(scripts, restoreScript);

            // Evaluate executable scripts on first document insertion
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || "") &&
                !dataPriv.access(node, "globalEval") &&
                jQuery.contains(doc, node)) {

                if (node.src && (node.type || "").toLowerCase() !== "module") {

                  // Optional AJAX dependency, but won't run scripts if not present
                  if (jQuery._evalUrl && !node.noModule) {
                    jQuery._evalUrl(node.src, {
                      nonce: node.nonce || node.getAttribute("nonce")
                    }, doc);
                  }
                } else {

                  // Unwrap a CDATA section containing script contents. This shouldn't be
                  // needed as in XML documents they're already not visible when
                  // inspecting element contents and in HTML documents they have no
                  // meaning but we're preserving that logic for backwards compatibility.
                  // This will be removed completely in 4.0. See gh-4904.
                  DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                }
              }
            }
          }
        }
      }

      return collection;
    }

    function remove(elem, selector, keepData) {
      var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;

      for (; (node = nodes[i]) != null; i++) {
        if (!keepData && node.nodeType === 1) {
          jQuery.cleanData(getAll(node));
        }

        if (node.parentNode) {
          if (keepData && isAttached(node)) {
            setGlobalEval(getAll(node, "script"));
          }
          node.parentNode.removeChild(node);
        }
      }

      return elem;
    }

    jQuery.extend({
      htmlPrefilter: function (html) {
        return html;
      },

      clone: function (elem, dataAndEvents, deepDataAndEvents) {
        var i, l, srcElements, destElements,
          clone = elem.cloneNode(true),
          inPage = isAttached(elem);

        // Fix IE cloning issues
        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
          !jQuery.isXMLDoc(elem)) {

          // We eschew jQuery#find here for performance reasons:
          // https://jsperf.com/getall-vs-sizzle/2
          destElements = getAll(clone);
          srcElements = getAll(elem);

          for (i = 0, l = srcElements.length; i < l; i++) {
            fixInput(srcElements[i], destElements[i]);
          }
        }

        // Copy the events from the original to the clone
        if (dataAndEvents) {
          if (deepDataAndEvents) {
            srcElements = srcElements || getAll(elem);
            destElements = destElements || getAll(clone);

            for (i = 0, l = srcElements.length; i < l; i++) {
              cloneCopyEvent(srcElements[i], destElements[i]);
            }
          } else {
            cloneCopyEvent(elem, clone);
          }
        }

        // Preserve script evaluation history
        destElements = getAll(clone, "script");
        if (destElements.length > 0) {
          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
        }

        // Return the cloned set
        return clone;
      },

      cleanData: function (elems) {
        var data, elem, type,
          special = jQuery.event.special,
          i = 0;

        for (; (elem = elems[i]) !== undefined; i++) {
          if (acceptData(elem)) {
            if ((data = elem[dataPriv.expando])) {
              if (data.events) {
                for (type in data.events) {
                  if (special[type]) {
                    jQuery.event.remove(elem, type);

                    // This is a shortcut to avoid jQuery.event.remove's overhead
                  } else {
                    jQuery.removeEvent(elem, type, data.handle);
                  }
                }
              }

              // Support: Chrome <=35 - 45+
              // Assign undefined instead of using delete, see Data#remove
              elem[dataPriv.expando] = undefined;
            }
            if (elem[dataUser.expando]) {

              // Support: Chrome <=35 - 45+
              // Assign undefined instead of using delete, see Data#remove
              elem[dataUser.expando] = undefined;
            }
          }
        }
      }
    });

    jQuery.fn.extend({
      detach: function (selector) {
        return remove(this, selector, true);
      },

      remove: function (selector) {
        return remove(this, selector);
      },

      text: function (value) {
        return access(this, function (value) {
          return value === undefined ?
            jQuery.text(this) :
            this.empty().each(function () {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value;
              }
            });
        }, null, value, arguments.length);
      },

      append: function () {
        return domManip(this, arguments, function (elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.appendChild(elem);
          }
        });
      },

      prepend: function () {
        return domManip(this, arguments, function (elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.insertBefore(elem, target.firstChild);
          }
        });
      },

      before: function () {
        return domManip(this, arguments, function (elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this);
          }
        });
      },

      after: function () {
        return domManip(this, arguments, function (elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this.nextSibling);
          }
        });
      },

      empty: function () {
        var elem,
          i = 0;

        for (; (elem = this[i]) != null; i++) {
          if (elem.nodeType === 1) {

            // Prevent memory leaks
            jQuery.cleanData(getAll(elem, false));

            // Remove any remaining nodes
            elem.textContent = "";
          }
        }

        return this;
      },

      clone: function (dataAndEvents, deepDataAndEvents) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

        return this.map(function () {
          return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
        });
      },

      html: function (value) {
        return access(this, function (value) {
          var elem = this[0] || {},
            i = 0,
            l = this.length;

          if (value === undefined && elem.nodeType === 1) {
            return elem.innerHTML;
          }

          // See if we can take a shortcut and just use innerHTML
          if (typeof value === "string" && !rnoInnerhtml.test(value) &&
            !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

            value = jQuery.htmlPrefilter(value);

            try {
              for (; i < l; i++) {
                elem = this[i] || {};

                // Remove element nodes and prevent memory leaks
                if (elem.nodeType === 1) {
                  jQuery.cleanData(getAll(elem, false));
                  elem.innerHTML = value;
                }
              }

              elem = 0;

              // If using innerHTML throws an exception, use the fallback method
            } catch (e) { }
          }

          if (elem) {
            this.empty().append(value);
          }
        }, null, value, arguments.length);
      },

      replaceWith: function () {
        var ignored = [];

        // Make the changes, replacing each non-ignored context element with the new content
        return domManip(this, arguments, function (elem) {
          var parent = this.parentNode;

          if (jQuery.inArray(this, ignored) < 0) {
            jQuery.cleanData(getAll(this));
            if (parent) {
              parent.replaceChild(elem, this);
            }
          }

          // Force callback invocation
        }, ignored);
      }
    });

    jQuery.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    }, function (name, original) {
      jQuery.fn[name] = function (selector) {
        var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;

        for (; i <= last; i++) {
          elems = i === last ? this : this.clone(true);
          jQuery(insert[i])[original](elems);

          // Support: Android <=4.0 only, PhantomJS 1 only
          // .get() because push.apply(_, arraylike) throws on ancient WebKit
          push.apply(ret, elems.get());
        }

        return this.pushStack(ret);
      };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

    var rcustomProp = /^--/;


    var getStyles = function (elem) {

      // Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
      // IE throws on elements created in popups
      // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
      var view = elem.ownerDocument.defaultView;

      if (!view || !view.opener) {
        view = window;
      }

      return view.getComputedStyle(elem);
    };

    var swap = function (elem, options, callback) {
      var ret, name,
        old = {};

      // Remember the old values, and insert the new ones
      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }

      ret = callback.call(elem);

      // Revert the old values
      for (name in options) {
        elem.style[name] = old[name];
      }

      return ret;
    };


    var rboxStyle = new RegExp(cssExpand.join("|"), "i");



    (function () {

      // Executing both pixelPosition & boxSizingReliable tests require only one layout
      // so they're executed at the same time to save the second computation.
      function computeStyleTests() {

        // This is a singleton, we need to execute it only once
        if (!div) {
          return;
        }

        container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
          "margin-top:1px;padding:0;border:0";
        div.style.cssText =
          "position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
          "margin:auto;border:1px;padding:1px;" +
          "width:60%;top:1%";
        documentElement.appendChild(container).appendChild(div);

        var divStyle = window.getComputedStyle(div);
        pixelPositionVal = divStyle.top !== "1%";

        // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
        reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;

        // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
        // Some styles come back with percentage values, even though they shouldn't
        div.style.right = "60%";
        pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;

        // Support: IE 9 - 11 only
        // Detect misreporting of content dimensions for box-sizing:border-box elements
        boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;

        // Support: IE 9 only
        // Detect overflow:scroll screwiness (gh-3699)
        // Support: Chrome <=64
        // Don't get tricked when zoom affects offsetWidth (gh-4029)
        div.style.position = "absolute";
        scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;

        documentElement.removeChild(container);

        // Nullify the div so it wouldn't be stored in the memory and
        // it will also be a sign that checks already performed
        div = null;
      }

      function roundPixelMeasures(measure) {
        return Math.round(parseFloat(measure));
      }

      var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
        reliableTrDimensionsVal, reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div");

      // Finish early in limited (non-browser) environments
      if (!div.style) {
        return;
      }

      // Support: IE <=9 - 11 only
      // Style of cloned element affects source element cloned (trac-8908)
      div.style.backgroundClip = "content-box";
      div.cloneNode(true).style.backgroundClip = "";
      support.clearCloneStyle = div.style.backgroundClip === "content-box";

      jQuery.extend(support, {
        boxSizingReliable: function () {
          computeStyleTests();
          return boxSizingReliableVal;
        },
        pixelBoxStyles: function () {
          computeStyleTests();
          return pixelBoxStylesVal;
        },
        pixelPosition: function () {
          computeStyleTests();
          return pixelPositionVal;
        },
        reliableMarginLeft: function () {
          computeStyleTests();
          return reliableMarginLeftVal;
        },
        scrollboxSize: function () {
          computeStyleTests();
          return scrollboxSizeVal;
        },

        // Support: IE 9 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Behavior in IE 9 is more subtle than in newer versions & it passes
        // some versions of this test; make sure not to make it pass there!
        //
        // Support: Firefox 70+
        // Only Firefox includes border widths
        // in computed dimensions. (gh-4529)
        reliableTrDimensions: function () {
          var table, tr, trChild, trStyle;
          if (reliableTrDimensionsVal == null) {
            table = document.createElement("table");
            tr = document.createElement("tr");
            trChild = document.createElement("div");

            table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
            tr.style.cssText = "box-sizing:content-box;border:1px solid";

            // Support: Chrome 86+
            // Height set through cssText does not get applied.
            // Computed height then comes back as 0.
            tr.style.height = "1px";
            trChild.style.height = "9px";

            // Support: Android 8 Chrome 86+
            // In our bodyBackground.html iframe,
            // display for all div elements is set to "inline",
            // which causes a problem only in Android 8 Chrome 86.
            // Ensuring the div is `display: block`
            // gets around this issue.
            trChild.style.display = "block";

            documentElement
              .appendChild(table)
              .appendChild(tr)
              .appendChild(trChild);

            trStyle = window.getComputedStyle(tr);
            reliableTrDimensionsVal = (parseInt(trStyle.height, 10) +
              parseInt(trStyle.borderTopWidth, 10) +
              parseInt(trStyle.borderBottomWidth, 10)) === tr.offsetHeight;

            documentElement.removeChild(table);
          }
          return reliableTrDimensionsVal;
        }
      });
    })();


    function curCSS(elem, name, computed) {
      var width, minWidth, maxWidth, ret,
        isCustomProp = rcustomProp.test(name),

        // Support: Firefox 51+
        // Retrieving style before computed somehow
        // fixes an issue with getting wrong values
        // on detached elements
        style = elem.style;

      computed = computed || getStyles(elem);

      // getPropertyValue is needed for:
      //   .css('filter') (IE 9 only, trac-12537)
      //   .css('--customProperty) (gh-3144)
      if (computed) {

        // Support: IE <=9 - 11+
        // IE only supports `"float"` in `getPropertyValue`; in computed styles
        // it's only available as `"cssFloat"`. We no longer modify properties
        // sent to `.css()` apart from camelCasing, so we need to check both.
        // Normally, this would create difference in behavior: if
        // `getPropertyValue` returns an empty string, the value returned
        // by `.css()` would be `undefined`. This is usually the case for
        // disconnected elements. However, in IE even disconnected elements
        // with no styles return `"none"` for `getPropertyValue( "float" )`
        ret = computed.getPropertyValue(name) || computed[name];

        if (isCustomProp && ret) {

          // Support: Firefox 105+, Chrome <=105+
          // Spec requires trimming whitespace for custom properties (gh-4926).
          // Firefox only trims leading whitespace. Chrome just collapses
          // both leading & trailing whitespace to a single space.
          //
          // Fall back to `undefined` if empty string returned.
          // This collapses a missing definition with property defined
          // and set to an empty string but there's no standard API
          // allowing us to differentiate them without a performance penalty
          // and returning `undefined` aligns with older jQuery.
          //
          // rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
          // as whitespace while CSS does not, but this is not a problem
          // because CSS preprocessing replaces them with U+000A LINE FEED
          // (which *is* CSS whitespace)
          // https://www.w3.org/TR/css-syntax-3/#input-preprocessing
          ret = ret.replace(rtrimCSS, "$1") || undefined;
        }

        if (ret === "" && !isAttached(elem)) {
          ret = jQuery.style(elem, name);
        }

        // A tribute to the "awesome hack by Dean Edwards"
        // Android Browser returns percentage for some values,
        // but width seems to be reliably pixels.
        // This is against the CSSOM draft spec:
        // https://drafts.csswg.org/cssom/#resolved-values
        if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {

          // Remember the original values
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth;

          // Put in the new values to get a computed value out
          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed.width;

          // Revert the changed values
          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }

      return ret !== undefined ?

        // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        ret + "" :
        ret;
    }


    function addGetHookIf(conditionFn, hookFn) {

      // Define the hook, we'll check on the first run if it's really needed.
      return {
        get: function () {
          if (conditionFn()) {

            // Hook not needed (or it's not possible to use it due
            // to missing dependency), remove it.
            delete this.get;
            return;
          }

          // Hook needed; redefine it so that the support test is not executed again.
          return (this.get = hookFn).apply(this, arguments);
        }
      };
    }


    var cssPrefixes = ["Webkit", "Moz", "ms"],
      emptyStyle = document.createElement("div").style,
      vendorProps = {};

    // Return a vendor-prefixed property or undefined
    function vendorPropName(name) {

      // Check for vendor prefixed names
      var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;

      while (i--) {
        name = cssPrefixes[i] + capName;
        if (name in emptyStyle) {
          return name;
        }
      }
    }

    // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
    function finalPropName(name) {
      var final = jQuery.cssProps[name] || vendorProps[name];

      if (final) {
        return final;
      }
      if (name in emptyStyle) {
        return name;
      }
      return vendorProps[name] = vendorPropName(name) || name;
    }


    var

      // Swappable if display is none or starts with table
      // except "table", "table-cell", or "table-caption"
      // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
      rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      cssShow = { position: "absolute", visibility: "hidden", display: "block" },
      cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      };

    function setPositiveNumber(_elem, value, subtract) {

      // Any relative (+/-) values have already been
      // normalized at this point
      var matches = rcssNum.exec(value);
      return matches ?

        // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") :
        value;
    }

    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
      var i = dimension === "width" ? 1 : 0,
        extra = 0,
        delta = 0,
        marginDelta = 0;

      // Adjustment may not be necessary
      if (box === (isBorderBox ? "border" : "content")) {
        return 0;
      }

      for (; i < 4; i += 2) {

        // Both box models exclude margin
        // Count margin delta separately to only add it after scroll gutter adjustment.
        // This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
        if (box === "margin") {
          marginDelta += jQuery.css(elem, box + cssExpand[i], true, styles);
        }

        // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
        if (!isBorderBox) {

          // Add padding
          delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

          // For "border" or "margin", add border
          if (box !== "padding") {
            delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);

            // But still keep track of it otherwise
          } else {
            extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }

          // If we get here with a border-box (content + padding + border), we're seeking "content" or
          // "padding" or "margin"
        } else {

          // For "content", subtract padding
          if (box === "content") {
            delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
          }

          // For "content" or "padding", subtract border
          if (box !== "margin") {
            delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        }
      }

      // Account for positive content-box scroll gutter when requested by providing computedVal
      if (!isBorderBox && computedVal >= 0) {

        // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
        // Assuming integer scroll gutter, subtract the rest and round down
        delta += Math.max(0, Math.ceil(
          elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
          computedVal -
          delta -
          extra -
          0.5

          // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
          // Use an explicit zero to avoid NaN (gh-3964)
        )) || 0;
      }

      return delta + marginDelta;
    }

    function getWidthOrHeight(elem, dimension, extra) {

      // Start with computed style
      var styles = getStyles(elem),

        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
        // Fake content-box until we know it's needed to know the true value.
        boxSizingNeeded = !support.boxSizingReliable() || extra,
        isBorderBox = boxSizingNeeded &&
          jQuery.css(elem, "boxSizing", false, styles) === "border-box",
        valueIsBorderBox = isBorderBox,

        val = curCSS(elem, dimension, styles),
        offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);

      // Support: Firefox <=54
      // Return a confounding non-pixel value or feign ignorance, as appropriate.
      if (rnumnonpx.test(val)) {
        if (!extra) {
          return val;
        }
        val = "auto";
      }


      // Support: IE 9 - 11 only
      // Use offsetWidth/offsetHeight for when box sizing is unreliable.
      // In those cases, the computed value can be trusted to be border-box.
      if ((!support.boxSizingReliable() && isBorderBox ||

        // Support: IE 10 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Interestingly, in some cases IE 9 doesn't suffer from this issue.
        !support.reliableTrDimensions() && nodeName(elem, "tr") ||

        // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        val === "auto" ||

        // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") &&

        // Make sure the element is visible & connected
        elem.getClientRects().length) {

        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

        // Where available, offsetWidth/offsetHeight approximate border box dimensions.
        // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
        // retrieved value as a content box dimension.
        valueIsBorderBox = offsetProp in elem;
        if (valueIsBorderBox) {
          val = elem[offsetProp];
        }
      }

      // Normalize "" and auto
      val = parseFloat(val) || 0;

      // Adjust for the element's box model
      return (val +
        boxModelAdjustment(
          elem,
          dimension,
          extra || (isBorderBox ? "border" : "content"),
          valueIsBorderBox,
          styles,

          // Provide the current computed size to request scroll gutter calculation (gh-3589)
          val
        )
      ) + "px";
    }

    jQuery.extend({

      // Add in style property hooks for overriding the default
      // behavior of getting and setting a style property
      cssHooks: {
        opacity: {
          get: function (elem, computed) {
            if (computed) {

              // We should always get a number back from opacity
              var ret = curCSS(elem, "opacity");
              return ret === "" ? "1" : ret;
            }
          }
        }
      },

      // Don't automatically add "px" to these possibly-unitless properties
      cssNumber: {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageSlice: true,
        columnCount: true,
        flexGrow: true,
        flexShrink: true,
        fontWeight: true,
        gridArea: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnStart: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowStart: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        scale: true,
        widows: true,
        zIndex: true,
        zoom: true,

        // SVG-related
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeMiterlimit: true,
        strokeOpacity: true
      },

      // Add in properties whose names you wish to fix before
      // setting or getting the value
      cssProps: {},

      // Get and set the style property on a DOM Node
      style: function (elem, name, value, extra) {

        // Don't set styles on text and comment nodes
        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
          return;
        }

        // Make sure that we're working with the right name
        var ret, type, hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name),
          style = elem.style;

        // Make sure that we're working with the right name. We don't
        // want to query the value if it is a CSS custom property
        // since they are user-defined.
        if (!isCustomProp) {
          name = finalPropName(origName);
        }

        // Gets hook for the prefixed version, then unprefixed version
        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

        // Check if we're setting a value
        if (value !== undefined) {
          type = typeof value;

          // Convert "+=" or "-=" to relative numbers (trac-7345)
          if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
            value = adjustCSS(elem, name, ret);

            // Fixes bug trac-9237
            type = "number";
          }

          // Make sure that null and NaN values aren't set (trac-7116)
          if (value == null || value !== value) {
            return;
          }

          // If a number was passed in, add the unit (except for certain CSS properties)
          // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
          // "px" to a few hardcoded values.
          if (type === "number" && !isCustomProp) {
            value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
          }

          // background-* props affect original clone's values
          if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
            style[name] = "inherit";
          }

          // If a hook was provided, use that value, otherwise just set the specified value
          if (!hooks || !("set" in hooks) ||
            (value = hooks.set(elem, value, extra)) !== undefined) {

            if (isCustomProp) {
              style.setProperty(name, value);
            } else {
              style[name] = value;
            }
          }

        } else {

          // If a hook was provided get the non-computed value from there
          if (hooks && "get" in hooks &&
            (ret = hooks.get(elem, false, extra)) !== undefined) {

            return ret;
          }

          // Otherwise just get the value from the style object
          return style[name];
        }
      },

      css: function (elem, name, extra, styles) {
        var val, num, hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name);

        // Make sure that we're working with the right name. We don't
        // want to modify the value if it is a CSS custom property
        // since they are user-defined.
        if (!isCustomProp) {
          name = finalPropName(origName);
        }

        // Try prefixed name followed by the unprefixed name
        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

        // If a hook was provided get the computed value from there
        if (hooks && "get" in hooks) {
          val = hooks.get(elem, true, extra);
        }

        // Otherwise, if a way to get the computed value exists, use that
        if (val === undefined) {
          val = curCSS(elem, name, styles);
        }

        // Convert "normal" to computed value
        if (val === "normal" && name in cssNormalTransform) {
          val = cssNormalTransform[name];
        }

        // Make numeric if forced or a qualifier was provided and val looks numeric
        if (extra === "" || extra) {
          num = parseFloat(val);
          return extra === true || isFinite(num) ? num || 0 : val;
        }

        return val;
      }
    });

    jQuery.each(["height", "width"], function (_i, dimension) {
      jQuery.cssHooks[dimension] = {
        get: function (elem, computed, extra) {
          if (computed) {

            // Certain elements can have dimension info if we invisibly show them
            // but it must have a current display style that would benefit
            return rdisplayswap.test(jQuery.css(elem, "display")) &&

              // Support: Safari 8+
              // Table columns in Safari have non-zero offsetWidth & zero
              // getBoundingClientRect().width unless display is changed.
              // Support: IE <=11 only
              // Running getBoundingClientRect on a disconnected node
              // in IE throws an error.
              (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ?
              swap(elem, cssShow, function () {
                return getWidthOrHeight(elem, dimension, extra);
              }) :
              getWidthOrHeight(elem, dimension, extra);
          }
        },

        set: function (elem, value, extra) {
          var matches,
            styles = getStyles(elem),

            // Only read styles.position if the test has a chance to fail
            // to avoid forcing a reflow.
            scrollboxSizeBuggy = !support.scrollboxSize() &&
              styles.position === "absolute",

            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
            boxSizingNeeded = scrollboxSizeBuggy || extra,
            isBorderBox = boxSizingNeeded &&
              jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            subtract = extra ?
              boxModelAdjustment(
                elem,
                dimension,
                extra,
                isBorderBox,
                styles
              ) :
              0;

          // Account for unreliable border-box dimensions by comparing offset* to computed and
          // faking a content-box to get border and padding (gh-3699)
          if (isBorderBox && scrollboxSizeBuggy) {
            subtract -= Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
              parseFloat(styles[dimension]) -
              boxModelAdjustment(elem, dimension, "border", false, styles) -
              0.5
            );
          }

          // Convert to pixels if value adjustment is needed
          if (subtract && (matches = rcssNum.exec(value)) &&
            (matches[3] || "px") !== "px") {

            elem.style[dimension] = value;
            value = jQuery.css(elem, dimension);
          }

          return setPositiveNumber(elem, value, subtract);
        }
      };
    });

    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft,
      function (elem, computed) {
        if (computed) {
          return (parseFloat(curCSS(elem, "marginLeft")) ||
            elem.getBoundingClientRect().left -
            swap(elem, { marginLeft: 0 }, function () {
              return elem.getBoundingClientRect().left;
            })
          ) + "px";
        }
      }
    );

    // These hooks are used by animate to expand properties
    jQuery.each({
      margin: "",
      padding: "",
      border: "Width"
    }, function (prefix, suffix) {
      jQuery.cssHooks[prefix + suffix] = {
        expand: function (value) {
          var i = 0,
            expanded = {},

            // Assumes a single number if not a string
            parts = typeof value === "string" ? value.split(" ") : [value];

          for (; i < 4; i++) {
            expanded[prefix + cssExpand[i] + suffix] =
              parts[i] || parts[i - 2] || parts[0];
          }

          return expanded;
        }
      };

      if (prefix !== "margin") {
        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    });

    jQuery.fn.extend({
      css: function (name, value) {
        return access(this, function (elem, name, value) {
          var styles, len,
            map = {},
            i = 0;

          if (Array.isArray(name)) {
            styles = getStyles(elem);
            len = name.length;

            for (; i < len; i++) {
              map[name[i]] = jQuery.css(elem, name[i], false, styles);
            }

            return map;
          }

          return value !== undefined ?
            jQuery.style(elem, name, value) :
            jQuery.css(elem, name);
        }, name, value, arguments.length > 1);
      }
    });


    function Tween(elem, options, prop, end, easing) {
      return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;

    Tween.prototype = {
      constructor: Tween,
      init: function (elem, options, prop, end, easing, unit) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || jQuery.easing._default;
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
      },
      cur: function () {
        var hooks = Tween.propHooks[this.prop];

        return hooks && hooks.get ?
          hooks.get(this) :
          Tween.propHooks._default.get(this);
      },
      run: function (percent) {
        var eased,
          hooks = Tween.propHooks[this.prop];

        if (this.options.duration) {
          this.pos = eased = jQuery.easing[this.easing](
            percent, this.options.duration * percent, 0, 1, this.options.duration
          );
        } else {
          this.pos = eased = percent;
        }
        this.now = (this.end - this.start) * eased + this.start;

        if (this.options.step) {
          this.options.step.call(this.elem, this.now, this);
        }

        if (hooks && hooks.set) {
          hooks.set(this);
        } else {
          Tween.propHooks._default.set(this);
        }
        return this;
      }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
      _default: {
        get: function (tween) {
          var result;

          // Use a property on the element directly when it is not a DOM element,
          // or when there is no matching style property that exists.
          if (tween.elem.nodeType !== 1 ||
            tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
            return tween.elem[tween.prop];
          }

          // Passing an empty string as a 3rd parameter to .css will automatically
          // attempt a parseFloat and fallback to a string if the parse fails.
          // Simple values such as "10px" are parsed to Float;
          // complex values such as "rotate(1rad)" are returned as-is.
          result = jQuery.css(tween.elem, tween.prop, "");

          // Empty strings, null, undefined and "auto" are converted to 0.
          return !result || result === "auto" ? 0 : result;
        },
        set: function (tween) {

          // Use step hook for back compat.
          // Use cssHook if its there.
          // Use .style if available and use plain properties where available.
          if (jQuery.fx.step[tween.prop]) {
            jQuery.fx.step[tween.prop](tween);
          } else if (tween.elem.nodeType === 1 && (
            jQuery.cssHooks[tween.prop] ||
            tween.elem.style[finalPropName(tween.prop)] != null)) {
            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
          } else {
            tween.elem[tween.prop] = tween.now;
          }
        }
      }
    };

    // Support: IE <=9 only
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
      set: function (tween) {
        if (tween.elem.nodeType && tween.elem.parentNode) {
          tween.elem[tween.prop] = tween.now;
        }
      }
    };

    jQuery.easing = {
      linear: function (p) {
        return p;
      },
      swing: function (p) {
        return 0.5 - Math.cos(p * Math.PI) / 2;
      },
      _default: "swing"
    };

    jQuery.fx = Tween.prototype.init;

    // Back compat <1.8 extension point
    jQuery.fx.step = {};




    var
      fxNow, inProgress,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;

    function schedule() {
      if (inProgress) {
        if (document.hidden === false && window.requestAnimationFrame) {
          window.requestAnimationFrame(schedule);
        } else {
          window.setTimeout(schedule, jQuery.fx.interval);
        }

        jQuery.fx.tick();
      }
    }

    // Animations created synchronously will run synchronously
    function createFxNow() {
      window.setTimeout(function () {
        fxNow = undefined;
      });
      return (fxNow = Date.now());
    }

    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
      var which,
        i = 0,
        attrs = { height: type };

      // If we include width, step value is 1 to do all cssExpand values,
      // otherwise step value is 2 to skip over Left and Right
      includeWidth = includeWidth ? 1 : 0;
      for (; i < 4; i += 2 - includeWidth) {
        which = cssExpand[i];
        attrs["margin" + which] = attrs["padding" + which] = type;
      }

      if (includeWidth) {
        attrs.opacity = attrs.width = type;
      }

      return attrs;
    }

    function createTween(value, prop, animation) {
      var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;
      for (; index < length; index++) {
        if ((tween = collection[index].call(animation, prop, value))) {

          // We're done with this property
          return tween;
        }
      }
    }

    function defaultPrefilter(elem, props, opts) {
      var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
        isBox = "width" in props || "height" in props,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHiddenWithinTree(elem),
        dataShow = dataPriv.get(elem, "fxshow");

      // Queue-skipping animations hijack the fx hooks
      if (!opts.queue) {
        hooks = jQuery._queueHooks(elem, "fx");
        if (hooks.unqueued == null) {
          hooks.unqueued = 0;
          oldfire = hooks.empty.fire;
          hooks.empty.fire = function () {
            if (!hooks.unqueued) {
              oldfire();
            }
          };
        }
        hooks.unqueued++;

        anim.always(function () {

          // Ensure the complete handler is called before this completes
          anim.always(function () {
            hooks.unqueued--;
            if (!jQuery.queue(elem, "fx").length) {
              hooks.empty.fire();
            }
          });
        });
      }

      // Detect show/hide animations
      for (prop in props) {
        value = props[prop];
        if (rfxtypes.test(value)) {
          delete props[prop];
          toggle = toggle || value === "toggle";
          if (value === (hidden ? "hide" : "show")) {

            // Pretend to be hidden if this is a "show" and
            // there is still data from a stopped show/hide
            if (value === "show" && dataShow && dataShow[prop] !== undefined) {
              hidden = true;

              // Ignore all other no-op show/hide data
            } else {
              continue;
            }
          }
          orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
        }
      }

      // Bail out if this is a no-op like .hide().hide()
      propTween = !jQuery.isEmptyObject(props);
      if (!propTween && jQuery.isEmptyObject(orig)) {
        return;
      }

      // Restrict "overflow" and "display" styles during box animations
      if (isBox && elem.nodeType === 1) {

        // Support: IE <=9 - 11, Edge 12 - 15
        // Record all 3 overflow attributes because IE does not infer the shorthand
        // from identically-valued overflowX and overflowY and Edge just mirrors
        // the overflowX value there.
        opts.overflow = [style.overflow, style.overflowX, style.overflowY];

        // Identify a display type, preferring old show/hide data over the CSS cascade
        restoreDisplay = dataShow && dataShow.display;
        if (restoreDisplay == null) {
          restoreDisplay = dataPriv.get(elem, "display");
        }
        display = jQuery.css(elem, "display");
        if (display === "none") {
          if (restoreDisplay) {
            display = restoreDisplay;
          } else {

            // Get nonempty value(s) by temporarily forcing visibility
            showHide([elem], true);
            restoreDisplay = elem.style.display || restoreDisplay;
            display = jQuery.css(elem, "display");
            showHide([elem]);
          }
        }

        // Animate inline elements as inline-block
        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
          if (jQuery.css(elem, "float") === "none") {

            // Restore the original display value at the end of pure show/hide animations
            if (!propTween) {
              anim.done(function () {
                style.display = restoreDisplay;
              });
              if (restoreDisplay == null) {
                display = style.display;
                restoreDisplay = display === "none" ? "" : display;
              }
            }
            style.display = "inline-block";
          }
        }
      }

      if (opts.overflow) {
        style.overflow = "hidden";
        anim.always(function () {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      }

      // Implement show/hide animations
      propTween = false;
      for (prop in orig) {

        // General show/hide setup for this element animation
        if (!propTween) {
          if (dataShow) {
            if ("hidden" in dataShow) {
              hidden = dataShow.hidden;
            }
          } else {
            dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
          }

          // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
          if (toggle) {
            dataShow.hidden = !hidden;
          }

          // Show elements before animating them
          if (hidden) {
            showHide([elem], true);
          }

          /* eslint-disable no-loop-func */

          anim.done(function () {

            /* eslint-enable no-loop-func */

            // The final step of a "hide" animation is actually hiding the element
            if (!hidden) {
              showHide([elem]);
            }
            dataPriv.remove(elem, "fxshow");
            for (prop in orig) {
              jQuery.style(elem, prop, orig[prop]);
            }
          });
        }

        // Per-property setup
        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = propTween.start;
          if (hidden) {
            propTween.end = propTween.start;
            propTween.start = 0;
          }
        }
      }
    }

    function propFilter(props, specialEasing) {
      var index, name, easing, value, hooks;

      // camelCase, specialEasing and expand cssHook pass
      for (index in props) {
        name = camelCase(index);
        easing = specialEasing[name];
        value = props[index];
        if (Array.isArray(value)) {
          easing = value[1];
          value = props[index] = value[0];
        }

        if (index !== name) {
          props[name] = value;
          delete props[index];
        }

        hooks = jQuery.cssHooks[name];
        if (hooks && "expand" in hooks) {
          value = hooks.expand(value);
          delete props[name];

          // Not quite $.extend, this won't overwrite existing keys.
          // Reusing 'index' because we have the correct "name"
          for (index in value) {
            if (!(index in props)) {
              props[index] = value[index];
              specialEasing[index] = easing;
            }
          }
        } else {
          specialEasing[name] = easing;
        }
      }
    }

    function Animation(elem, properties, options) {
      var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function () {

          // Don't match elem in the :animated selector
          delete tick.elem;
        }),
        tick = function () {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(),
            remaining = Math.max(0, animation.startTime + animation.duration - currentTime),

            // Support: Android 2.3 only
            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
            temp = remaining / animation.duration || 0,
            percent = 1 - temp,
            index = 0,
            length = animation.tweens.length;

          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }

          deferred.notifyWith(elem, [animation, percent, remaining]);

          // If there's more to do, yield
          if (percent < 1 && length) {
            return remaining;
          }

          // If this was an empty animation, synthesize a final progress notification
          if (!length) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          }

          // Resolve the animation and report its conclusion
          deferred.resolveWith(elem, [animation]);
          return false;
        },
        animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function (prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end,
              animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function (gotoEnd) {
            var index = 0,

              // If we are going to the end, we want to run all the tweens
              // otherwise we skip this part
              length = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index < length; index++) {
              animation.tweens[index].run(1);
            }

            // Resolve when we played the last frame; otherwise, reject
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }),
        props = animation.props;

      propFilter(props, animation.opts.specialEasing);

      for (; index < length; index++) {
        result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
        if (result) {
          if (isFunction(result.stop)) {
            jQuery._queueHooks(animation.elem, animation.opts.queue).stop =
              result.stop.bind(result);
          }
          return result;
        }
      }

      jQuery.map(props, createTween, animation);

      if (isFunction(animation.opts.start)) {
        animation.opts.start.call(elem, animation);
      }

      // Attach callbacks from options
      animation
        .progress(animation.opts.progress)
        .done(animation.opts.done, animation.opts.complete)
        .fail(animation.opts.fail)
        .always(animation.opts.always);

      jQuery.fx.timer(
        jQuery.extend(tick, {
          elem: elem,
          anim: animation,
          queue: animation.opts.queue
        })
      );

      return animation;
    }

    jQuery.Animation = jQuery.extend(Animation, {

      tweeners: {
        "*": [function (prop, value) {
          var tween = this.createTween(prop, value);
          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
          return tween;
        }]
      },

      tweener: function (props, callback) {
        if (isFunction(props)) {
          callback = props;
          props = ["*"];
        } else {
          props = props.match(rnothtmlwhite);
        }

        var prop,
          index = 0,
          length = props.length;

        for (; index < length; index++) {
          prop = props[index];
          Animation.tweeners[prop] = Animation.tweeners[prop] || [];
          Animation.tweeners[prop].unshift(callback);
        }
      },

      prefilters: [defaultPrefilter],

      prefilter: function (callback, prepend) {
        if (prepend) {
          Animation.prefilters.unshift(callback);
        } else {
          Animation.prefilters.push(callback);
        }
      }
    });

    jQuery.speed = function (speed, easing, fn) {
      var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing ||
          isFunction(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !isFunction(easing) && easing
      };

      // Go to the end state if fx are off
      if (jQuery.fx.off) {
        opt.duration = 0;

      } else {
        if (typeof opt.duration !== "number") {
          if (opt.duration in jQuery.fx.speeds) {
            opt.duration = jQuery.fx.speeds[opt.duration];

          } else {
            opt.duration = jQuery.fx.speeds._default;
          }
        }
      }

      // Normalize opt.queue - true/undefined/null -> "fx"
      if (opt.queue == null || opt.queue === true) {
        opt.queue = "fx";
      }

      // Queueing
      opt.old = opt.complete;

      opt.complete = function () {
        if (isFunction(opt.old)) {
          opt.old.call(this);
        }

        if (opt.queue) {
          jQuery.dequeue(this, opt.queue);
        }
      };

      return opt;
    };

    jQuery.fn.extend({
      fadeTo: function (speed, to, easing, callback) {

        // Show any hidden elements after setting opacity to 0
        return this.filter(isHiddenWithinTree).css("opacity", 0).show()

          // Animate to the value specified
          .end().animate({ opacity: to }, speed, easing, callback);
      },
      animate: function (prop, speed, easing, callback) {
        var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function () {

            // Operate on a copy of prop so per-property easing won't be lost
            var anim = Animation(this, jQuery.extend({}, prop), optall);

            // Empty animations, or finishing resolves immediately
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };

        doAnimation.finish = doAnimation;

        return empty || optall.queue === false ?
          this.each(doAnimation) :
          this.queue(optall.queue, doAnimation);
      },
      stop: function (type, clearQueue, gotoEnd) {
        var stopQueue = function (hooks) {
          var stop = hooks.stop;
          delete hooks.stop;
          stop(gotoEnd);
        };

        if (typeof type !== "string") {
          gotoEnd = clearQueue;
          clearQueue = type;
          type = undefined;
        }
        if (clearQueue) {
          this.queue(type || "fx", []);
        }

        return this.each(function () {
          var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);

          if (index) {
            if (data[index] && data[index].stop) {
              stopQueue(data[index]);
            }
          } else {
            for (index in data) {
              if (data[index] && data[index].stop && rrun.test(index)) {
                stopQueue(data[index]);
              }
            }
          }

          for (index = timers.length; index--;) {
            if (timers[index].elem === this &&
              (type == null || timers[index].queue === type)) {

              timers[index].anim.stop(gotoEnd);
              dequeue = false;
              timers.splice(index, 1);
            }
          }

          // Start the next in the queue if the last step wasn't forced.
          // Timers currently will call their complete callbacks, which
          // will dequeue but only if they were gotoEnd.
          if (dequeue || !gotoEnd) {
            jQuery.dequeue(this, type);
          }
        });
      },
      finish: function (type) {
        if (type !== false) {
          type = type || "fx";
        }
        return this.each(function () {
          var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;

          // Enable finishing flag on private data
          data.finish = true;

          // Empty the queue first
          jQuery.queue(this, type, []);

          if (hooks && hooks.stop) {
            hooks.stop.call(this, true);
          }

          // Look for any active animations, and finish them
          for (index = timers.length; index--;) {
            if (timers[index].elem === this && timers[index].queue === type) {
              timers[index].anim.stop(true);
              timers.splice(index, 1);
            }
          }

          // Look for any animations in the old queue and finish them
          for (index = 0; index < length; index++) {
            if (queue[index] && queue[index].finish) {
              queue[index].finish.call(this);
            }
          }

          // Turn off finishing flag
          delete data.finish;
        });
      }
    });

    jQuery.each(["toggle", "show", "hide"], function (_i, name) {
      var cssFn = jQuery.fn[name];
      jQuery.fn[name] = function (speed, easing, callback) {
        return speed == null || typeof speed === "boolean" ?
          cssFn.apply(this, arguments) :
          this.animate(genFx(name, true), speed, easing, callback);
      };
    });

    // Generate shortcuts for custom animations
    jQuery.each({
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: { opacity: "show" },
      fadeOut: { opacity: "hide" },
      fadeToggle: { opacity: "toggle" }
    }, function (name, props) {
      jQuery.fn[name] = function (speed, easing, callback) {
        return this.animate(props, speed, easing, callback);
      };
    });

    jQuery.timers = [];
    jQuery.fx.tick = function () {
      var timer,
        i = 0,
        timers = jQuery.timers;

      fxNow = Date.now();

      for (; i < timers.length; i++) {
        timer = timers[i];

        // Run the timer and safely remove it when done (allowing for external removal)
        if (!timer() && timers[i] === timer) {
          timers.splice(i--, 1);
        }
      }

      if (!timers.length) {
        jQuery.fx.stop();
      }
      fxNow = undefined;
    };

    jQuery.fx.timer = function (timer) {
      jQuery.timers.push(timer);
      jQuery.fx.start();
    };

    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
      if (inProgress) {
        return;
      }

      inProgress = true;
      schedule();
    };

    jQuery.fx.stop = function () {
      inProgress = null;
    };

    jQuery.fx.speeds = {
      slow: 600,
      fast: 200,

      // Default speed
      _default: 400
    };


    // Based off of the plugin by Clint Helfers, with permission.
    jQuery.fn.delay = function (time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || "fx";

      return this.queue(type, function (next, hooks) {
        var timeout = window.setTimeout(next, time);
        hooks.stop = function () {
          window.clearTimeout(timeout);
        };
      });
    };


    (function () {
      var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));

      input.type = "checkbox";

      // Support: Android <=4.3 only
      // Default value for a checkbox should be "on"
      support.checkOn = input.value !== "";

      // Support: IE <=11 only
      // Must access selectedIndex to make default options select
      support.optSelected = opt.selected;

      // Support: IE <=11 only
      // An input loses its value after becoming a radio
      input = document.createElement("input");
      input.value = "t";
      input.type = "radio";
      support.radioValue = input.value === "t";
    })();


    var boolHook,
      attrHandle = jQuery.expr.attrHandle;

    jQuery.fn.extend({
      attr: function (name, value) {
        return access(this, jQuery.attr, name, value, arguments.length > 1);
      },

      removeAttr: function (name) {
        return this.each(function () {
          jQuery.removeAttr(this, name);
        });
      }
    });

    jQuery.extend({
      attr: function (elem, name, value) {
        var ret, hooks,
          nType = elem.nodeType;

        // Don't get/set attributes on text, comment and attribute nodes
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }

        // Fallback to prop when attributes are not supported
        if (typeof elem.getAttribute === "undefined") {
          return jQuery.prop(elem, name, value);
        }

        // Attribute hooks are determined by the lowercase version
        // Grab necessary hook if one is defined
        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          hooks = jQuery.attrHooks[name.toLowerCase()] ||
            (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
        }

        if (value !== undefined) {
          if (value === null) {
            jQuery.removeAttr(elem, name);
            return;
          }

          if (hooks && "set" in hooks &&
            (ret = hooks.set(elem, value, name)) !== undefined) {
            return ret;
          }

          elem.setAttribute(name, value + "");
          return value;
        }

        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }

        ret = jQuery.find.attr(elem, name);

        // Non-existent attributes return null, we normalize to undefined
        return ret == null ? undefined : ret;
      },

      attrHooks: {
        type: {
          set: function (elem, value) {
            if (!support.radioValue && value === "radio" &&
              nodeName(elem, "input")) {
              var val = elem.value;
              elem.setAttribute("type", value);
              if (val) {
                elem.value = val;
              }
              return value;
            }
          }
        }
      },

      removeAttr: function (elem, value) {
        var name,
          i = 0,

          // Attribute names can contain non-HTML whitespace characters
          // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
          attrNames = value && value.match(rnothtmlwhite);

        if (attrNames && elem.nodeType === 1) {
          while ((name = attrNames[i++])) {
            elem.removeAttribute(name);
          }
        }
      }
    });

    // Hooks for boolean attributes
    boolHook = {
      set: function (elem, value, name) {
        if (value === false) {

          // Remove boolean attributes when set to false
          jQuery.removeAttr(elem, name);
        } else {
          elem.setAttribute(name, name);
        }
        return name;
      }
    };

    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
      var getter = attrHandle[name] || jQuery.find.attr;

      attrHandle[name] = function (elem, name, isXML) {
        var ret, handle,
          lowercaseName = name.toLowerCase();

        if (!isXML) {

          // Avoid an infinite loop by temporarily removing this function from the getter
          handle = attrHandle[lowercaseName];
          attrHandle[lowercaseName] = ret;
          ret = getter(elem, name, isXML) != null ?
            lowercaseName :
            null;
          attrHandle[lowercaseName] = handle;
        }
        return ret;
      };
    });




    var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;

    jQuery.fn.extend({
      prop: function (name, value) {
        return access(this, jQuery.prop, name, value, arguments.length > 1);
      },

      removeProp: function (name) {
        return this.each(function () {
          delete this[jQuery.propFix[name] || name];
        });
      }
    });

    jQuery.extend({
      prop: function (elem, name, value) {
        var ret, hooks,
          nType = elem.nodeType;

        // Don't get/set properties on text, comment and attribute nodes
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }

        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

          // Fix name and attach hooks
          name = jQuery.propFix[name] || name;
          hooks = jQuery.propHooks[name];
        }

        if (value !== undefined) {
          if (hooks && "set" in hooks &&
            (ret = hooks.set(elem, value, name)) !== undefined) {
            return ret;
          }

          return (elem[name] = value);
        }

        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }

        return elem[name];
      },

      propHooks: {
        tabIndex: {
          get: function (elem) {

            // Support: IE <=9 - 11 only
            // elem.tabIndex doesn't always return the
            // correct value when it hasn't been explicitly set
            // Use proper attribute retrieval (trac-12072)
            var tabindex = jQuery.find.attr(elem, "tabindex");

            if (tabindex) {
              return parseInt(tabindex, 10);
            }

            if (
              rfocusable.test(elem.nodeName) ||
              rclickable.test(elem.nodeName) &&
              elem.href
            ) {
              return 0;
            }

            return -1;
          }
        }
      },

      propFix: {
        "for": "htmlFor",
        "class": "className"
      }
    });

    // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    // eslint rule "no-unused-expressions" is disabled for this code
    // since it considers such accessions noop
    if (!support.optSelected) {
      jQuery.propHooks.selected = {
        get: function (elem) {

          /* eslint no-unused-expressions: "off" */

          var parent = elem.parentNode;
          if (parent && parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
          return null;
        },
        set: function (elem) {

          /* eslint no-unused-expressions: "off" */

          var parent = elem.parentNode;
          if (parent) {
            parent.selectedIndex;

            if (parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
          }
        }
      };
    }

    jQuery.each([
      "tabIndex",
      "readOnly",
      "maxLength",
      "cellSpacing",
      "cellPadding",
      "rowSpan",
      "colSpan",
      "useMap",
      "frameBorder",
      "contentEditable"
    ], function () {
      jQuery.propFix[this.toLowerCase()] = this;
    });




    // Strip and collapse whitespace according to HTML spec
    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
    function stripAndCollapse(value) {
      var tokens = value.match(rnothtmlwhite) || [];
      return tokens.join(" ");
    }


    function getClass(elem) {
      return elem.getAttribute && elem.getAttribute("class") || "";
    }

    function classesToArray(value) {
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "string") {
        return value.match(rnothtmlwhite) || [];
      }
      return [];
    }

    jQuery.fn.extend({
      addClass: function (value) {
        var classNames, cur, curValue, className, i, finalValue;

        if (isFunction(value)) {
          return this.each(function (j) {
            jQuery(this).addClass(value.call(this, j, getClass(this)));
          });
        }

        classNames = classesToArray(value);

        if (classNames.length) {
          return this.each(function () {
            curValue = getClass(this);
            cur = this.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

            if (cur) {
              for (i = 0; i < classNames.length; i++) {
                className = classNames[i];
                if (cur.indexOf(" " + className + " ") < 0) {
                  cur += className + " ";
                }
              }

              // Only assign if different to avoid unneeded rendering.
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                this.setAttribute("class", finalValue);
              }
            }
          });
        }

        return this;
      },

      removeClass: function (value) {
        var classNames, cur, curValue, className, i, finalValue;

        if (isFunction(value)) {
          return this.each(function (j) {
            jQuery(this).removeClass(value.call(this, j, getClass(this)));
          });
        }

        if (!arguments.length) {
          return this.attr("class", "");
        }

        classNames = classesToArray(value);

        if (classNames.length) {
          return this.each(function () {
            curValue = getClass(this);

            // This expression is here for better compressibility (see addClass)
            cur = this.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

            if (cur) {
              for (i = 0; i < classNames.length; i++) {
                className = classNames[i];

                // Remove *all* instances
                while (cur.indexOf(" " + className + " ") > -1) {
                  cur = cur.replace(" " + className + " ", " ");
                }
              }

              // Only assign if different to avoid unneeded rendering.
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                this.setAttribute("class", finalValue);
              }
            }
          });
        }

        return this;
      },

      toggleClass: function (value, stateVal) {
        var classNames, className, i, self,
          type = typeof value,
          isValidValue = type === "string" || Array.isArray(value);

        if (isFunction(value)) {
          return this.each(function (i) {
            jQuery(this).toggleClass(
              value.call(this, i, getClass(this), stateVal),
              stateVal
            );
          });
        }

        if (typeof stateVal === "boolean" && isValidValue) {
          return stateVal ? this.addClass(value) : this.removeClass(value);
        }

        classNames = classesToArray(value);

        return this.each(function () {
          if (isValidValue) {

            // Toggle individual class names
            self = jQuery(this);

            for (i = 0; i < classNames.length; i++) {
              className = classNames[i];

              // Check each className given, space separated list
              if (self.hasClass(className)) {
                self.removeClass(className);
              } else {
                self.addClass(className);
              }
            }

            // Toggle whole class name
          } else if (value === undefined || type === "boolean") {
            className = getClass(this);
            if (className) {

              // Store className if set
              dataPriv.set(this, "__className__", className);
            }

            // If the element has a class name or if we're passed `false`,
            // then remove the whole classname (if there was one, the above saved it).
            // Otherwise bring back whatever was previously saved (if anything),
            // falling back to the empty string if nothing was stored.
            if (this.setAttribute) {
              this.setAttribute("class",
                className || value === false ?
                  "" :
                  dataPriv.get(this, "__className__") || ""
              );
            }
          }
        });
      },

      hasClass: function (selector) {
        var className, elem,
          i = 0;

        className = " " + selector + " ";
        while ((elem = this[i++])) {
          if (elem.nodeType === 1 &&
            (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
            return true;
          }
        }

        return false;
      }
    });




    var rreturn = /\r/g;

    jQuery.fn.extend({
      val: function (value) {
        var hooks, ret, valueIsFunction,
          elem = this[0];

        if (!arguments.length) {
          if (elem) {
            hooks = jQuery.valHooks[elem.type] ||
              jQuery.valHooks[elem.nodeName.toLowerCase()];

            if (hooks &&
              "get" in hooks &&
              (ret = hooks.get(elem, "value")) !== undefined
            ) {
              return ret;
            }

            ret = elem.value;

            // Handle most common string cases
            if (typeof ret === "string") {
              return ret.replace(rreturn, "");
            }

            // Handle cases where value is null/undef or number
            return ret == null ? "" : ret;
          }

          return;
        }

        valueIsFunction = isFunction(value);

        return this.each(function (i) {
          var val;

          if (this.nodeType !== 1) {
            return;
          }

          if (valueIsFunction) {
            val = value.call(this, i, jQuery(this).val());
          } else {
            val = value;
          }

          // Treat null/undefined as ""; convert numbers to string
          if (val == null) {
            val = "";

          } else if (typeof val === "number") {
            val += "";

          } else if (Array.isArray(val)) {
            val = jQuery.map(val, function (value) {
              return value == null ? "" : value + "";
            });
          }

          hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

          // If set returns undefined, fall back to normal setting
          if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
            this.value = val;
          }
        });
      }
    });

    jQuery.extend({
      valHooks: {
        option: {
          get: function (elem) {

            var val = jQuery.find.attr(elem, "value");
            return val != null ?
              val :

              // Support: IE <=10 - 11 only
              // option.text throws exceptions (trac-14686, trac-14858)
              // Strip and collapse whitespace
              // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
              stripAndCollapse(jQuery.text(elem));
          }
        },
        select: {
          get: function (elem) {
            var value, option, i,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one",
              values = one ? null : [],
              max = one ? index + 1 : options.length;

            if (index < 0) {
              i = max;

            } else {
              i = one ? index : 0;
            }

            // Loop through all the selected options
            for (; i < max; i++) {
              option = options[i];

              // Support: IE <=9 only
              // IE8-9 doesn't update selected after form reset (trac-2551)
              if ((option.selected || i === index) &&

                // Don't return options that are disabled or in a disabled optgroup
                !option.disabled &&
                (!option.parentNode.disabled ||
                  !nodeName(option.parentNode, "optgroup"))) {

                // Get the specific value for the option
                value = jQuery(option).val();

                // We don't need an array for one selects
                if (one) {
                  return value;
                }

                // Multi-Selects return an array
                values.push(value);
              }
            }

            return values;
          },

          set: function (elem, value) {
            var optionSet, option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;

            while (i--) {
              option = options[i];

              /* eslint-disable no-cond-assign */

              if (option.selected =
                jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1
              ) {
                optionSet = true;
              }

              /* eslint-enable no-cond-assign */
            }

            // Force browsers to behave consistently when non-matching value is set
            if (!optionSet) {
              elem.selectedIndex = -1;
            }
            return values;
          }
        }
      }
    });

    // Radios and checkboxes getter/setter
    jQuery.each(["radio", "checkbox"], function () {
      jQuery.valHooks[this] = {
        set: function (elem, value) {
          if (Array.isArray(value)) {
            return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
          }
        }
      };
      if (!support.checkOn) {
        jQuery.valHooks[this].get = function (elem) {
          return elem.getAttribute("value") === null ? "on" : elem.value;
        };
      }
    });




    // Return jQuery for attributes-only inclusion
    var location = window.location;

    var nonce = { guid: Date.now() };

    var rquery = (/\?/);



    // Cross-browser xml parsing
    jQuery.parseXML = function (data) {
      var xml, parserErrorElem;
      if (!data || typeof data !== "string") {
        return null;
      }

      // Support: IE 9 - 11 only
      // IE throws on parseFromString with invalid input.
      try {
        xml = (new window.DOMParser()).parseFromString(data, "text/xml");
      } catch (e) { }

      parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
      if (!xml || parserErrorElem) {
        jQuery.error("Invalid XML: " + (
          parserErrorElem ?
            jQuery.map(parserErrorElem.childNodes, function (el) {
              return el.textContent;
            }).join("\n") :
            data
        ));
      }
      return xml;
    };


    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      stopPropagationCallback = function (e) {
        e.stopPropagation();
      };

    jQuery.extend(jQuery.event, {

      trigger: function (event, data, elem, onlyHandlers) {

        var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

        cur = lastElement = tmp = elem = elem || document;

        // Don't do events on text and comment nodes
        if (elem.nodeType === 3 || elem.nodeType === 8) {
          return;
        }

        // focus/blur morphs to focusin/out; ensure we're not firing them right now
        if (rfocusMorph.test(type + jQuery.event.triggered)) {
          return;
        }

        if (type.indexOf(".") > -1) {

          // Namespaced trigger; create a regexp to match event type in handle()
          namespaces = type.split(".");
          type = namespaces.shift();
          namespaces.sort();
        }
        ontype = type.indexOf(":") < 0 && "on" + type;

        // Caller can pass in a jQuery.Event object, Object, or just an event type string
        event = event[jQuery.expando] ?
          event :
          new jQuery.Event(type, typeof event === "object" && event);

        // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.rnamespace = event.namespace ?
          new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
          null;

        // Clean up the event in case it is being reused
        event.result = undefined;
        if (!event.target) {
          event.target = elem;
        }

        // Clone any incoming data and prepend the event, creating the handler arg list
        data = data == null ?
          [event] :
          jQuery.makeArray(data, [event]);

        // Allow special events to draw outside the lines
        special = jQuery.event.special[type] || {};
        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
          return;
        }

        // Determine event propagation path in advance, per W3C events spec (trac-9951)
        // Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
        if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {

          bubbleType = special.delegateType || type;
          if (!rfocusMorph.test(bubbleType + type)) {
            cur = cur.parentNode;
          }
          for (; cur; cur = cur.parentNode) {
            eventPath.push(cur);
            tmp = cur;
          }

          // Only add window if we got to document (e.g., not plain obj or detached DOM)
          if (tmp === (elem.ownerDocument || document)) {
            eventPath.push(tmp.defaultView || tmp.parentWindow || window);
          }
        }

        // Fire handlers on the event path
        i = 0;
        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
          lastElement = cur;
          event.type = i > 1 ?
            bubbleType :
            special.bindType || type;

          // jQuery handler
          handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] &&
            dataPriv.get(cur, "handle");
          if (handle) {
            handle.apply(cur, data);
          }

          // Native handler
          handle = ontype && cur[ontype];
          if (handle && handle.apply && acceptData(cur)) {
            event.result = handle.apply(cur, data);
            if (event.result === false) {
              event.preventDefault();
            }
          }
        }
        event.type = type;

        // If nobody prevented the default action, do it now
        if (!onlyHandlers && !event.isDefaultPrevented()) {

          if ((!special._default ||
            special._default.apply(eventPath.pop(), data) === false) &&
            acceptData(elem)) {

            // Call a native DOM method on the target with the same name as the event.
            // Don't do default actions on window, that's where global variables be (trac-6170)
            if (ontype && isFunction(elem[type]) && !isWindow(elem)) {

              // Don't re-trigger an onFOO event when we call its FOO() method
              tmp = elem[ontype];

              if (tmp) {
                elem[ontype] = null;
              }

              // Prevent re-triggering of the same event, since we already bubbled it above
              jQuery.event.triggered = type;

              if (event.isPropagationStopped()) {
                lastElement.addEventListener(type, stopPropagationCallback);
              }

              elem[type]();

              if (event.isPropagationStopped()) {
                lastElement.removeEventListener(type, stopPropagationCallback);
              }

              jQuery.event.triggered = undefined;

              if (tmp) {
                elem[ontype] = tmp;
              }
            }
          }
        }

        return event.result;
      },

      // Piggyback on a donor event to simulate a different one
      // Used only for `focus(in | out)` events
      simulate: function (type, elem, event) {
        var e = jQuery.extend(
          new jQuery.Event(),
          event,
          {
            type: type,
            isSimulated: true
          }
        );

        jQuery.event.trigger(e, null, elem);
      }

    });

    jQuery.fn.extend({

      trigger: function (type, data) {
        return this.each(function () {
          jQuery.event.trigger(type, data, this);
        });
      },
      triggerHandler: function (type, data) {
        var elem = this[0];
        if (elem) {
          return jQuery.event.trigger(type, data, elem, true);
        }
      }
    });


    var
      rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
      var name;

      if (Array.isArray(obj)) {

        // Serialize array item.
        jQuery.each(obj, function (i, v) {
          if (traditional || rbracket.test(prefix)) {

            // Treat each array item as a scalar.
            add(prefix, v);

          } else {

            // Item is non-scalar (array or object), encode its numeric index.
            buildParams(
              prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
              v,
              traditional,
              add
            );
          }
        });

      } else if (!traditional && toType(obj) === "object") {

        // Serialize object item.
        for (name in obj) {
          buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
        }

      } else {

        // Serialize scalar item.
        add(prefix, obj);
      }
    }

    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function (a, traditional) {
      var prefix,
        s = [],
        add = function (key, valueOrFunction) {

          // If value is a function, invoke it and use its return value
          var value = isFunction(valueOrFunction) ?
            valueOrFunction() :
            valueOrFunction;

          s[s.length] = encodeURIComponent(key) + "=" +
            encodeURIComponent(value == null ? "" : value);
        };

      if (a == null) {
        return "";
      }

      // If an array was passed in, assume that it is an array of form elements.
      if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {

        // Serialize the form elements
        jQuery.each(a, function () {
          add(this.name, this.value);
        });

      } else {

        // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for (prefix in a) {
          buildParams(prefix, a[prefix], traditional, add);
        }
      }

      // Return the resulting serialization
      return s.join("&");
    };

    jQuery.fn.extend({
      serialize: function () {
        return jQuery.param(this.serializeArray());
      },
      serializeArray: function () {
        return this.map(function () {

          // Can add propHook for "elements" to filter or add form elements
          var elements = jQuery.prop(this, "elements");
          return elements ? jQuery.makeArray(elements) : this;
        }).filter(function () {
          var type = this.type;

          // Use .is( ":disabled" ) so that fieldset[disabled] works
          return this.name && !jQuery(this).is(":disabled") &&
            rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
            (this.checked || !rcheckableType.test(type));
        }).map(function (_i, elem) {
          var val = jQuery(this).val();

          if (val == null) {
            return null;
          }

          if (Array.isArray(val)) {
            return jQuery.map(val, function (val) {
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            });
          }

          return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
        }).get();
      }
    });


    var
      r20 = /%20/g,
      rhash = /#.*$/,
      rantiCache = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

      // trac-7653, trac-8125, trac-8152: local protocol detection
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,

      /* Prefilters
       * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
       * 2) These are called:
       *    - BEFORE asking for a transport
       *    - AFTER param serialization (s.data is a string if s.processData is true)
       * 3) key is the dataType
       * 4) the catchall symbol "*" can be used
       * 5) execution will start with transport dataType and THEN continue down to "*" if needed
       */
      prefilters = {},

      /* Transports bindings
       * 1) key is the dataType
       * 2) the catchall symbol "*" can be used
       * 3) selection will start with transport dataType and THEN go to "*" if needed
       */
      transports = {},

      // Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
      allTypes = "*/".concat("*"),

      // Anchor tag for parsing the document origin
      originAnchor = document.createElement("a");

    originAnchor.href = location.href;

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

      // dataTypeExpression is optional and defaults to "*"
      return function (dataTypeExpression, func) {

        if (typeof dataTypeExpression !== "string") {
          func = dataTypeExpression;
          dataTypeExpression = "*";
        }

        var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

        if (isFunction(func)) {

          // For each dataType in the dataTypeExpression
          while ((dataType = dataTypes[i++])) {

            // Prepend if requested
            if (dataType[0] === "+") {
              dataType = dataType.slice(1) || "*";
              (structure[dataType] = structure[dataType] || []).unshift(func);

              // Otherwise append
            } else {
              (structure[dataType] = structure[dataType] || []).push(func);
            }
          }
        }
      };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

      var inspected = {},
        seekingTransport = (structure === transports);

      function inspect(dataType) {
        var selected;
        inspected[dataType] = true;
        jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
          var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
          if (typeof dataTypeOrTransport === "string" &&
            !seekingTransport && !inspected[dataTypeOrTransport]) {

            options.dataTypes.unshift(dataTypeOrTransport);
            inspect(dataTypeOrTransport);
            return false;
          } else if (seekingTransport) {
            return !(selected = dataTypeOrTransport);
          }
        });
        return selected;
      }

      return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }

    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes trac-9887
    function ajaxExtend(target, src) {
      var key, deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

      for (key in src) {
        if (src[key] !== undefined) {
          (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
        }
      }
      if (deep) {
        jQuery.extend(true, target, deep);
      }

      return target;
    }

    /* Handles responses to an ajax request:
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
    function ajaxHandleResponses(s, jqXHR, responses) {

      var ct, type, finalDataType, firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;

      // Remove auto dataType and get content-type in the process
      while (dataTypes[0] === "*") {
        dataTypes.shift();
        if (ct === undefined) {
          ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
      }

      // Check if we're dealing with a known content-type
      if (ct) {
        for (type in contents) {
          if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
          }
        }
      }

      // Check to see if we have a response for the expected dataType
      if (dataTypes[0] in responses) {
        finalDataType = dataTypes[0];
      } else {

        // Try convertible dataTypes
        for (type in responses) {
          if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
            finalDataType = type;
            break;
          }
          if (!firstDataType) {
            firstDataType = type;
          }
        }

        // Or just use first one
        finalDataType = finalDataType || firstDataType;
      }

      // If we found a dataType
      // We add the dataType to the list if needed
      // and return the corresponding response
      if (finalDataType) {
        if (finalDataType !== dataTypes[0]) {
          dataTypes.unshift(finalDataType);
        }
        return responses[finalDataType];
      }
    }

    /* Chain conversions given the request and the original response
     * Also sets the responseXXX fields on the jqXHR instance
     */
    function ajaxConvert(s, response, jqXHR, isSuccess) {
      var conv2, current, conv, tmp, prev,
        converters = {},

        // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();

      // Create converters map with lowercased keys
      if (dataTypes[1]) {
        for (conv in s.converters) {
          converters[conv.toLowerCase()] = s.converters[conv];
        }
      }

      current = dataTypes.shift();

      // Convert to each sequential dataType
      while (current) {

        if (s.responseFields[current]) {
          jqXHR[s.responseFields[current]] = response;
        }

        // Apply the dataFilter if provided
        if (!prev && isSuccess && s.dataFilter) {
          response = s.dataFilter(response, s.dataType);
        }

        prev = current;
        current = dataTypes.shift();

        if (current) {

          // There's only work to do if current dataType is non-auto
          if (current === "*") {

            current = prev;

            // Convert response if prev dataType is non-auto and differs from current
          } else if (prev !== "*" && prev !== current) {

            // Seek a direct converter
            conv = converters[prev + " " + current] || converters["* " + current];

            // If none found, seek a pair
            if (!conv) {
              for (conv2 in converters) {

                // If conv2 outputs current
                tmp = conv2.split(" ");
                if (tmp[1] === current) {

                  // If prev can be converted to accepted input
                  conv = converters[prev + " " + tmp[0]] ||
                    converters["* " + tmp[0]];
                  if (conv) {

                    // Condense equivalence converters
                    if (conv === true) {
                      conv = converters[conv2];

                      // Otherwise, insert the intermediate dataType
                    } else if (converters[conv2] !== true) {
                      current = tmp[0];
                      dataTypes.unshift(tmp[1]);
                    }
                    break;
                  }
                }
              }
            }

            // Apply converter (if not an equivalence)
            if (conv !== true) {

              // Unless errors are allowed to bubble, catch and return them
              if (conv && s.throws) {
                response = conv(response);
              } else {
                try {
                  response = conv(response);
                } catch (e) {
                  return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                  };
                }
              }
            }
          }
        }
      }

      return { state: "success", data: response };
    }

    jQuery.extend({

      // Counter for holding the number of active queries
      active: 0,

      // Last-Modified header cache for next request
      lastModified: {},
      etag: {},

      ajaxSettings: {
        url: location.href,
        type: "GET",
        isLocal: rlocalProtocol.test(location.protocol),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",

        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */

        accepts: {
          "*": allTypes,
          text: "text/plain",
          html: "text/html",
          xml: "application/xml, text/xml",
          json: "application/json, text/javascript"
        },

        contents: {
          xml: /\bxml\b/,
          html: /\bhtml/,
          json: /\bjson\b/
        },

        responseFields: {
          xml: "responseXML",
          text: "responseText",
          json: "responseJSON"
        },

        // Data converters
        // Keys separate source (or catchall "*") and destination types with a single space
        converters: {

          // Convert anything to text
          "* text": String,

          // Text to html (true = no transformation)
          "text html": true,

          // Evaluate text as a json expression
          "text json": JSON.parse,

          // Parse text as xml
          "text xml": jQuery.parseXML
        },

        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
          url: true,
          context: true
        }
      },

      // Creates a full fledged settings object into target
      // with both ajaxSettings and settings fields.
      // If target is omitted, writes into ajaxSettings.
      ajaxSetup: function (target, settings) {
        return settings ?

          // Building a settings object
          ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

          // Extending ajaxSettings
          ajaxExtend(jQuery.ajaxSettings, target);
      },

      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
      ajaxTransport: addToPrefiltersOrTransports(transports),

      // Main method
      ajax: function (url, options) {

        // If url is an object, simulate pre-1.5 signature
        if (typeof url === "object") {
          options = url;
          url = undefined;
        }

        // Force options to be an object
        options = options || {};

        var transport,

          // URL without anti-cache param
          cacheURL,

          // Response headers
          responseHeadersString,
          responseHeaders,

          // timeout handle
          timeoutTimer,

          // Url cleanup var
          urlAnchor,

          // Request state (becomes false upon send and true upon completion)
          completed,

          // To know if global events are to be dispatched
          fireGlobals,

          // Loop variable
          i,

          // uncached part of the url
          uncached,

          // Create the final options object
          s = jQuery.ajaxSetup({}, options),

          // Callbacks context
          callbackContext = s.context || s,

          // Context for global events is callbackContext if it is a DOM node or jQuery collection
          globalEventContext = s.context &&
            (callbackContext.nodeType || callbackContext.jquery) ?
            jQuery(callbackContext) :
            jQuery.event,

          // Deferreds
          deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),

          // Status-dependent callbacks
          statusCode = s.statusCode || {},

          // Headers (they are sent all at once)
          requestHeaders = {},
          requestHeadersNames = {},

          // Default abort message
          strAbort = "canceled",

          // Fake xhr
          jqXHR = {
            readyState: 0,

            // Builds headers hashtable if needed
            getResponseHeader: function (key) {
              var match;
              if (completed) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while ((match = rheaders.exec(responseHeadersString))) {
                    responseHeaders[match[1].toLowerCase() + " "] =
                      (responseHeaders[match[1].toLowerCase() + " "] || [])
                        .concat(match[2]);
                  }
                }
                match = responseHeaders[key.toLowerCase() + " "];
              }
              return match == null ? null : match.join(", ");
            },

            // Raw string
            getAllResponseHeaders: function () {
              return completed ? responseHeadersString : null;
            },

            // Caches the header
            setRequestHeader: function (name, value) {
              if (completed == null) {
                name = requestHeadersNames[name.toLowerCase()] =
                  requestHeadersNames[name.toLowerCase()] || name;
                requestHeaders[name] = value;
              }
              return this;
            },

            // Overrides response content-type header
            overrideMimeType: function (type) {
              if (completed == null) {
                s.mimeType = type;
              }
              return this;
            },

            // Status-dependent callbacks
            statusCode: function (map) {
              var code;
              if (map) {
                if (completed) {

                  // Execute the appropriate callbacks
                  jqXHR.always(map[jqXHR.status]);
                } else {

                  // Lazy-add the new callbacks in a way that preserves old ones
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                }
              }
              return this;
            },

            // Cancel the request
            abort: function (statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };

        // Attach deferreds
        deferred.promise(jqXHR);

        // Add protocol if not provided (prefilters might expect it)
        // Handle falsy url in the settings object (trac-10093: consistency with old signature)
        // We also use the url parameter if available
        s.url = ((url || s.url || location.href) + "")
          .replace(rprotocol, location.protocol + "//");

        // Alias method option to type as per ticket trac-12004
        s.type = options.method || options.type || s.method || s.type;

        // Extract dataTypes list
        s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];

        // A cross-domain request is in order when the origin doesn't match the current origin.
        if (s.crossDomain == null) {
          urlAnchor = document.createElement("a");

          // Support: IE <=8 - 11, Edge 12 - 15
          // IE throws exception on accessing the href property if url is malformed,
          // e.g. http://example.com:80x/
          try {
            urlAnchor.href = s.url;

            // Support: IE <=8 - 11 only
            // Anchor's host property isn't correctly set when s.url is relative
            urlAnchor.href = urlAnchor.href;
            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
              urlAnchor.protocol + "//" + urlAnchor.host;
          } catch (e) {

            // If there is an error parsing the URL, assume it is crossDomain,
            // it can be rejected by the transport if it is invalid
            s.crossDomain = true;
          }
        }

        // Convert data if not already a string
        if (s.data && s.processData && typeof s.data !== "string") {
          s.data = jQuery.param(s.data, s.traditional);
        }

        // Apply prefilters
        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

        // If request was aborted inside a prefilter, stop there
        if (completed) {
          return jqXHR;
        }

        // We can fire global events as of now if asked to
        // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
        fireGlobals = jQuery.event && s.global;

        // Watch for a new set of requests
        if (fireGlobals && jQuery.active++ === 0) {
          jQuery.event.trigger("ajaxStart");
        }

        // Uppercase the type
        s.type = s.type.toUpperCase();

        // Determine if request has content
        s.hasContent = !rnoContent.test(s.type);

        // Save the URL in case we're toying with the If-Modified-Since
        // and/or If-None-Match header later on
        // Remove hash to simplify url manipulation
        cacheURL = s.url.replace(rhash, "");

        // More options handling for requests with no content
        if (!s.hasContent) {

          // Remember the hash so we can put it back
          uncached = s.url.slice(cacheURL.length);

          // If data is available and should be processed, append data to url
          if (s.data && (s.processData || typeof s.data === "string")) {
            cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;

            // trac-9682: remove data so that it's not used in an eventual retry
            delete s.data;
          }

          // Add or update anti-cache param if needed
          if (s.cache === false) {
            cacheURL = cacheURL.replace(rantiCache, "$1");
            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + (nonce.guid++) +
              uncached;
          }

          // Put hash and anti-cache on the URL that will be requested (gh-1732)
          s.url = cacheURL + uncached;

          // Change '%20' to '+' if this is encoded form body content (gh-2658)
        } else if (s.data && s.processData &&
          (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
          s.data = s.data.replace(r20, "+");
        }

        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
        if (s.ifModified) {
          if (jQuery.lastModified[cacheURL]) {
            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
          }
          if (jQuery.etag[cacheURL]) {
            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
          }
        }

        // Set the correct header, if data is being sent
        if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
          jqXHR.setRequestHeader("Content-Type", s.contentType);
        }

        // Set the Accepts header for the server, depending on the dataType
        jqXHR.setRequestHeader(
          "Accept",
          s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
            s.accepts[s.dataTypes[0]] +
            (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
            s.accepts["*"]
        );

        // Check for headers option
        for (i in s.headers) {
          jqXHR.setRequestHeader(i, s.headers[i]);
        }

        // Allow custom headers/mimetypes and early abort
        if (s.beforeSend &&
          (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {

          // Abort if not done already and return
          return jqXHR.abort();
        }

        // Aborting is no longer a cancellation
        strAbort = "abort";

        // Install callbacks on deferreds
        completeDeferred.add(s.complete);
        jqXHR.done(s.success);
        jqXHR.fail(s.error);

        // Get transport
        transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

        // If no transport, we auto-abort
        if (!transport) {
          done(-1, "No Transport");
        } else {
          jqXHR.readyState = 1;

          // Send global event
          if (fireGlobals) {
            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
          }

          // If request was aborted inside ajaxSend, stop there
          if (completed) {
            return jqXHR;
          }

          // Timeout
          if (s.async && s.timeout > 0) {
            timeoutTimer = window.setTimeout(function () {
              jqXHR.abort("timeout");
            }, s.timeout);
          }

          try {
            completed = false;
            transport.send(requestHeaders, done);
          } catch (e) {

            // Rethrow post-completion exceptions
            if (completed) {
              throw e;
            }

            // Propagate others as results
            done(-1, e);
          }
        }

        // Callback for when everything is done
        function done(status, nativeStatusText, responses, headers) {
          var isSuccess, success, error, response, modified,
            statusText = nativeStatusText;

          // Ignore repeat invocations
          if (completed) {
            return;
          }

          completed = true;

          // Clear timeout if it exists
          if (timeoutTimer) {
            window.clearTimeout(timeoutTimer);
          }

          // Dereference transport for early garbage collection
          // (no matter how long the jqXHR object will be used)
          transport = undefined;

          // Cache response headers
          responseHeadersString = headers || "";

          // Set readyState
          jqXHR.readyState = status > 0 ? 4 : 0;

          // Determine if successful
          isSuccess = status >= 200 && status < 300 || status === 304;

          // Get response data
          if (responses) {
            response = ajaxHandleResponses(s, jqXHR, responses);
          }

          // Use a noop converter for missing script but not if jsonp
          if (!isSuccess &&
            jQuery.inArray("script", s.dataTypes) > -1 &&
            jQuery.inArray("json", s.dataTypes) < 0) {
            s.converters["text script"] = function () { };
          }

          // Convert no matter what (that way responseXXX fields are always set)
          response = ajaxConvert(s, response, jqXHR, isSuccess);

          // If successful, handle type chaining
          if (isSuccess) {

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
              modified = jqXHR.getResponseHeader("Last-Modified");
              if (modified) {
                jQuery.lastModified[cacheURL] = modified;
              }
              modified = jqXHR.getResponseHeader("etag");
              if (modified) {
                jQuery.etag[cacheURL] = modified;
              }
            }

            // if no content
            if (status === 204 || s.type === "HEAD") {
              statusText = "nocontent";

              // if not modified
            } else if (status === 304) {
              statusText = "notmodified";

              // If we have data, let's convert it
            } else {
              statusText = response.state;
              success = response.data;
              error = response.error;
              isSuccess = !error;
            }
          } else {

            // Extract error from statusText and normalize for non-aborts
            error = statusText;
            if (status || !statusText) {
              statusText = "error";
              if (status < 0) {
                status = 0;
              }
            }
          }

          // Set data for the fake xhr object
          jqXHR.status = status;
          jqXHR.statusText = (nativeStatusText || statusText) + "";

          // Success/Error
          if (isSuccess) {
            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
          } else {
            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
          }

          // Status-dependent callbacks
          jqXHR.statusCode(statusCode);
          statusCode = undefined;

          if (fireGlobals) {
            globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError",
              [jqXHR, s, isSuccess ? success : error]);
          }

          // Complete
          completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

          if (fireGlobals) {
            globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

            // Handle the global AJAX counter
            if (!(--jQuery.active)) {
              jQuery.event.trigger("ajaxStop");
            }
          }
        }

        return jqXHR;
      },

      getJSON: function (url, data, callback) {
        return jQuery.get(url, data, callback, "json");
      },

      getScript: function (url, callback) {
        return jQuery.get(url, undefined, callback, "script");
      }
    });

    jQuery.each(["get", "post"], function (_i, method) {
      jQuery[method] = function (url, data, callback, type) {

        // Shift arguments if data argument was omitted
        if (isFunction(data)) {
          type = type || callback;
          callback = data;
          data = undefined;
        }

        // The url can be an options object (which then must have .url)
        return jQuery.ajax(jQuery.extend({
          url: url,
          type: method,
          dataType: type,
          data: data,
          success: callback
        }, jQuery.isPlainObject(url) && url));
      };
    });

    jQuery.ajaxPrefilter(function (s) {
      var i;
      for (i in s.headers) {
        if (i.toLowerCase() === "content-type") {
          s.contentType = s.headers[i] || "";
        }
      }
    });


    jQuery._evalUrl = function (url, options, doc) {
      return jQuery.ajax({
        url: url,

        // Make this explicit, since user can override this through ajaxSetup (trac-11264)
        type: "GET",
        dataType: "script",
        cache: true,
        async: false,
        global: false,

        // Only evaluate the response if it is successful (gh-4126)
        // dataFilter is not invoked for failure responses, so using it instead
        // of the default converter is kludgy but it works.
        converters: {
          "text script": function () { }
        },
        dataFilter: function (response) {
          jQuery.globalEval(response, options, doc);
        }
      });
    };


    jQuery.fn.extend({
      wrapAll: function (html) {
        var wrap;

        if (this[0]) {
          if (isFunction(html)) {
            html = html.call(this[0]);
          }

          // The elements to wrap the target around
          wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

          if (this[0].parentNode) {
            wrap.insertBefore(this[0]);
          }

          wrap.map(function () {
            var elem = this;

            while (elem.firstElementChild) {
              elem = elem.firstElementChild;
            }

            return elem;
          }).append(this);
        }

        return this;
      },

      wrapInner: function (html) {
        if (isFunction(html)) {
          return this.each(function (i) {
            jQuery(this).wrapInner(html.call(this, i));
          });
        }

        return this.each(function () {
          var self = jQuery(this),
            contents = self.contents();

          if (contents.length) {
            contents.wrapAll(html);

          } else {
            self.append(html);
          }
        });
      },

      wrap: function (html) {
        var htmlIsFunction = isFunction(html);

        return this.each(function (i) {
          jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
        });
      },

      unwrap: function (selector) {
        this.parent(selector).not("body").each(function () {
          jQuery(this).replaceWith(this.childNodes);
        });
        return this;
      }
    });


    jQuery.expr.pseudos.hidden = function (elem) {
      return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function (elem) {
      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };




    jQuery.ajaxSettings.xhr = function () {
      try {
        return new window.XMLHttpRequest();
      } catch (e) { }
    };

    var xhrSuccessStatus = {

      // File protocol always yields status code 0, assume 200
      0: 200,

      // Support: IE <=9 only
      // trac-1450: sometimes IE returns 1223 when it should be 204
      1223: 204
    },
      xhrSupported = jQuery.ajaxSettings.xhr();

    support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
    support.ajax = xhrSupported = !!xhrSupported;

    jQuery.ajaxTransport(function (options) {
      var callback, errorCallback;

      // Cross domain only allowed if supported through XMLHttpRequest
      if (support.cors || xhrSupported && !options.crossDomain) {
        return {
          send: function (headers, complete) {
            var i,
              xhr = options.xhr();

            xhr.open(
              options.type,
              options.url,
              options.async,
              options.username,
              options.password
            );

            // Apply custom fields if provided
            if (options.xhrFields) {
              for (i in options.xhrFields) {
                xhr[i] = options.xhrFields[i];
              }
            }

            // Override mime type if needed
            if (options.mimeType && xhr.overrideMimeType) {
              xhr.overrideMimeType(options.mimeType);
            }

            // X-Requested-With header
            // For cross-domain requests, seeing as conditions for a preflight are
            // akin to a jigsaw puzzle, we simply never set it to be sure.
            // (it can always be set on a per-request basis or even using ajaxSetup)
            // For same-domain requests, won't change header if already provided.
            if (!options.crossDomain && !headers["X-Requested-With"]) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            }

            // Set headers
            for (i in headers) {
              xhr.setRequestHeader(i, headers[i]);
            }

            // Callback
            callback = function (type) {
              return function () {
                if (callback) {
                  callback = errorCallback = xhr.onload =
                    xhr.onerror = xhr.onabort = xhr.ontimeout =
                    xhr.onreadystatechange = null;

                  if (type === "abort") {
                    xhr.abort();
                  } else if (type === "error") {

                    // Support: IE <=9 only
                    // On a manual native abort, IE9 throws
                    // errors on any property access that is not readyState
                    if (typeof xhr.status !== "number") {
                      complete(0, "error");
                    } else {
                      complete(

                        // File: protocol always yields status 0; see trac-8605, trac-14207
                        xhr.status,
                        xhr.statusText
                      );
                    }
                  } else {
                    complete(
                      xhrSuccessStatus[xhr.status] || xhr.status,
                      xhr.statusText,

                      // Support: IE <=9 only
                      // IE9 has no XHR2 but throws on binary (trac-11426)
                      // For XHR2 non-text, let the caller handle it (gh-2498)
                      (xhr.responseType || "text") !== "text" ||
                        typeof xhr.responseText !== "string" ?
                        { binary: xhr.response } :
                        { text: xhr.responseText },
                      xhr.getAllResponseHeaders()
                    );
                  }
                }
              };
            };

            // Listen to events
            xhr.onload = callback();
            errorCallback = xhr.onerror = xhr.ontimeout = callback("error");

            // Support: IE 9 only
            // Use onreadystatechange to replace onabort
            // to handle uncaught aborts
            if (xhr.onabort !== undefined) {
              xhr.onabort = errorCallback;
            } else {
              xhr.onreadystatechange = function () {

                // Check readyState before timeout as it changes
                if (xhr.readyState === 4) {

                  // Allow onerror to be called first,
                  // but that will not handle a native abort
                  // Also, save errorCallback to a variable
                  // as xhr.onerror cannot be accessed
                  window.setTimeout(function () {
                    if (callback) {
                      errorCallback();
                    }
                  });
                }
              };
            }

            // Create the abort callback
            callback = callback("abort");

            try {

              // Do send the request (this may raise an exception)
              xhr.send(options.hasContent && options.data || null);
            } catch (e) {

              // trac-14683: Only rethrow if this hasn't been notified as an error yet
              if (callback) {
                throw e;
              }
            }
          },

          abort: function () {
            if (callback) {
              callback();
            }
          }
        };
      }
    });




    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
    jQuery.ajaxPrefilter(function (s) {
      if (s.crossDomain) {
        s.contents.script = false;
      }
    });

    // Install script dataType
    jQuery.ajaxSetup({
      accepts: {
        script: "text/javascript, application/javascript, " +
          "application/ecmascript, application/x-ecmascript"
      },
      contents: {
        script: /\b(?:java|ecma)script\b/
      },
      converters: {
        "text script": function (text) {
          jQuery.globalEval(text);
          return text;
        }
      }
    });

    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter("script", function (s) {
      if (s.cache === undefined) {
        s.cache = false;
      }
      if (s.crossDomain) {
        s.type = "GET";
      }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function (s) {

      // This transport only deals with cross domain or forced-by-attrs requests
      if (s.crossDomain || s.scriptAttrs) {
        var script, callback;
        return {
          send: function (_, complete) {
            script = jQuery("<script>")
              .attr(s.scriptAttrs || {})
              .prop({ charset: s.scriptCharset, src: s.url })
              .on("load error", callback = function (evt) {
                script.remove();
                callback = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              });

            // Use native DOM manipulation to avoid our domManip AJAX trickery
            document.head.appendChild(script[0]);
          },
          abort: function () {
            if (callback) {
              callback();
            }
          }
        };
      }
    });




    var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;

    // Default jsonp settings
    jQuery.ajaxSetup({
      jsonp: "callback",
      jsonpCallback: function () {
        var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce.guid++));
        this[callback] = true;
        return callback;
      }
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

      var callbackName, overwritten, responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
          "url" :
          typeof s.data === "string" &&
          (s.contentType || "")
            .indexOf("application/x-www-form-urlencoded") === 0 &&
          rjsonp.test(s.data) && "data"
        );

      // Handle iff the expected data type is "jsonp" or we have a parameter to set
      if (jsonProp || s.dataTypes[0] === "jsonp") {

        // Get callback name, remembering preexisting value associated with it
        callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ?
          s.jsonpCallback() :
          s.jsonpCallback;

        // Insert callback into url or form data
        if (jsonProp) {
          s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
        } else if (s.jsonp !== false) {
          s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
        }

        // Use data converter to retrieve json after script execution
        s.converters["script json"] = function () {
          if (!responseContainer) {
            jQuery.error(callbackName + " was not called");
          }
          return responseContainer[0];
        };

        // Force json dataType
        s.dataTypes[0] = "json";

        // Install callback
        overwritten = window[callbackName];
        window[callbackName] = function () {
          responseContainer = arguments;
        };

        // Clean-up function (fires after converters)
        jqXHR.always(function () {

          // If previous value didn't exist - remove it
          if (overwritten === undefined) {
            jQuery(window).removeProp(callbackName);

            // Otherwise restore preexisting value
          } else {
            window[callbackName] = overwritten;
          }

          // Save back as free
          if (s[callbackName]) {

            // Make sure that re-using the options doesn't screw things around
            s.jsonpCallback = originalSettings.jsonpCallback;

            // Save the callback name for future use
            oldCallbacks.push(callbackName);
          }

          // Call if it was a function and we have a response
          if (responseContainer && isFunction(overwritten)) {
            overwritten(responseContainer[0]);
          }

          responseContainer = overwritten = undefined;
        });

        // Delegate to script
        return "script";
      }
    });




    // Support: Safari 8 only
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337
    support.createHTMLDocument = (function () {
      var body = document.implementation.createHTMLDocument("").body;
      body.innerHTML = "<form></form><form></form>";
      return body.childNodes.length === 2;
    })();


    // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function (data, context, keepScripts) {
      if (typeof data !== "string") {
        return [];
      }
      if (typeof context === "boolean") {
        keepScripts = context;
        context = false;
      }

      var base, parsed, scripts;

      if (!context) {

        // Stop scripts or inline event handlers from being executed immediately
        // by using document.implementation
        if (support.createHTMLDocument) {
          context = document.implementation.createHTMLDocument("");

          // Set the base href for the created document
          // so any parsed elements with URLs
          // are based on the document's URL (gh-2965)
          base = context.createElement("base");
          base.href = document.location.href;
          context.head.appendChild(base);
        } else {
          context = document;
        }
      }

      parsed = rsingleTag.exec(data);
      scripts = !keepScripts && [];

      // Single tag
      if (parsed) {
        return [context.createElement(parsed[1])];
      }

      parsed = buildFragment([data], context, scripts);

      if (scripts && scripts.length) {
        jQuery(scripts).remove();
      }

      return jQuery.merge([], parsed.childNodes);
    };


    /**
     * Load a url into a page
     */
    jQuery.fn.load = function (url, params, callback) {
      var selector, type, response,
        self = this,
        off = url.indexOf(" ");

      if (off > -1) {
        selector = stripAndCollapse(url.slice(off));
        url = url.slice(0, off);
      }

      // If it's a function
      if (isFunction(params)) {

        // We assume that it's the callback
        callback = params;
        params = undefined;

        // Otherwise, build a param string
      } else if (params && typeof params === "object") {
        type = "POST";
      }

      // If we have elements to modify, make the request
      if (self.length > 0) {
        jQuery.ajax({
          url: url,

          // If "type" variable is undefined, then "GET" method will be used.
          // Make value of this field explicit since
          // user can override it through ajaxSetup method
          type: type || "GET",
          dataType: "html",
          data: params
        }).done(function (responseText) {

          // Save response for use in complete callback
          response = arguments;

          self.html(selector ?

            // If a selector was specified, locate the right elements in a dummy div
            // Exclude scripts to avoid IE 'Permission Denied' errors
            jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

            // Otherwise use the full result
            responseText);

          // If the request succeeds, this function gets "data", "status", "jqXHR"
          // but they are ignored because response was set above.
          // If it fails, this function gets "jqXHR", "status", "error"
        }).always(callback && function (jqXHR, status) {
          self.each(function () {
            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
          });
        });
      }

      return this;
    };




    jQuery.expr.pseudos.animated = function (elem) {
      return jQuery.grep(jQuery.timers, function (fn) {
        return elem === fn.elem;
      }).length;
    };




    jQuery.offset = {
      setOffset: function (elem, options, i) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {};

        // Set position first, in-case top/left are set even on static elem
        if (position === "static") {
          elem.style.position = "relative";
        }

        curOffset = curElem.offset();
        curCSSTop = jQuery.css(elem, "top");
        curCSSLeft = jQuery.css(elem, "left");
        calculatePosition = (position === "absolute" || position === "fixed") &&
          (curCSSTop + curCSSLeft).indexOf("auto") > -1;

        // Need to be able to calculate position if either
        // top or left is auto and position is either absolute or fixed
        if (calculatePosition) {
          curPosition = curElem.position();
          curTop = curPosition.top;
          curLeft = curPosition.left;

        } else {
          curTop = parseFloat(curCSSTop) || 0;
          curLeft = parseFloat(curCSSLeft) || 0;
        }

        if (isFunction(options)) {

          // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
          options = options.call(elem, i, jQuery.extend({}, curOffset));
        }

        if (options.top != null) {
          props.top = (options.top - curOffset.top) + curTop;
        }
        if (options.left != null) {
          props.left = (options.left - curOffset.left) + curLeft;
        }

        if ("using" in options) {
          options.using.call(elem, props);

        } else {
          curElem.css(props);
        }
      }
    };

    jQuery.fn.extend({

      // offset() relates an element's border box to the document origin
      offset: function (options) {

        // Preserve chaining for setter
        if (arguments.length) {
          return options === undefined ?
            this :
            this.each(function (i) {
              jQuery.offset.setOffset(this, options, i);
            });
        }

        var rect, win,
          elem = this[0];

        if (!elem) {
          return;
        }

        // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
        // Support: IE <=11 only
        // Running getBoundingClientRect on a
        // disconnected node in IE throws an error
        if (!elem.getClientRects().length) {
          return { top: 0, left: 0 };
        }

        // Get document-relative position by adding viewport scroll to viewport-relative gBCR
        rect = elem.getBoundingClientRect();
        win = elem.ownerDocument.defaultView;
        return {
          top: rect.top + win.pageYOffset,
          left: rect.left + win.pageXOffset
        };
      },

      // position() relates an element's margin box to its offset parent's padding box
      // This corresponds to the behavior of CSS absolute positioning
      position: function () {
        if (!this[0]) {
          return;
        }

        var offsetParent, offset, doc,
          elem = this[0],
          parentOffset = { top: 0, left: 0 };

        // position:fixed elements are offset from the viewport, which itself always has zero offset
        if (jQuery.css(elem, "position") === "fixed") {

          // Assume position:fixed implies availability of getBoundingClientRect
          offset = elem.getBoundingClientRect();

        } else {
          offset = this.offset();

          // Account for the *real* offset parent, which can be the document or its root element
          // when a statically positioned element is identified
          doc = elem.ownerDocument;
          offsetParent = elem.offsetParent || doc.documentElement;
          while (offsetParent &&
            (offsetParent === doc.body || offsetParent === doc.documentElement) &&
            jQuery.css(offsetParent, "position") === "static") {

            offsetParent = offsetParent.parentNode;
          }
          if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {

            // Incorporate borders into its offset, since they are outside its content origin
            parentOffset = jQuery(offsetParent).offset();
            parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
            parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
          }
        }

        // Subtract parent offsets and element margins
        return {
          top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
          left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
        };
      },

      // This method will return documentElement in the following cases:
      // 1) For the element inside the iframe without offsetParent, this method will return
      //    documentElement of the parent window
      // 2) For the hidden or detached element
      // 3) For body or html element, i.e. in case of the html node - it will return itself
      //
      // but those exceptions were never presented as a real life use-cases
      // and might be considered as more preferable results.
      //
      // This logic, however, is not guaranteed and can change at any point in the future
      offsetParent: function () {
        return this.map(function () {
          var offsetParent = this.offsetParent;

          while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.offsetParent;
          }

          return offsetParent || documentElement;
        });
      }
    });

    // Create scrollLeft and scrollTop methods
    jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
      var top = "pageYOffset" === prop;

      jQuery.fn[method] = function (val) {
        return access(this, function (elem, method, val) {

          // Coalesce documents and windows
          var win;
          if (isWindow(elem)) {
            win = elem;
          } else if (elem.nodeType === 9) {
            win = elem.defaultView;
          }

          if (val === undefined) {
            return win ? win[prop] : elem[method];
          }

          if (win) {
            win.scrollTo(
              !top ? val : win.pageXOffset,
              top ? val : win.pageYOffset
            );

          } else {
            elem[method] = val;
          }
        }, method, val, arguments.length);
      };
    });

    // Support: Safari <=7 - 9.1, Chrome <=37 - 49
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each(["top", "left"], function (_i, prop) {
      jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
        function (elem, computed) {
          if (computed) {
            computed = curCSS(elem, prop);

            // If curCSS returns percentage, fallback to offset
            return rnumnonpx.test(computed) ?
              jQuery(elem).position()[prop] + "px" :
              computed;
          }
        }
      );
    });


    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
      jQuery.each({
        padding: "inner" + name,
        content: type,
        "": "outer" + name
      }, function (defaultExtra, funcName) {

        // Margin is only for outerHeight, outerWidth
        jQuery.fn[funcName] = function (margin, value) {
          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

          return access(this, function (elem, type, value) {
            var doc;

            if (isWindow(elem)) {

              // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
              return funcName.indexOf("outer") === 0 ?
                elem["inner" + name] :
                elem.document.documentElement["client" + name];
            }

            // Get document width or height
            if (elem.nodeType === 9) {
              doc = elem.documentElement;

              // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
              // whichever is greatest
              return Math.max(
                elem.body["scroll" + name], doc["scroll" + name],
                elem.body["offset" + name], doc["offset" + name],
                doc["client" + name]
              );
            }

            return value === undefined ?

              // Get width or height on the element, requesting but not forcing parseFloat
              jQuery.css(elem, type, extra) :

              // Set width or height on the element
              jQuery.style(elem, type, value, extra);
          }, type, chainable ? margin : undefined, chainable);
        };
      });
    });


    jQuery.each([
      "ajaxStart",
      "ajaxStop",
      "ajaxComplete",
      "ajaxError",
      "ajaxSuccess",
      "ajaxSend"
    ], function (_i, type) {
      jQuery.fn[type] = function (fn) {
        return this.on(type, fn);
      };
    });




    jQuery.fn.extend({

      bind: function (types, data, fn) {
        return this.on(types, null, data, fn);
      },
      unbind: function (types, fn) {
        return this.off(types, null, fn);
      },

      delegate: function (selector, types, data, fn) {
        return this.on(types, selector, data, fn);
      },
      undelegate: function (selector, types, fn) {

        // ( namespace ) or ( selector, types [, fn] )
        return arguments.length === 1 ?
          this.off(selector, "**") :
          this.off(types, selector || "**", fn);
      },

      hover: function (fnOver, fnOut) {
        return this
          .on("mouseenter", fnOver)
          .on("mouseleave", fnOut || fnOver);
      }
    });

    jQuery.each(
      ("blur focus focusin focusout resize scroll click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup contextmenu").split(" "),
      function (_i, name) {

        // Handle event binding
        jQuery.fn[name] = function (data, fn) {
          return arguments.length > 0 ?
            this.on(name, null, data, fn) :
            this.trigger(name);
        };
      }
    );




    // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP
    // Require that the "whitespace run" starts from a non-whitespace
    // to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
    var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

    // Bind a function to a context, optionally partially applying any
    // arguments.
    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
    // However, it is not slated for removal any time soon
    jQuery.proxy = function (fn, context) {
      var tmp, args, proxy;

      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }

      // Quick check to determine if target is callable, in the spec
      // this throws a TypeError, but we will just return undefined.
      if (!isFunction(fn)) {
        return undefined;
      }

      // Simulated bind
      args = slice.call(arguments, 2);
      proxy = function () {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };

      // Set the guid of unique handler to the same of original handler, so it can be removed
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;

      return proxy;
    };

    jQuery.holdReady = function (hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;

    jQuery.now = Date.now;

    jQuery.isNumeric = function (obj) {

      // As of jQuery 3.0, isNumeric is limited to
      // strings and numbers (primitives or objects)
      // that can be coerced to finite numbers (gh-2662)
      var type = jQuery.type(obj);
      return (type === "number" || type === "string") &&

        // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
    };

    jQuery.trim = function (text) {
      return text == null ?
        "" :
        (text + "").replace(rtrim, "$1");
    };



    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.

    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if (typeof define === "function" && define.amd) {
      define("jquery", [], function () {
        return jQuery;
      });
    }




    var

      // Map over jQuery in case of overwrite
      _jQuery = window.jQuery,

      // Map over the $ in case of overwrite
      _$ = window.$;

    jQuery.noConflict = function (deep) {
      if (window.$ === jQuery) {
        window.$ = _$;
      }

      if (deep && window.jQuery === jQuery) {
        window.jQuery = _jQuery;
      }

      return jQuery;
    };

    // Expose jQuery and $ identifiers, even in AMD
    // (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (trac-13566)
    if (typeof noGlobal === "undefined") {
      window.jQuery = window.$ = jQuery;
    }




    return jQuery;
  });
})();
;/*!
 * fancyBox - jQuery Plugin
 * version: 2.1.5 (Fri, 14 Jun 2013)
 * requires jQuery v1.6 or later
 *
 * Examples at http://fancyapps.com/fancybox/
 * License: www.fancyapps.com/fancybox/#license
 *
 * Copyright 2012 Janis Skarnelis - janis@fancyapps.com
 *
 */
(function () {
  (function (window, document, $, undefined) {
    "use strict";

    var H = $("html"),
      W = $(window),
      D = $(document),
      F = $.fancybox = function () {
        F.open.apply(this, arguments);
      },
      IE = navigator.userAgent.match(/msie/i),
      didUpdate = null,
      isTouch = document.createTouch !== undefined,

      isQuery = function (obj) {
        return obj && obj.hasOwnProperty && obj instanceof $;
      },
      isString = function (str) {
        return str && $.type(str) === "string";
      },
      isPercentage = function (str) {
        return isString(str) && str.indexOf('%') > 0;
      },
      isScrollable = function (el) {
        return (el && !(el.style.overflow && el.style.overflow === 'hidden') && ((el.clientWidth && el.scrollWidth > el.clientWidth) || (el.clientHeight && el.scrollHeight > el.clientHeight)));
      },
      getScalar = function (orig, dim) {
        var value = parseInt(orig, 10) || 0;

        if (dim && isPercentage(orig)) {
          value = F.getViewport()[dim] / 100 * value;
        }

        return Math.ceil(value);
      },
      getValue = function (value, dim) {
        return getScalar(value, dim) + 'px';
      };

    $.extend(F, {
      // The current version of fancyBox
      version: '2.1.5',

      defaults: {
        padding: 15,
        margin: 20,

        width: 800,
        height: 600,
        minWidth: 100,
        minHeight: 100,
        maxWidth: 9999,
        maxHeight: 9999,
        pixelRatio: 1, // Set to 2 for retina display support

        autoSize: true,
        autoHeight: false,
        autoWidth: false,

        autoResize: true,
        autoCenter: !isTouch,
        fitToView: true,
        aspectRatio: false,
        topRatio: 0.5,
        leftRatio: 0.5,

        scrolling: 'auto', // 'auto', 'yes' or 'no'
        wrapCSS: '',

        arrows: true,
        closeBtn: true,
        closeClick: false,
        nextClick: false,
        mouseWheel: true,
        autoPlay: false,
        playSpeed: 3000,
        preload: 3,
        modal: false,
        loop: true,

        ajax: {
          dataType: 'html',
          headers: { 'X-fancyBox': true }
        },
        iframe: {
          scrolling: 'auto',
          preload: true
        },
        swf: {
          wmode: 'transparent',
          allowfullscreen: 'true',
          allowscriptaccess: 'always'
        },

        keys: {
          next: {
            13: 'left', // enter
            34: 'up',   // page down
            39: 'left', // right arrow
            40: 'up'    // down arrow
          },
          prev: {
            8: 'right',  // backspace
            33: 'down',   // page up
            37: 'right',  // left arrow
            38: 'down'    // up arrow
          },
          close: [27], // escape key
          play: [32], // space - start/stop slideshow
          toggle: [70]  // letter "f" - toggle fullscreen
        },

        direction: {
          next: 'left',
          prev: 'right'
        },

        scrollOutside: true,

        // Override some properties
        index: 0,
        type: null,
        href: null,
        content: null,
        title: null,

        // HTML templates
        tpl: {
          wrap: '<div class="fancybox-wrap" tabIndex="-1"><div class="fancybox-skin"><div class="fancybox-outer"><div class="fancybox-inner"></div></div></div></div>',
          image: '<img class="fancybox-image" src="{href}" alt="" />',
          iframe: '<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" frameborder="0" vspace="0" hspace="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen' + (IE ? ' allowtransparency="true"' : '') + '></iframe>',
          error: '<p class="fancybox-error">The requested content cannot be loaded.<br/>Please try again later.</p>',
          closeBtn: '<a title="Close" class="fancybox-item fancybox-close" href="javascript:;"></a>',
          next: '<a title="Next" class="fancybox-nav fancybox-next" href="javascript:;"><span></span></a>',
          prev: '<a title="Previous" class="fancybox-nav fancybox-prev" href="javascript:;"><span></span></a>',
          loading: '<div id="fancybox-loading"><div></div></div>'
        },

        // Properties for each animation type
        // Opening fancyBox
        openEffect: 'fade', // 'elastic', 'fade' or 'none'
        openSpeed: 250,
        openEasing: 'swing',
        openOpacity: true,
        openMethod: 'zoomIn',

        // Closing fancyBox
        closeEffect: 'fade', // 'elastic', 'fade' or 'none'
        closeSpeed: 250,
        closeEasing: 'swing',
        closeOpacity: true,
        closeMethod: 'zoomOut',

        // Changing next gallery item
        nextEffect: 'elastic', // 'elastic', 'fade' or 'none'
        nextSpeed: 250,
        nextEasing: 'swing',
        nextMethod: 'changeIn',

        // Changing previous gallery item
        prevEffect: 'elastic', // 'elastic', 'fade' or 'none'
        prevSpeed: 250,
        prevEasing: 'swing',
        prevMethod: 'changeOut',

        // Enable default helpers
        helpers: {
          overlay: true,
          title: true
        },

        // Callbacks
        onCancel: $.noop, // If canceling
        beforeLoad: $.noop, // Before loading
        afterLoad: $.noop, // After loading
        beforeShow: $.noop, // Before changing in current item
        afterShow: $.noop, // After opening
        beforeChange: $.noop, // Before changing gallery item
        beforeClose: $.noop, // Before closing
        afterClose: $.noop  // After closing
      },

      //Current state
      group: {}, // Selected group
      opts: {}, // Group options
      previous: null,  // Previous element
      coming: null,  // Element being loaded
      current: null,  // Currently loaded element
      isActive: false, // Is activated
      isOpen: false, // Is currently open
      isOpened: false, // Have been fully opened at least once

      wrap: null,
      skin: null,
      outer: null,
      inner: null,

      player: {
        timer: null,
        isActive: false
      },

      // Loaders
      ajaxLoad: null,
      imgPreload: null,

      // Some collections
      transitions: {},
      helpers: {},

      /*
       *	Static methods
       */

      open: function (group, opts) {
        if (!group) {
          return;
        }

        if (!$.isPlainObject(opts)) {
          opts = {};
        }

        // Close if already active
        if (false === F.close(true)) {
          return;
        }

        // Normalize group
        if (!$.isArray(group)) {
          group = isQuery(group) ? $(group).get() : [group];
        }

        // Recheck if the type of each element is `object` and set content type (image, ajax, etc)
        $.each(group, function (i, element) {
          var obj = {},
            href,
            title,
            content,
            type,
            rez,
            hrefParts,
            selector;

          if ($.type(element) === "object") {
            // Check if is DOM element
            if (element.nodeType) {
              element = $(element);
            }

            if (isQuery(element)) {
              obj = {
                href: element.data('fancybox-href') || element.attr('href'),
                title: $('<div/>').text(element.data('fancybox-title') || element.attr('title') || '').html(),
                isDom: true,
                element: element
              };

              if ($.metadata) {
                $.extend(true, obj, element.metadata());
              }

            } else {
              obj = element;
            }
          }

          href = opts.href || obj.href || (isString(element) ? element : null);
          title = opts.title !== undefined ? opts.title : obj.title || '';

          content = opts.content || obj.content;
          type = content ? 'html' : (opts.type || obj.type);

          if (!type && obj.isDom) {
            type = element.data('fancybox-type');

            if (!type) {
              rez = element.prop('class').match(/fancybox\.(\w+)/);
              type = rez ? rez[1] : null;
            }
          }

          if (isString(href)) {
            // Try to guess the content type
            if (!type) {
              if (F.isImage(href)) {
                type = 'image';

              } else if (F.isSWF(href)) {
                type = 'swf';

              } else if (href.charAt(0) === '#') {
                type = 'inline';

              } else if (isString(element)) {
                type = 'html';
                content = element;
              }
            }

            // Split url into two pieces with source url and content selector, e.g,
            // "/mypage.html #my_id" will load "/mypage.html" and display element having id "my_id"
            if (type === 'ajax') {
              hrefParts = href.split(/\s+/, 2);
              href = hrefParts.shift();
              selector = hrefParts.shift();
            }
          }

          if (!content) {
            if (type === 'inline') {
              if (href) {
                content = $(isString(href) ? href.replace(/.*(?=#[^\s]+$)/, '') : href); //strip for ie7

              } else if (obj.isDom) {
                content = element;
              }

            } else if (type === 'html') {
              content = href;

            } else if (!type && !href && obj.isDom) {
              type = 'inline';
              content = element;
            }
          }

          $.extend(obj, {
            href: href,
            type: type,
            content: content,
            title: title,
            selector: selector
          });

          group[i] = obj;
        });

        // Extend the defaults
        F.opts = $.extend(true, {}, F.defaults, opts);

        // All options are merged recursive except keys
        if (opts.keys !== undefined) {
          F.opts.keys = opts.keys ? $.extend({}, F.defaults.keys, opts.keys) : false;
        }

        F.group = group;

        return F._start(F.opts.index);
      },

      // Cancel image loading or abort ajax request
      cancel: function () {
        var coming = F.coming;

        if (coming && false === F.trigger('onCancel')) {
          return;
        }

        F.hideLoading();

        if (!coming) {
          return;
        }

        if (F.ajaxLoad) {
          F.ajaxLoad.abort();
        }

        F.ajaxLoad = null;

        if (F.imgPreload) {
          F.imgPreload.onload = F.imgPreload.onerror = null;
        }

        if (coming.wrap) {
          coming.wrap.stop(true, true).trigger('onReset').remove();
        }

        F.coming = null;

        // If the first item has been canceled, then clear everything
        if (!F.current) {
          F._afterZoomOut(coming);
        }
      },

      // Start closing animation if is open; remove immediately if opening/closing
      close: function (event) {
        F.cancel();

        if (false === F.trigger('beforeClose')) {
          return;
        }

        F.unbindEvents();

        if (!F.isActive) {
          return;
        }

        if (!F.isOpen || event === true) {
          $('.fancybox-wrap').stop(true).trigger('onReset').remove();

          F._afterZoomOut();

        } else {
          F.isOpen = F.isOpened = false;
          F.isClosing = true;

          $('.fancybox-item, .fancybox-nav').remove();

          F.wrap.stop(true, true).removeClass('fancybox-opened');

          F.transitions[F.current.closeMethod]();
        }
      },

      // Manage slideshow:
      //   $.fancybox.play(); - toggle slideshow
      //   $.fancybox.play( true ); - start
      //   $.fancybox.play( false ); - stop
      play: function (action) {
        var clear = function () {
          clearTimeout(F.player.timer);
        },
          set = function () {
            clear();

            if (F.current && F.player.isActive) {
              F.player.timer = setTimeout(F.next, F.current.playSpeed);
            }
          },
          stop = function () {
            clear();

            D.unbind('.player');

            F.player.isActive = false;

            F.trigger('onPlayEnd');
          },
          start = function () {
            if (F.current && (F.current.loop || F.current.index < F.group.length - 1)) {
              F.player.isActive = true;

              D.bind({
                'onCancel.player beforeClose.player': stop,
                'onUpdate.player': set,
                'beforeLoad.player': clear
              });

              set();

              F.trigger('onPlayStart');
            }
          };

        if (action === true || (!F.player.isActive && action !== false)) {
          start();
        } else {
          stop();
        }
      },

      // Navigate to next gallery item
      next: function (direction) {
        var current = F.current;

        if (current) {
          if (!isString(direction)) {
            direction = current.direction.next;
          }

          F.jumpto(current.index + 1, direction, 'next');
        }
      },

      // Navigate to previous gallery item
      prev: function (direction) {
        var current = F.current;

        if (current) {
          if (!isString(direction)) {
            direction = current.direction.prev;
          }

          F.jumpto(current.index - 1, direction, 'prev');
        }
      },

      // Navigate to gallery item by index
      jumpto: function (index, direction, router) {
        var current = F.current;

        if (!current) {
          return;
        }

        index = getScalar(index);

        F.direction = direction || current.direction[(index >= current.index ? 'next' : 'prev')];
        F.router = router || 'jumpto';

        if (current.loop) {
          if (index < 0) {
            index = current.group.length + (index % current.group.length);
          }

          index = index % current.group.length;
        }

        if (current.group[index] !== undefined) {
          F.cancel();

          F._start(index);
        }
      },

      // Center inside viewport and toggle position type to fixed or absolute if needed
      reposition: function (e, onlyAbsolute) {
        var current = F.current,
          wrap = current ? current.wrap : null,
          pos;

        if (wrap) {
          pos = F._getPosition(onlyAbsolute);

          if (e && e.type === 'scroll') {
            delete pos.position;

            wrap.stop(true, true).animate(pos, 200);

          } else {
            wrap.css(pos);

            current.pos = $.extend({}, current.dim, pos);
          }
        }
      },

      update: function (e) {
        var type = (e && e.originalEvent && e.originalEvent.type),
          anyway = !type || type === 'orientationchange';

        if (anyway) {
          clearTimeout(didUpdate);

          didUpdate = null;
        }

        if (!F.isOpen || didUpdate) {
          return;
        }

        didUpdate = setTimeout(function () {
          var current = F.current;

          if (!current || F.isClosing) {
            return;
          }

          F.wrap.removeClass('fancybox-tmp');

          if (anyway || type === 'load' || (type === 'resize' && current.autoResize)) {
            F._setDimension();
          }

          if (!(type === 'scroll' && current.canShrink)) {
            F.reposition(e);
          }

          F.trigger('onUpdate');

          didUpdate = null;

        }, (anyway && !isTouch ? 0 : 300));
      },

      // Shrink content to fit inside viewport or restore if resized
      toggle: function (action) {
        if (F.isOpen) {
          F.current.fitToView = $.type(action) === "boolean" ? action : !F.current.fitToView;

          // Help browser to restore document dimensions
          if (isTouch) {
            F.wrap.removeAttr('style').addClass('fancybox-tmp');

            F.trigger('onUpdate');
          }

          F.update();
        }
      },

      hideLoading: function () {
        D.unbind('.loading');

        $('#fancybox-loading').remove();
      },

      showLoading: function () {
        var el, viewport;

        F.hideLoading();

        el = $(F.opts.tpl.loading).click(F.cancel).appendTo('body');

        // If user will press the escape-button, the request will be canceled
        D.bind('keydown.loading', function (e) {
          if ((e.which || e.keyCode) === 27) {
            e.preventDefault();

            F.cancel();
          }
        });

        if (!F.defaults.fixed) {
          viewport = F.getViewport();

          el.css({
            position: 'absolute',
            top: (viewport.h * 0.5) + viewport.y,
            left: (viewport.w * 0.5) + viewport.x
          });
        }

        F.trigger('onLoading');
      },

      getViewport: function () {
        var locked = (F.current && F.current.locked) || false,
          rez = {
            x: W.scrollLeft(),
            y: W.scrollTop()
          };

        if (locked && locked.length) {
          rez.w = locked[0].clientWidth;
          rez.h = locked[0].clientHeight;

        } else {
          // See http://bugs.jquery.com/ticket/6724
          rez.w = isTouch && window.innerWidth ? window.innerWidth : W.width();
          rez.h = isTouch && window.innerHeight ? window.innerHeight : W.height();
        }

        return rez;
      },

      // Unbind the keyboard / clicking actions
      unbindEvents: function () {
        if (F.wrap && isQuery(F.wrap)) {
          F.wrap.unbind('.fb');
        }

        D.unbind('.fb');
        W.unbind('.fb');
      },

      bindEvents: function () {
        var current = F.current,
          keys;

        if (!current) {
          return;
        }

        // Changing document height on iOS devices triggers a 'resize' event,
        // that can change document height... repeating infinitely
        W.bind('orientationchange.fb' + (isTouch ? '' : ' resize.fb') + (current.autoCenter && !current.locked ? ' scroll.fb' : ''), F.update);

        keys = current.keys;

        if (keys) {
          D.bind('keydown.fb', function (e) {
            var code = e.which || e.keyCode,
              target = e.target || e.srcElement;

            // Skip esc key if loading, because showLoading will cancel preloading
            if (code === 27 && F.coming) {
              return false;
            }

            // Ignore key combinations and key events within form elements
            if (!e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey && !(target && (target.type || $(target).is('[contenteditable]')))) {
              $.each(keys, function (i, val) {
                if (current.group.length > 1 && val[code] !== undefined) {
                  F[i](val[code]);

                  e.preventDefault();
                  return false;
                }

                if ($.inArray(code, val) > -1) {
                  F[i]();

                  e.preventDefault();
                  return false;
                }
              });
            }
          });
        }

        if ($.fn.mousewheel && current.mouseWheel) {
          F.wrap.bind('mousewheel.fb', function (e, delta, deltaX, deltaY) {
            var target = e.target || null,
              parent = $(target),
              canScroll = false;

            while (parent.length) {
              if (canScroll || parent.is('.fancybox-skin') || parent.is('.fancybox-wrap')) {
                break;
              }

              canScroll = isScrollable(parent[0]);
              parent = $(parent).parent();
            }

            if (delta !== 0 && !canScroll) {
              if (F.group.length > 1 && !current.canShrink) {
                if (deltaY > 0 || deltaX > 0) {
                  F.prev(deltaY > 0 ? 'down' : 'left');

                } else if (deltaY < 0 || deltaX < 0) {
                  F.next(deltaY < 0 ? 'up' : 'right');
                }

                e.preventDefault();
              }
            }
          });
        }
      },

      trigger: function (event, o) {
        var ret, obj = o || F.coming || F.current;

        if (obj) {
          if ($.isFunction(obj[event])) {
            ret = obj[event].apply(obj, Array.prototype.slice.call(arguments, 1));
          }

          if (ret === false) {
            return false;
          }

          if (obj.helpers) {
            $.each(obj.helpers, function (helper, opts) {
              if (opts && F.helpers[helper] && $.isFunction(F.helpers[helper][event])) {
                F.helpers[helper][event]($.extend(true, {}, F.helpers[helper].defaults, opts), obj);
              }
            });
          }
        }

        D.trigger(event);
      },

      isImage: function (str) {
        return isString(str) && str.match(/(^data:image\/.*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg)((\?|#).*)?$)/i);
      },

      isSWF: function (str) {
        return isString(str) && str.match(/\.(swf)((\?|#).*)?$/i);
      },

      _start: function (index) {
        var coming = {},
          obj,
          href,
          type,
          margin,
          padding;

        index = getScalar(index);
        obj = F.group[index] || null;

        if (!obj) {
          return false;
        }

        coming = $.extend(true, {}, F.opts, obj);

        // Convert margin and padding properties to array - top, right, bottom, left
        margin = coming.margin;
        padding = coming.padding;

        if ($.type(margin) === 'number') {
          coming.margin = [margin, margin, margin, margin];
        }

        if ($.type(padding) === 'number') {
          coming.padding = [padding, padding, padding, padding];
        }

        // 'modal' propery is just a shortcut
        if (coming.modal) {
          $.extend(true, coming, {
            closeBtn: false,
            closeClick: false,
            nextClick: false,
            arrows: false,
            mouseWheel: false,
            keys: null,
            helpers: {
              overlay: {
                closeClick: false
              }
            }
          });
        }

        // 'autoSize' property is a shortcut, too
        if (coming.autoSize) {
          coming.autoWidth = coming.autoHeight = true;
        }

        if (coming.width === 'auto') {
          coming.autoWidth = true;
        }

        if (coming.height === 'auto') {
          coming.autoHeight = true;
        }

        /*
         * Add reference to the group, so it`s possible to access from callbacks, example:
         * afterLoad : function() {
         *     this.title = 'Image ' + (this.index + 1) + ' of ' + this.group.length + (this.title ? ' - ' + this.title : '');
         * }
         */

        coming.group = F.group;
        coming.index = index;

        // Give a chance for callback or helpers to update coming item (type, title, etc)
        F.coming = coming;

        if (false === F.trigger('beforeLoad')) {
          F.coming = null;

          return;
        }

        type = coming.type;
        href = coming.href;

        if (!type) {
          F.coming = null;

          //If we can not determine content type then drop silently or display next/prev item if looping through gallery
          if (F.current && F.router && F.router !== 'jumpto') {
            F.current.index = index;

            return F[F.router](F.direction);
          }

          return false;
        }

        F.isActive = true;

        if (type === 'image' || type === 'swf') {
          coming.autoHeight = coming.autoWidth = false;
          coming.scrolling = 'visible';
        }

        if (type === 'image') {
          coming.aspectRatio = true;
        }

        if (type === 'iframe' && isTouch) {
          coming.scrolling = 'scroll';
        }

        // Build the neccessary markup
        coming.wrap = $(coming.tpl.wrap).addClass('fancybox-' + (isTouch ? 'mobile' : 'desktop') + ' fancybox-type-' + type + ' fancybox-tmp ' + coming.wrapCSS).appendTo(coming.parent || 'body');

        $.extend(coming, {
          skin: $('.fancybox-skin', coming.wrap),
          outer: $('.fancybox-outer', coming.wrap),
          inner: $('.fancybox-inner', coming.wrap)
        });

        $.each(["Top", "Right", "Bottom", "Left"], function (i, v) {
          coming.skin.css('padding' + v, getValue(coming.padding[i]));
        });

        F.trigger('onReady');

        // Check before try to load; 'inline' and 'html' types need content, others - href
        if (type === 'inline' || type === 'html') {
          if (!coming.content || !coming.content.length) {
            return F._error('content');
          }

        } else if (!href) {
          return F._error('href');
        }

        if (type === 'image') {
          F._loadImage();

        } else if (type === 'ajax') {
          F._loadAjax();

        } else if (type === 'iframe') {
          F._loadIframe();

        } else {
          F._afterLoad();
        }
      },

      _error: function (type) {
        $.extend(F.coming, {
          type: 'html',
          autoWidth: true,
          autoHeight: true,
          minWidth: 0,
          minHeight: 0,
          scrolling: 'no',
          hasError: type,
          content: F.coming.tpl.error
        });

        F._afterLoad();
      },

      _loadImage: function () {
        // Reset preload image so it is later possible to check "complete" property
        var img = F.imgPreload = new Image();

        img.onload = function () {
          this.onload = this.onerror = null;

          F.coming.width = this.width / F.opts.pixelRatio;
          F.coming.height = this.height / F.opts.pixelRatio;

          F._afterLoad();
        };

        img.onerror = function () {
          this.onload = this.onerror = null;

          F._error('image');
        };

        img.src = F.coming.href;

        if (img.complete !== true) {
          F.showLoading();
        }
      },

      _loadAjax: function () {
        var coming = F.coming;

        F.showLoading();

        F.ajaxLoad = $.ajax($.extend({}, coming.ajax, {
          url: coming.href,
          error: function (jqXHR, textStatus) {
            if (F.coming && textStatus !== 'abort') {
              F._error('ajax', jqXHR);

            } else {
              F.hideLoading();
            }
          },
          success: function (data, textStatus) {
            if (textStatus === 'success') {
              coming.content = data;

              F._afterLoad();
            }
          }
        }));
      },

      _loadIframe: function () {
        var coming = F.coming,
          iframe = $(coming.tpl.iframe.replace(/\{rnd\}/g, new Date().getTime()))
            .attr('scrolling', isTouch ? 'auto' : coming.iframe.scrolling)
            .attr('src', coming.href);

        // This helps IE
        $(coming.wrap).bind('onReset', function () {
          try {
            $(this).find('iframe').hide().attr('src', '//about:blank').end().empty();
          } catch (e) { }
        });

        if (coming.iframe.preload) {
          F.showLoading();

          iframe.one('load', function () {
            $(this).data('ready', 1);

            // iOS will lose scrolling if we resize
            if (!isTouch) {
              $(this).bind('load.fb', F.update);
            }

            // Without this trick:
            //   - iframe won't scroll on iOS devices
            //   - IE7 sometimes displays empty iframe
            $(this).parents('.fancybox-wrap').width('100%').removeClass('fancybox-tmp').show();

            F._afterLoad();
          });
        }

        coming.content = iframe.appendTo(coming.inner);

        if (!coming.iframe.preload) {
          F._afterLoad();
        }
      },

      _preloadImages: function () {
        var group = F.group,
          current = F.current,
          len = group.length,
          cnt = current.preload ? Math.min(current.preload, len - 1) : 0,
          item,
          i;

        for (i = 1; i <= cnt; i += 1) {
          item = group[(current.index + i) % len];

          if (item.type === 'image' && item.href) {
            new Image().src = item.href;
          }
        }
      },

      _afterLoad: function () {
        var coming = F.coming,
          previous = F.current,
          placeholder = 'fancybox-placeholder',
          current,
          content,
          type,
          scrolling,
          href,
          embed;

        F.hideLoading();

        if (!coming || F.isActive === false) {
          return;
        }

        if (false === F.trigger('afterLoad', coming, previous)) {
          coming.wrap.stop(true).trigger('onReset').remove();

          F.coming = null;

          return;
        }

        if (previous) {
          F.trigger('beforeChange', previous);

          previous.wrap.stop(true).removeClass('fancybox-opened')
            .find('.fancybox-item, .fancybox-nav')
            .remove();
        }

        F.unbindEvents();

        current = coming;
        content = coming.content;
        type = coming.type;
        scrolling = coming.scrolling;

        $.extend(F, {
          wrap: current.wrap,
          skin: current.skin,
          outer: current.outer,
          inner: current.inner,
          current: current,
          previous: previous
        });

        href = current.href;

        switch (type) {
          case 'inline':
          case 'ajax':
          case 'html':
            if (current.selector) {
              content = $('<div>').html(content).find(current.selector);

            } else if (isQuery(content)) {
              if (!content.data(placeholder)) {
                content.data(placeholder, $('<div class="' + placeholder + '"></div>').insertAfter(content).hide());
              }

              content = content.show().detach();

              current.wrap.bind('onReset', function () {
                if ($(this).find(content).length) {
                  content.hide().replaceAll(content.data(placeholder)).data(placeholder, false);
                }
              });
            }
            break;

          case 'image':
            content = current.tpl.image.replace(/\{href\}/g, href);
            break;

          case 'swf':
            content = '<object id="fancybox-swf" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="100%" height="100%"><param name="movie" value="' + href + '"></param>';
            embed = '';

            $.each(current.swf, function (name, val) {
              content += '<param name="' + name + '" value="' + val + '"></param>';
              embed += ' ' + name + '="' + val + '"';
            });

            content += '<embed src="' + href + '" type="application/x-shockwave-flash" width="100%" height="100%"' + embed + '></embed></object>';
            break;
        }

        if (!(isQuery(content) && content.parent().is(current.inner))) {
          current.inner.append(content);
        }

        // Give a chance for helpers or callbacks to update elements
        F.trigger('beforeShow');

        // Set scrolling before calculating dimensions
        current.inner.css('overflow', scrolling === 'yes' ? 'scroll' : (scrolling === 'no' ? 'hidden' : scrolling));

        // Set initial dimensions and start position
        F._setDimension();

        F.reposition();

        F.isOpen = false;
        F.coming = null;

        F.bindEvents();

        if (!F.isOpened) {
          $('.fancybox-wrap').not(current.wrap).stop(true).trigger('onReset').remove();

        } else if (previous.prevMethod) {
          F.transitions[previous.prevMethod]();
        }

        F.transitions[F.isOpened ? current.nextMethod : current.openMethod]();

        F._preloadImages();
      },

      _setDimension: function () {
        var viewport = F.getViewport(),
          steps = 0,
          canShrink = false,
          canExpand = false,
          wrap = F.wrap,
          skin = F.skin,
          inner = F.inner,
          current = F.current,
          width = current.width,
          height = current.height,
          minWidth = current.minWidth,
          minHeight = current.minHeight,
          maxWidth = current.maxWidth,
          maxHeight = current.maxHeight,
          scrolling = current.scrolling,
          scrollOut = current.scrollOutside ? current.scrollbarWidth : 0,
          margin = current.margin,
          wMargin = getScalar(margin[1] + margin[3]),
          hMargin = getScalar(margin[0] + margin[2]),
          wPadding,
          hPadding,
          wSpace,
          hSpace,
          origWidth,
          origHeight,
          origMaxWidth,
          origMaxHeight,
          ratio,
          width_,
          height_,
          maxWidth_,
          maxHeight_,
          iframe,
          body;

        // Reset dimensions so we could re-check actual size
        wrap.add(skin).add(inner).width('auto').height('auto').removeClass('fancybox-tmp');

        wPadding = getScalar(skin.outerWidth(true) - skin.width());
        hPadding = getScalar(skin.outerHeight(true) - skin.height());

        // Any space between content and viewport (margin, padding, border, title)
        wSpace = wMargin + wPadding;
        hSpace = hMargin + hPadding;

        origWidth = isPercentage(width) ? (viewport.w - wSpace) * getScalar(width) / 100 : width;
        origHeight = isPercentage(height) ? (viewport.h - hSpace) * getScalar(height) / 100 : height;

        if (current.type === 'iframe') {
          iframe = current.content;

          if (current.autoHeight && iframe.data('ready') === 1) {
            try {
              if (iframe[0].contentWindow.document.location) {
                inner.width(origWidth).height(9999);

                body = iframe.contents().find('body');

                if (scrollOut) {
                  body.css('overflow-x', 'hidden');
                }

                origHeight = body.outerHeight(true);
              }

            } catch (e) { }
          }

        } else if (current.autoWidth || current.autoHeight) {
          inner.addClass('fancybox-tmp');

          // Set width or height in case we need to calculate only one dimension
          if (!current.autoWidth) {
            inner.width(origWidth);
          }

          if (!current.autoHeight) {
            inner.height(origHeight);
          }

          if (current.autoWidth) {
            origWidth = inner.width();
          }

          if (current.autoHeight) {
            origHeight = inner.height();
          }

          inner.removeClass('fancybox-tmp');
        }

        width = getScalar(origWidth);
        height = getScalar(origHeight);

        ratio = origWidth / origHeight;

        // Calculations for the content
        minWidth = getScalar(isPercentage(minWidth) ? getScalar(minWidth, 'w') - wSpace : minWidth);
        maxWidth = getScalar(isPercentage(maxWidth) ? getScalar(maxWidth, 'w') - wSpace : maxWidth);

        minHeight = getScalar(isPercentage(minHeight) ? getScalar(minHeight, 'h') - hSpace : minHeight);
        maxHeight = getScalar(isPercentage(maxHeight) ? getScalar(maxHeight, 'h') - hSpace : maxHeight);

        // These will be used to determine if wrap can fit in the viewport
        origMaxWidth = maxWidth;
        origMaxHeight = maxHeight;

        if (current.fitToView) {
          maxWidth = Math.min(viewport.w - wSpace, maxWidth);
          maxHeight = Math.min(viewport.h - hSpace, maxHeight);
        }

        maxWidth_ = viewport.w - wMargin;
        maxHeight_ = viewport.h - hMargin;

        if (current.aspectRatio) {
          if (width > maxWidth) {
            width = maxWidth;
            height = getScalar(width / ratio);
          }

          if (height > maxHeight) {
            height = maxHeight;
            width = getScalar(height * ratio);
          }

          if (width < minWidth) {
            width = minWidth;
            height = getScalar(width / ratio);
          }

          if (height < minHeight) {
            height = minHeight;
            width = getScalar(height * ratio);
          }

        } else {
          width = Math.max(minWidth, Math.min(width, maxWidth));

          if (current.autoHeight && current.type !== 'iframe') {
            inner.width(width);

            height = inner.height();
          }

          height = Math.max(minHeight, Math.min(height, maxHeight));
        }

        // Try to fit inside viewport (including the title)
        if (current.fitToView) {
          inner.width(width).height(height);

          wrap.width(width + wPadding);

          // Real wrap dimensions
          width_ = wrap.width();
          height_ = wrap.height();

          if (current.aspectRatio) {
            while ((width_ > maxWidth_ || height_ > maxHeight_) && width > minWidth && height > minHeight) {
              if (steps++ > 19) {
                break;
              }

              height = Math.max(minHeight, Math.min(maxHeight, height - 10));
              width = getScalar(height * ratio);

              if (width < minWidth) {
                width = minWidth;
                height = getScalar(width / ratio);
              }

              if (width > maxWidth) {
                width = maxWidth;
                height = getScalar(width / ratio);
              }

              inner.width(width).height(height);

              wrap.width(width + wPadding);

              width_ = wrap.width();
              height_ = wrap.height();
            }

          } else {
            width = Math.max(minWidth, Math.min(width, width - (width_ - maxWidth_)));
            height = Math.max(minHeight, Math.min(height, height - (height_ - maxHeight_)));
          }
        }

        if (scrollOut && scrolling === 'auto' && height < origHeight && (width + wPadding + scrollOut) < maxWidth_) {
          width += scrollOut;
        }

        inner.width(width).height(height);

        wrap.width(width + wPadding);

        width_ = wrap.width();
        height_ = wrap.height();

        canShrink = (width_ > maxWidth_ || height_ > maxHeight_) && width > minWidth && height > minHeight;
        canExpand = current.aspectRatio ? (width < origMaxWidth && height < origMaxHeight && width < origWidth && height < origHeight) : ((width < origMaxWidth || height < origMaxHeight) && (width < origWidth || height < origHeight));

        $.extend(current, {
          dim: {
            width: getValue(width_),
            height: getValue(height_)
          },
          origWidth: origWidth,
          origHeight: origHeight,
          canShrink: canShrink,
          canExpand: canExpand,
          wPadding: wPadding,
          hPadding: hPadding,
          wrapSpace: height_ - skin.outerHeight(true),
          skinSpace: skin.height() - height
        });

        if (!iframe && current.autoHeight && height > minHeight && height < maxHeight && !canExpand) {
          inner.height('auto');
        }
      },

      _getPosition: function (onlyAbsolute) {
        var current = F.current,
          viewport = F.getViewport(),
          margin = current.margin,
          width = F.wrap.width() + margin[1] + margin[3],
          height = F.wrap.height() + margin[0] + margin[2],
          rez = {
            position: 'absolute',
            top: margin[0],
            left: margin[3]
          };

        if (current.autoCenter && current.fixed && !onlyAbsolute && height <= viewport.h && width <= viewport.w) {
          rez.position = 'fixed';

        } else if (!current.locked) {
          rez.top += viewport.y;
          rez.left += viewport.x;
        }

        rez.top = getValue(Math.max(rez.top, rez.top + ((viewport.h - height) * current.topRatio)));
        rez.left = getValue(Math.max(rez.left, rez.left + ((viewport.w - width) * current.leftRatio)));

        return rez;
      },

      _afterZoomIn: function () {
        var current = F.current;

        if (!current) {
          return;
        }

        F.isOpen = F.isOpened = true;

        F.wrap.css('overflow', 'visible').addClass('fancybox-opened').hide().show(0);

        F.update();

        // Assign a click event
        if (current.closeClick || (current.nextClick && F.group.length > 1)) {
          F.inner.css('cursor', 'pointer').bind('click.fb', function (e) {
            if (!$(e.target).is('a') && !$(e.target).parent().is('a')) {
              e.preventDefault();

              F[current.closeClick ? 'close' : 'next']();
            }
          });
        }

        // Create a close button
        if (current.closeBtn) {
          $(current.tpl.closeBtn).appendTo(F.skin).bind('click.fb', function (e) {
            e.preventDefault();

            F.close();
          });
        }

        // Create navigation arrows
        if (current.arrows && F.group.length > 1) {
          if (current.loop || current.index > 0) {
            $(current.tpl.prev).appendTo(F.outer).bind('click.fb', F.prev);
          }

          if (current.loop || current.index < F.group.length - 1) {
            $(current.tpl.next).appendTo(F.outer).bind('click.fb', F.next);
          }
        }

        F.trigger('afterShow');

        // Stop the slideshow if this is the last item
        if (!current.loop && current.index === current.group.length - 1) {

          F.play(false);

        } else if (F.opts.autoPlay && !F.player.isActive) {
          F.opts.autoPlay = false;

          F.play(true);
        }
      },

      _afterZoomOut: function (obj) {
        obj = obj || F.current;

        $('.fancybox-wrap').trigger('onReset').remove();

        $.extend(F, {
          group: {},
          opts: {},
          router: false,
          current: null,
          isActive: false,
          isOpened: false,
          isOpen: false,
          isClosing: false,
          wrap: null,
          skin: null,
          outer: null,
          inner: null
        });

        F.trigger('afterClose', obj);
      }
    });

    /*
     *	Default transitions
     */

    F.transitions = {
      getOrigPosition: function () {
        var current = F.current,
          element = current.element,
          orig = current.orig,
          pos = {},
          width = 50,
          height = 50,
          hPadding = current.hPadding,
          wPadding = current.wPadding,
          viewport = F.getViewport();

        if (!orig && current.isDom && element.is(':visible')) {
          orig = element.find('img:first');

          if (!orig.length) {
            orig = element;
          }
        }

        if (isQuery(orig)) {
          pos = orig.offset();

          if (orig.is('img')) {
            width = orig.outerWidth();
            height = orig.outerHeight();
          }

        } else {
          pos.top = viewport.y + (viewport.h - height) * current.topRatio;
          pos.left = viewport.x + (viewport.w - width) * current.leftRatio;
        }

        if (F.wrap.css('position') === 'fixed' || current.locked) {
          pos.top -= viewport.y;
          pos.left -= viewport.x;
        }

        pos = {
          top: getValue(pos.top - hPadding * current.topRatio),
          left: getValue(pos.left - wPadding * current.leftRatio),
          width: getValue(width + wPadding),
          height: getValue(height + hPadding)
        };

        return pos;
      },

      step: function (now, fx) {
        var ratio,
          padding,
          value,
          prop = fx.prop,
          current = F.current,
          wrapSpace = current.wrapSpace,
          skinSpace = current.skinSpace;

        if (prop === 'width' || prop === 'height') {
          ratio = fx.end === fx.start ? 1 : (now - fx.start) / (fx.end - fx.start);

          if (F.isClosing) {
            ratio = 1 - ratio;
          }

          padding = prop === 'width' ? current.wPadding : current.hPadding;
          value = now - padding;

          F.skin[prop](getScalar(prop === 'width' ? value : value - (wrapSpace * ratio)));
          F.inner[prop](getScalar(prop === 'width' ? value : value - (wrapSpace * ratio) - (skinSpace * ratio)));
        }
      },

      zoomIn: function () {
        var current = F.current,
          startPos = current.pos,
          effect = current.openEffect,
          elastic = effect === 'elastic',
          endPos = $.extend({ opacity: 1 }, startPos);

        // Remove "position" property that breaks older IE
        delete endPos.position;

        if (elastic) {
          startPos = this.getOrigPosition();

          if (current.openOpacity) {
            startPos.opacity = 0.1;
          }

        } else if (effect === 'fade') {
          startPos.opacity = 0.1;
        }

        F.wrap.css(startPos).animate(endPos, {
          duration: effect === 'none' ? 0 : current.openSpeed,
          easing: current.openEasing,
          step: elastic ? this.step : null,
          complete: F._afterZoomIn
        });
      },

      zoomOut: function () {
        var current = F.current,
          effect = current.closeEffect,
          elastic = effect === 'elastic',
          endPos = { opacity: 0.1 };

        if (elastic) {
          endPos = this.getOrigPosition();

          if (current.closeOpacity) {
            endPos.opacity = 0.1;
          }
        }

        F.wrap.animate(endPos, {
          duration: effect === 'none' ? 0 : current.closeSpeed,
          easing: current.closeEasing,
          step: elastic ? this.step : null,
          complete: F._afterZoomOut
        });
      },

      changeIn: function () {
        var current = F.current,
          effect = current.nextEffect,
          startPos = current.pos,
          endPos = { opacity: 1 },
          direction = F.direction,
          distance = 200,
          field;

        startPos.opacity = 0.1;

        if (effect === 'elastic') {
          field = direction === 'down' || direction === 'up' ? 'top' : 'left';

          if (direction === 'down' || direction === 'right') {
            startPos[field] = getValue(getScalar(startPos[field]) - distance);
            endPos[field] = '+=' + distance + 'px';

          } else {
            startPos[field] = getValue(getScalar(startPos[field]) + distance);
            endPos[field] = '-=' + distance + 'px';
          }
        }

        // Workaround for http://bugs.jquery.com/ticket/12273
        if (effect === 'none') {
          F._afterZoomIn();

        } else {
          F.wrap.css(startPos).animate(endPos, {
            duration: current.nextSpeed,
            easing: current.nextEasing,
            complete: F._afterZoomIn
          });
        }
      },

      changeOut: function () {
        var previous = F.previous,
          effect = previous.prevEffect,
          endPos = { opacity: 0.1 },
          direction = F.direction,
          distance = 200;

        if (effect === 'elastic') {
          endPos[direction === 'down' || direction === 'up' ? 'top' : 'left'] = (direction === 'up' || direction === 'left' ? '-' : '+') + '=' + distance + 'px';
        }

        previous.wrap.animate(endPos, {
          duration: effect === 'none' ? 0 : previous.prevSpeed,
          easing: previous.prevEasing,
          complete: function () {
            $(this).trigger('onReset').remove();
          }
        });
      }
    };

    /*
     *	Overlay helper
     */

    F.helpers.overlay = {
      defaults: {
        closeClick: true,      // if true, fancyBox will be closed when user clicks on the overlay
        speedOut: 200,       // duration of fadeOut animation
        showEarly: true,      // indicates if should be opened immediately or wait until the content is ready
        css: {},        // custom CSS properties
        locked: !isTouch,  // if true, the content will be locked into overlay
        fixed: true       // if false, the overlay CSS position property will not be set to "fixed"
      },

      overlay: null,      // current handle
      fixed: false,     // indicates if the overlay has position "fixed"
      el: $('html'), // element that contains "the lock"

      // Public methods
      create: function (opts) {
        var parent;

        opts = $.extend({}, this.defaults, opts);

        if (this.overlay) {
          this.close();
        }

        parent = F.coming ? F.coming.parent : opts.parent;

        this.overlay = $('<div class="fancybox-overlay"></div>').appendTo(parent && parent.length ? parent : 'body');
        this.fixed = false;

        if (opts.fixed && F.defaults.fixed) {
          this.overlay.addClass('fancybox-overlay-fixed');

          this.fixed = true;
        }
      },

      open: function (opts) {
        var that = this;

        opts = $.extend({}, this.defaults, opts);

        if (this.overlay) {
          this.overlay.unbind('.overlay').width('auto').height('auto');

        } else {
          this.create(opts);
        }

        if (!this.fixed) {
          W.bind('resize.overlay', $.proxy(this.update, this));

          this.update();
        }

        if (opts.closeClick) {
          this.overlay.bind('click.overlay', function (e) {
            if ($(e.target).hasClass('fancybox-overlay')) {
              if (F.isActive) {
                F.close();
              } else {
                that.close();
              }

              return false;
            }
          });
        }

        this.overlay.css(opts.css).show();
      },

      close: function () {
        W.unbind('resize.overlay');

        if (this.el.hasClass('fancybox-lock')) {
          $('.fancybox-margin').removeClass('fancybox-margin');

          this.el.removeClass('fancybox-lock');

          W.scrollTop(this.scrollV).scrollLeft(this.scrollH);
        }

        $('.fancybox-overlay').remove().hide();

        $.extend(this, {
          overlay: null,
          fixed: false
        });
      },

      // Private, callbacks

      update: function () {
        var width = '100%', offsetWidth;

        // Reset width/height so it will not mess
        this.overlay.width(width).height('100%');

        // jQuery does not return reliable result for IE
        if (IE) {
          offsetWidth = Math.max(document.documentElement.offsetWidth, document.body.offsetWidth);

          if (D.width() > offsetWidth) {
            width = D.width();
          }

        } else if (D.width() > W.width()) {
          width = D.width();
        }

        this.overlay.width(width).height(D.height());
      },

      // This is where we can manipulate DOM, because later it would cause iframes to reload
      onReady: function (opts, obj) {
        var overlay = this.overlay;

        $('.fancybox-overlay').stop(true, true);

        if (!overlay) {
          this.create(opts);
        }

        if (opts.locked && this.fixed && obj.fixed) {
          obj.locked = this.overlay.append(obj.wrap);
          obj.fixed = false;
        }

        if (opts.showEarly === true) {
          this.beforeShow.apply(this, arguments);
        }
      },

      beforeShow: function (opts, obj) {
        if (obj.locked && !this.el.hasClass('fancybox-lock')) {
          if (this.fixPosition !== false) {
            $('*').filter(function () {
              return ($(this).css('position') === 'fixed' && !$(this).hasClass("fancybox-overlay") && !$(this).hasClass("fancybox-wrap"));
            }).addClass('fancybox-margin');
          }

          this.el.addClass('fancybox-margin');

          this.scrollV = W.scrollTop();
          this.scrollH = W.scrollLeft();

          this.el.addClass('fancybox-lock');

          W.scrollTop(this.scrollV).scrollLeft(this.scrollH);
        }

        this.open(opts);
      },

      onUpdate: function () {
        if (!this.fixed) {
          this.update();
        }
      },

      afterClose: function (opts) {
        // Remove overlay if exists and fancyBox is not opening
        // (e.g., it is not being open using afterClose callback)
        if (this.overlay && !F.coming) {
          this.overlay.fadeOut(opts.speedOut, $.proxy(this.close, this));
        }
      }
    };

    /*
     *	Title helper
     */

    F.helpers.title = {
      defaults: {
        type: 'float', // 'float', 'inside', 'outside' or 'over',
        position: 'bottom' // 'top' or 'bottom'
      },

      beforeShow: function (opts) {
        var current = F.current,
          text = current.title,
          type = opts.type,
          title,
          target;

        if ($.isFunction(text)) {
          text = text.call(current.element, current);
        }

        if (!isString(text) || $.trim(text) === '') {
          return;
        }

        title = $('<div class="fancybox-title fancybox-title-' + type + '-wrap">' + text + '</div>');

        switch (type) {
          case 'inside':
            target = F.skin;
            break;

          case 'outside':
            target = F.wrap;
            break;

          case 'over':
            target = F.inner;
            break;

          default: // 'float'
            target = F.skin;

            title.appendTo('body');

            if (IE) {
              title.width(title.width());
            }

            title.wrapInner('<span class="child"></span>');

            //Increase bottom margin so this title will also fit into viewport
            F.current.margin[2] += Math.abs(getScalar(title.css('margin-bottom')));
            break;
        }

        title[(opts.position === 'top' ? 'prependTo' : 'appendTo')](target);
      }
    };

    // jQuery plugin initialization
    $.fn.fancybox = function (options) {
      var index,
        that = $(this),
        selector = this.selector || '',
        run = function (e) {
          var what = $(this).blur(), idx = index, relType, relVal;

          if (!(e.ctrlKey || e.altKey || e.shiftKey || e.metaKey) && !what.is('.fancybox-wrap')) {
            relType = options.groupAttr || 'data-fancybox-group';
            relVal = what.attr(relType);

            if (!relVal) {
              relType = 'rel';
              relVal = what.get(0)[relType];
            }

            if (relVal && relVal !== '' && relVal !== 'nofollow') {
              what = selector.length ? $(selector) : that;
              what = what.filter('[' + relType + '="' + relVal + '"]');
              idx = what.index(this);
            }

            options.index = idx;

            // Stop an event from bubbling if everything is fine
            if (F.open(what, options) !== false) {
              e.preventDefault();
            }
          }
        };

      options = options || {};
      index = options.index || 0;

      if (!selector || options.live === false) {
        that.unbind('click.fb-start').bind('click.fb-start', run);

      } else {
        D.undelegate(selector, 'click.fb-start').delegate(selector + ":not('.fancybox-item, .fancybox-nav')", 'click.fb-start', run);
      }

      this.filter('[data-fancybox-start=1]').trigger('click');

      return this;
    };

    // Tests that need a body at doc ready
    D.ready(function () {
      var w1, w2;

      if ($.scrollbarWidth === undefined) {
        // http://benalman.com/projects/jquery-misc-plugins/#scrollbarwidth
        $.scrollbarWidth = function () {
          var parent = $('<div style="width:50px;height:50px;overflow:auto"><div/></div>').appendTo('body'),
            child = parent.children(),
            width = child.innerWidth() - child.height(99).innerWidth();

          parent.remove();

          return width;
        };
      }

      if ($.support.fixedPosition === undefined) {
        $.support.fixedPosition = (function () {
          var elem = $('<div style="position:fixed;top:20px;"></div>').appendTo('body'),
            fixed = (elem[0].offsetTop === 20 || elem[0].offsetTop === 15);

          elem.remove();

          return fixed;
        }());
      }

      $.extend(F.defaults, {
        scrollbarWidth: $.scrollbarWidth(),
        fixed: $.support.fixedPosition,
        parent: $('body')
      });

      //Get real width of page scroll-bar
      w1 = $(window).width();

      H.addClass('fancybox-lock-test');

      w2 = $(window).width();

      H.removeClass('fancybox-lock-test');

      $("<style type='text/css'>.fancybox-margin{margin-right:" + (w2 - w1) + "px;}</style>").appendTo("head");
    });

  }(window, document, jQuery));
})();
;(function () {
  const mesurewidth = item => {
    let reqItemWidth = 0;

    const screenWidth = $(window).width();
    const container = item.closest(".catalogs__list");
    const titleBlocks = container.find(".catalogs__btn");
    const titleWidth = titleBlocks.width() * titleBlocks.length;

    const textContainer = item.find(".catalogs__container");
    const paddingLeft = parseInt(textContainer.css("padding-left"));
    const paddingRight = parseInt(textContainer.css("padding-right"));

    const isMobile = window.matchMedia("(max-width: 768px)").matches;

    if (isMobile) {
      reqItemWidth = screenWidth - titleWidth;
    } else {
      reqItemWidth = 500;
    }

    return {
      container: reqItemWidth,
      textContainer: reqItemWidth - paddingRight - paddingLeft
    }
  };

  const closeEveryItemContainer = container => {
    const items = container.find(".catalogs__item");
    const content = container.find(".catalogs__content");

    items.removeClass("active");
    content.width(0);
  }

  const openItem = (item) => {
    const hiddenContent = item.find(".catalogs__content");
    const reqWidth = mesurewidth(item);
    const textBlock = item.find(".catalogs__container");

    item.addClass("active");
    hiddenContent.width(reqWidth.container);
    textBlock.width(reqWidth.textContainer);
  };

  $(".catalogs__btn").on("click", e => {
    e.preventDefault();

    const $this = $(e.currentTarget);
    const item = $this.closest(".catalogs__item");
    const itemOpened = item.hasClass("active");
    const container = $this.closest(".catalogs__list");

    if (itemOpened) {
      closeEveryItemContainer(container);
    } else {
      closeEveryItemContainer(container);
      openItem(item);
    }
  });

  $(".catalogs__btn-close").on("click", e => {
    e.preventDefault();

    closeEveryItemContainer($(".catalogs__list"));
  })

})();
;(function () {
  const validateFields = (form, fieldsArray) => {

    fieldsArray.forEach((field) => {
      field.removeClass("input-error");
      if (field.val().trim() === "") {
        field.addClass("input-error");
      }
    });

    const errorFields = form.find(".input-error");

    return errorFields.length === 0;
  };

  $(".form").submit(e => {
    e.preventDefault();

    const form = $(e.currentTarget);
    const name = form.find("[name='username']");
    const phone = form.find("[name='usertel']");
    const comment = form.find("[name='usermessage']");
    const to = form.find("[name='to']");

    const popupForm = $("#popup-form");
    const content = popupForm.find(".popup-form__content");
    popupForm.removeClass("error-popup-form");

    const isValid = validateFields(form, [name, phone, comment, to]);

    if (isValid) {
      const request = $.ajax({
        url: "https://webdev-api.loftschool.com/sendmail",
        method: "post",
        data: {
          name: name.val(),
          phone: phone.val(),
          comment: comment.val(),
          to: to.val(),
        },

      });

      request.done(data => {
        content.text(data.message);
        $('.form')[0].reset();
      });

      request.fail(data => {
        const message = data.responseJSON.message;
        content.text(message);
        popupForm.addClass("error-popup-form");
      });

      request.always(() => {
        $.fancybox.open({
          src: "#popup-form",
          type: "inline"
        });
      });
    };
  });

  $(".app-submit-btn").click(e => {
    e.preventDefault();

    $.fancybox.close();
  });
})();
;(function () {
  let myMap;

  const init = () => {
    myMap = new ymaps.Map("map", {
      center: [55.74, 37.61],
      zoom: 14,
      controls: []
    });
    coords = [
      [55.749539, 37.603591]
    ];

    const myCollection = new ymaps.GeoObjectCollection({}, {
      draggable: false,
      iconLayout: 'default#image',
      iconImageHref: './img/marker.svg',
      iconImageSize: [70, 80],
      iconImageOffset: [-35, -52]
    });

    coords.forEach(coord => {
      myCollection.add(new ymaps.Placemark(coord));
    })

    myMap.geoObjects.add(myCollection);
    myMap.behaviors.disable('scrollZoom');
  };

  ymaps.ready(init);
})();
;(function () {
  let hamburger = document.querySelector('.hamburger');
  let popupMenu = document.querySelector('.popup-menu');
  let body = document.querySelector('body');

  let links = document.querySelectorAll('.popup-menu__link');

  links.forEach(function (element) {
    element.addEventListener('click', toggleMenu);
  });

  function toggleMenu() {
    hamburger.classList.toggle('hamburger--active');
    popupMenu.classList.toggle('popup-menu--active');
    body.classList.toggle('body--active-menu');
  };

  hamburger.addEventListener('click', toggleMenu);
})();
;(function () {
  const findBlockByAlias = alias => {
    return $(".reviews__item").filter((ndx, item) => {
      return $(item).attr("data-linked-with") === alias;
    });
  };

  $(".reviews__btn").click(e => {
    e.preventDefault();

    const $this = $(e.currentTarget);
    const target = $this.attr("data-open");
    const itemToShow = findBlockByAlias(target);
    const curItem = $this.closest(".reviews__menu-item");

    itemToShow.addClass("reviews__item--active").siblings().removeClass("reviews__item--active");
    curItem.addClass("reviews__menu-item--active").siblings().removeClass("reviews__menu-item--active");
  });
})();
;(function () {

  const sections = $("section");
  const display = $(".maincontent");
  const sideMenu = $(".fixed-menu");
  const menuItems = sideMenu.find(".fixed-menu__item");

  let inScroll = false;

  sections.first().addClass("active");

  const countSectionPosition = sectionEq => {
    return sectionEq * -100;
  };

  const changeMenuThemeForSection = sectionEq => {

    const currentSection = sections.eq(sectionEq);
    const menuTheme = currentSection.attr("data-sidemenu-theme");
    const activeClass = "fixed-menu--shadowed";

    if (menuTheme === "black") {
      sideMenu.addClass(activeClass);
    } else {
      sideMenu.removeClass(activeClass);
    }

  };

  const resetActiveClassForItem = (items, itemEq, activeClass) => {
    items.eq(itemEq).addClass(activeClass).siblings().removeClass(activeClass);
  }

  const performTransition = (sectionEq) => {

    if (inScroll) return;

    const transitionOver = 1000;
    const mouseInertiaOver = 300;

    inScroll = true;

    const position = countSectionPosition(sectionEq);

    changeMenuThemeForSection(sectionEq);

    display.css({
      transform: `translateY(${position}%)`
    });

    resetActiveClassForItem(sections, sectionEq, "active");

    setTimeout(() => {
      inScroll = false;
      resetActiveClassForItem(menuItems, sectionEq, "fixed-menu__item--active");
    }, transitionOver + mouseInertiaOver);


  };

  const scrollViewport = direction => {
    const activeSection = sections.filter(".active");
    const nextSection = activeSection.next();
    const prevSection = activeSection.prev();

    if (direction === "next" && nextSection.length) {
      performTransition(nextSection.index());
    }

    if (direction === "prev" && prevSection.length) {
      performTransition(prevSection.index());
    }
  };

  $(window).on("wheel", e => {
    const deltaY = e.originalEvent.deltaY;

    if (deltaY > 0) {
      scrollViewport("next");
    }

    if (deltaY < 0) {
      scrollViewport("prev");
    }

  });

  $(window).on("keydown", e => {

    const tagName = e.target.tagName.toLowerCase();
    const userTypingInInputs = tagName === "input" || tagName === "textarea";

    if (userTypingInInputs) return;

    switch (e.keyCode) {
      case 38:
        scrollViewport("prev");
        break;
      case 40:
        scrollViewport("next");
        break;
    }

  });

  $("[data-scroll-to]").click(e => {
    e.preventDefault();

    const $this = $(e.currentTarget);
    const target = $this.attr("data-scroll-to");
    const reqSection = $(`[data-section-id=${target}]`);

    performTransition(reqSection.index());
  });

})();
;(function () {
  const left = document.querySelector("#left");
  const right = document.querySelector("#right");
  const itemsList = document.querySelector("#items");

  const loop = (direction, e) => {
    e.preventDefault();

    if (direction === "right") {
      itemsList.appendChild(itemsList.firstElementChild);
    } else {
      itemsList.insertBefore(itemsList.lastElementChild, items.firstElementChild);
    }
  };

  right.addEventListener("click", (e) => {
    loop("right", e);
  });

  left.addEventListener("click", (e) => {
    loop("left", e);
  });
})();
;(function () {
  const openItem = item => {
    const container = item.closest(".teams__item");
    const contentBlock = container.find(".team__content");
    const textBlock = contentBlock.find(".team__content-block");
    const reqHeight = textBlock.height();

    container.addClass("team--active");
    contentBlock.height(reqHeight);
  };

  const closeEveryItem = (container) => {
    const items = container.find(".team__content");
    const itemContainer = container.find(".teams__item");

    itemContainer.removeClass("team--active");
    items.height(0);
  };

  $(".team__btn").click(e => {
    const $this = $(e.currentTarget);
    const container = $this.closest(".teams__list");
    const elemContainer = $this.closest(".teams__item");

    if (elemContainer.hasClass("team--active")) {
      closeEveryItem(container);
    } else {
      closeEveryItem(container);
      openItem($this);
    }

  });
})();
;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5qcyIsImpxdWVyeS5mYW5jeWJveC5qcyIsImNhdGFsb2dzLmpzIiwiZm9ybS5qcyIsIm1hcHMuanMiLCJtb2RhbC5qcyIsInJldmlld3MuanMiLCJzY3JvbGwuanMiLCJzbGlkZXIuanMiLCJ0ZWFtcy5qcyIsInZpZGVvLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQzk5VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0NuK0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0NuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0NwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENDakNBIiwiZmlsZSI6Im1haW4ubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjcuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMy0wOC0yOFQxMzozN1pcbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cbiAgICAgIC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2BcbiAgICAgIC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG4gICAgICAvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuICAgICAgLy8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG4gICAgICAvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuICAgICAgLy8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuICAgICAgLy8gU2VlIHRpY2tldCB0cmFjLTE0NTQ5IGZvciBtb3JlIGluZm8uXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG4gICAgICAgIGZhY3RvcnkoZ2xvYmFsLCB0cnVlKSA6XG4gICAgICAgIGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgaWYgKCF3LmRvY3VtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFjdG9yeSh3KTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmFjdG9yeShnbG9iYWwpO1xuICAgIH1cblxuICAgIC8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG4gIH0pKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAod2luZG93LCBub0dsb2JhbCkge1xuXG4gICAgLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4gICAgLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4gICAgLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbiAgICAvLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBhcnIgPSBbXTtcblxuICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuICAgIHZhciBzbGljZSA9IGFyci5zbGljZTtcblxuICAgIHZhciBmbGF0ID0gYXJyLmZsYXQgPyBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnIuZmxhdC5jYWxsKGFycmF5KTtcbiAgICB9IDogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyLmNvbmNhdC5hcHBseShbXSwgYXJyYXkpO1xuICAgIH07XG5cblxuICAgIHZhciBwdXNoID0gYXJyLnB1c2g7XG5cbiAgICB2YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG4gICAgdmFyIGNsYXNzMnR5cGUgPSB7fTtcblxuICAgIHZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbiAgICB2YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIHZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG4gICAgdmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbiAgICB2YXIgc3VwcG9ydCA9IHt9O1xuXG4gICAgdmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICAvLyBTdXBwb3J0OiBRdFdlYiA8PTMuOC41LCBXZWJLaXQgPD01MzQuMzQsIHdraHRtbHRvcGRmIHRvb2wgPD0wLjEyLjVcbiAgICAgIC8vIFBsdXMgZm9yIG9sZCBXZWJLaXQsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCBjb2xsZWN0aW9uc1xuICAgICAgLy8gKGUuZy4sIGB0eXBlb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIikgPT09IFwiZnVuY3Rpb25cImApLiAoZ2gtNDc1NilcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIiAmJlxuICAgICAgICB0eXBlb2Ygb2JqLml0ZW0gIT09IFwiZnVuY3Rpb25cIjtcbiAgICB9O1xuXG5cbiAgICB2YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG4gICAgfTtcblxuXG4gICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG5cblxuICAgIHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuICAgICAgdHlwZTogdHJ1ZSxcbiAgICAgIHNyYzogdHJ1ZSxcbiAgICAgIG5vbmNlOiB0cnVlLFxuICAgICAgbm9Nb2R1bGU6IHRydWVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRE9NRXZhbChjb2RlLCBub2RlLCBkb2MpIHtcbiAgICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuICAgICAgdmFyIGksIHZhbCxcbiAgICAgICAgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cbiAgICAgIHNjcmlwdC50ZXh0ID0gY29kZTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGZvciAoaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzKSB7XG5cbiAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcbiAgICAgICAgICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuICAgICAgICAgIC8vIE9uIHRoZSBvdGhlciBoYW5kLCBqdXN0IHVzaW5nIGBnZXRBdHRyaWJ1dGVgIGlzIG5vdCBlbm91Z2ggYXNcbiAgICAgICAgICAvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG4gICAgICAgICAgLy8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cbiAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy8yMzY5XG4gICAgICAgICAgLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcbiAgICAgICAgICAvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG4gICAgICAgICAgLy8gYGpRdWVyeS5nbG9iYWxFdmFsYCBzbyB0aGF0IGl0IGNhbiBmYWtlIGEgbm9uY2UtY29udGFpbmluZyBub2RlXG4gICAgICAgICAgLy8gdmlhIGFuIG9iamVjdC5cbiAgICAgICAgICB2YWwgPSBub2RlW2ldIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKGkpO1xuICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoaSwgdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvYy5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gdG9UeXBlKG9iaikge1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmogKyBcIlwiO1xuICAgICAgfVxuXG4gICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG4gICAgICAgIGNsYXNzMnR5cGVbdG9TdHJpbmcuY2FsbChvYmopXSB8fCBcIm9iamVjdFwiIDpcbiAgICAgICAgdHlwZW9mIG9iajtcbiAgICB9XG4gICAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICAgIC8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4gICAgLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbiAgICB2YXIgdmVyc2lvbiA9IFwiMy43LjFcIixcblxuICAgICAgcmh0bWxTdWZmaXggPSAvSFRNTCQvaSxcblxuICAgICAgLy8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcbiAgICAgIGpRdWVyeSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCkge1xuXG4gICAgICAgIC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuICAgICAgICAvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuICAgICAgICByZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KHNlbGVjdG9yLCBjb250ZXh0KTtcbiAgICAgIH07XG5cbiAgICBqUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG4gICAgICAvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG4gICAgICBqcXVlcnk6IHZlcnNpb24sXG5cbiAgICAgIGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cbiAgICAgIC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuICAgICAgbGVuZ3RoOiAwLFxuXG4gICAgICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKHRoaXMpO1xuICAgICAgfSxcblxuICAgICAgLy8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuICAgICAgLy8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcbiAgICAgIGdldDogZnVuY3Rpb24gKG51bSkge1xuXG4gICAgICAgIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcbiAgICAgICAgaWYgKG51bSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG4gICAgICAgIHJldHVybiBudW0gPCAwID8gdGhpc1tudW0gKyB0aGlzLmxlbmd0aF0gOiB0aGlzW251bV07XG4gICAgICB9LFxuXG4gICAgICAvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG4gICAgICAvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcbiAgICAgIHB1c2hTdGFjazogZnVuY3Rpb24gKGVsZW1zKSB7XG5cbiAgICAgICAgLy8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcbiAgICAgICAgdmFyIHJldCA9IGpRdWVyeS5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zKTtcblxuICAgICAgICAvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuICAgICAgICByZXQucHJldk9iamVjdCA9IHRoaXM7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG5cbiAgICAgIC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG4gICAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5lYWNoKHRoaXMsIGNhbGxiYWNrKTtcbiAgICAgIH0sXG5cbiAgICAgIG1hcDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhqUXVlcnkubWFwKHRoaXMsIGZ1bmN0aW9uIChlbGVtLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoZWxlbSwgaSwgZWxlbSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG5cbiAgICAgIHNsaWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhzbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH0sXG5cbiAgICAgIGZpcnN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVxKDApO1xuICAgICAgfSxcblxuICAgICAgbGFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcSgtMSk7XG4gICAgICB9LFxuXG4gICAgICBldmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhqUXVlcnkuZ3JlcCh0aGlzLCBmdW5jdGlvbiAoX2VsZW0sIGkpIHtcbiAgICAgICAgICByZXR1cm4gKGkgKyAxKSAlIDI7XG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG5cbiAgICAgIG9kZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soalF1ZXJ5LmdyZXAodGhpcywgZnVuY3Rpb24gKF9lbGVtLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGkgJSAyO1xuICAgICAgICB9KSk7XG4gICAgICB9LFxuXG4gICAgICBlcTogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgIGogPSAraSArIChpIDwgMCA/IGxlbiA6IDApO1xuICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soaiA+PSAwICYmIGogPCBsZW4gPyBbdGhpc1tqXV0gOiBbXSk7XG4gICAgICB9LFxuXG4gICAgICBlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICB9LFxuXG4gICAgICAvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAgICAvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cbiAgICAgIHB1c2g6IHB1c2gsXG4gICAgICBzb3J0OiBhcnIuc29ydCxcbiAgICAgIHNwbGljZTogYXJyLnNwbGljZVxuICAgIH07XG5cbiAgICBqUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcbiAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICBpID0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgZGVlcCA9IGZhbHNlO1xuXG4gICAgICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG4gICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgZGVlcCA9IHRhcmdldDtcblxuICAgICAgICAvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpXSB8fCB7fTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0ID0ge307XG4gICAgICB9XG5cbiAgICAgIC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgICAgaWYgKGkgPT09IGxlbmd0aCkge1xuICAgICAgICB0YXJnZXQgPSB0aGlzO1xuICAgICAgICBpLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gICAgICAgIGlmICgob3B0aW9ucyA9IGFyZ3VtZW50c1tpXSkgIT0gbnVsbCkge1xuXG4gICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICAgIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb3B5ID0gb3B0aW9uc1tuYW1lXTtcblxuICAgICAgICAgICAgLy8gUHJldmVudCBPYmplY3QucHJvdG90eXBlIHBvbGx1dGlvblxuICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgfHwgdGFyZ2V0ID09PSBjb3B5KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcbiAgICAgICAgICAgIGlmIChkZWVwICYmIGNvcHkgJiYgKGpRdWVyeS5pc1BsYWluT2JqZWN0KGNvcHkpIHx8XG4gICAgICAgICAgICAgIChjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY29weSkpKSkge1xuICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbbmFtZV07XG5cbiAgICAgICAgICAgICAgLy8gRW5zdXJlIHByb3BlciB0eXBlIGZvciB0aGUgc291cmNlIHZhbHVlXG4gICAgICAgICAgICAgIGlmIChjb3B5SXNBcnJheSAmJiAhQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUgPSBbXTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KHNyYykpIHtcbiAgICAgICAgICAgICAgICBjbG9uZSA9IHt9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsb25lID0gc3JjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG4gICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGpRdWVyeS5leHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xuXG4gICAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcblxuICAgICAgLy8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG4gICAgICBleHBhbmRvOiBcImpRdWVyeVwiICsgKHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9cXEQvZywgXCJcIiksXG5cbiAgICAgIC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG4gICAgICBpc1JlYWR5OiB0cnVlLFxuXG4gICAgICBlcnJvcjogZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0sXG5cbiAgICAgIG5vb3A6IGZ1bmN0aW9uICgpIHsgfSxcblxuICAgICAgaXNQbGFpbk9iamVjdDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgcHJvdG8sIEN0b3I7XG5cbiAgICAgICAgLy8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG4gICAgICAgIC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuICAgICAgICBpZiAoIW9iaiB8fCB0b1N0cmluZy5jYWxsKG9iaikgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcm90byA9IGdldFByb3RvKG9iaik7XG5cbiAgICAgICAgLy8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuICAgICAgICBpZiAoIXByb3RvKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuICAgICAgICBDdG9yID0gaGFzT3duLmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbChDdG9yKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG4gICAgICB9LFxuXG4gICAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBuYW1lO1xuXG4gICAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuXG4gICAgICAvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBwcm92aWRlZCBjb250ZXh0OyBmYWxscyBiYWNrIHRvIHRoZSBnbG9iYWwgb25lXG4gICAgICAvLyBpZiBub3Qgc3BlY2lmaWVkLlxuICAgICAgZ2xvYmFsRXZhbDogZnVuY3Rpb24gKGNvZGUsIG9wdGlvbnMsIGRvYykge1xuICAgICAgICBET01FdmFsKGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9LCBkb2MpO1xuICAgICAgfSxcblxuICAgICAgZWFjaDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGxlbmd0aCwgaSA9IDA7XG5cbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgICAgICBsZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKG9ialtpXSwgaSwgb2JqW2ldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKG9ialtpXSwgaSwgb2JqW2ldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sXG5cblxuICAgICAgLy8gUmV0cmlldmUgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gICAgICB0ZXh0OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICB2YXIgbm9kZSxcbiAgICAgICAgICByZXQgPSBcIlwiLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuICAgICAgICBpZiAoIW5vZGVUeXBlKSB7XG5cbiAgICAgICAgICAvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuICAgICAgICAgIHdoaWxlICgobm9kZSA9IGVsZW1baSsrXSkpIHtcblxuICAgICAgICAgICAgLy8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcbiAgICAgICAgICAgIHJldCArPSBqUXVlcnkudGV4dChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgIHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgIHJldHVybiBlbGVtLmRvY3VtZW50RWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxcblxuICAgICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAgbWFrZUFycmF5OiBmdW5jdGlvbiAoYXJyLCByZXN1bHRzKSB7XG4gICAgICAgIHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG4gICAgICAgIGlmIChhcnIgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpc0FycmF5TGlrZShPYmplY3QoYXJyKSkpIHtcbiAgICAgICAgICAgIGpRdWVyeS5tZXJnZShyZXQsXG4gICAgICAgICAgICAgIHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuICAgICAgICAgICAgICAgIFthcnJdIDogYXJyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdXNoLmNhbGwocmV0LCBhcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuXG4gICAgICBpbkFycmF5OiBmdW5jdGlvbiAoZWxlbSwgYXJyLCBpKSB7XG4gICAgICAgIHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKGFyciwgZWxlbSwgaSk7XG4gICAgICB9LFxuXG4gICAgICBpc1hNTERvYzogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGVsZW0gJiYgZWxlbS5uYW1lc3BhY2VVUkksXG4gICAgICAgICAgZG9jRWxlbSA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgLy8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlXG4gICAgICAgIC8vIGRvY3VtZW50IGZyYWdtZW50cy5cbiAgICAgICAgcmV0dXJuICFyaHRtbFN1ZmZpeC50ZXN0KG5hbWVzcGFjZSB8fCBkb2NFbGVtICYmIGRvY0VsZW0ubm9kZU5hbWUgfHwgXCJIVE1MXCIpO1xuICAgICAgfSxcblxuICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICBtZXJnZTogZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgdmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuICAgICAgICAgIGogPSAwLFxuICAgICAgICAgIGkgPSBmaXJzdC5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGZpcnN0W2krK10gPSBzZWNvbmRbal07XG4gICAgICAgIH1cblxuICAgICAgICBmaXJzdC5sZW5ndGggPSBpO1xuXG4gICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgIH0sXG5cbiAgICAgIGdyZXA6IGZ1bmN0aW9uIChlbGVtcywgY2FsbGJhY2ssIGludmVydCkge1xuICAgICAgICB2YXIgY2FsbGJhY2tJbnZlcnNlLFxuICAgICAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG4gICAgICAgICAgY2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcbiAgICAgICAgLy8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayhlbGVtc1tpXSwgaSk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QpIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChlbGVtc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICB9LFxuXG4gICAgICAvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcbiAgICAgIG1hcDogZnVuY3Rpb24gKGVsZW1zLCBjYWxsYmFjaywgYXJnKSB7XG4gICAgICAgIHZhciBsZW5ndGgsIHZhbHVlLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIHJldCA9IFtdO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG4gICAgICAgIGlmIChpc0FycmF5TGlrZShlbGVtcykpIHtcbiAgICAgICAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG4gICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtc1tpXSwgaSwgYXJnKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChpIGluIGVsZW1zKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKGVsZW1zW2ldLCBpLCBhcmcpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuICAgICAgICByZXR1cm4gZmxhdChyZXQpO1xuICAgICAgfSxcblxuICAgICAgLy8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG4gICAgICBndWlkOiAxLFxuXG4gICAgICAvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcbiAgICAgIC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG4gICAgICBzdXBwb3J0OiBzdXBwb3J0XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBqUXVlcnkuZm5bU3ltYm9sLml0ZXJhdG9yXSA9IGFycltTeW1ib2wuaXRlcmF0b3JdO1xuICAgIH1cblxuICAgIC8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxuICAgIGpRdWVyeS5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdChcIiBcIiksXG4gICAgICBmdW5jdGlvbiAoX2ksIG5hbWUpIHtcbiAgICAgICAgY2xhc3MydHlwZVtcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCJdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSk7XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcblxuICAgICAgLy8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuICAgICAgLy8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuICAgICAgLy8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG4gICAgICAvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG4gICAgICB2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcbiAgICAgICAgdHlwZSA9IHRvVHlwZShvYmopO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihvYmopIHx8IGlzV2luZG93KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuICAgICAgICB0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKGxlbmd0aCAtIDEpIGluIG9iajtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG5vZGVOYW1lKGVsZW0sIG5hbWUpIHtcblxuICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICB9XG4gICAgdmFyIHBvcCA9IGFyci5wb3A7XG5cblxuICAgIHZhciBzb3J0ID0gYXJyLnNvcnQ7XG5cblxuICAgIHZhciBzcGxpY2UgPSBhcnIuc3BsaWNlO1xuXG5cbiAgICB2YXIgd2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIjtcblxuXG4gICAgdmFyIHJ0cmltQ1NTID0gbmV3IFJlZ0V4cChcbiAgICAgIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsXG4gICAgICBcImdcIlxuICAgICk7XG5cblxuXG5cbiAgICAvLyBOb3RlOiBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG4gICAgalF1ZXJ5LmNvbnRhaW5zID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblxuICAgICAgcmV0dXJuIGEgPT09IGJ1cCB8fCAhIShidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG4gICAgICAgIC8vIElFIGRvZXNuJ3QgaGF2ZSBgY29udGFpbnNgIG9uIFNWRy5cbiAgICAgICAgYS5jb250YWlucyA/XG4gICAgICAgICAgYS5jb250YWlucyhidXApIDpcbiAgICAgICAgICBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYnVwKSAmIDE2XG4gICAgICApKTtcbiAgICB9O1xuXG5cblxuXG4gICAgLy8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cbiAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcbiAgICB2YXIgcmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxceDgwLVxcdUZGRkZcXHctXS9nO1xuXG4gICAgZnVuY3Rpb24gZmNzc2VzY2FwZShjaCwgYXNDb2RlUG9pbnQpIHtcbiAgICAgIGlmIChhc0NvZGVQb2ludCkge1xuXG4gICAgICAgIC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuICAgICAgICBpZiAoY2ggPT09IFwiXFwwXCIpIHtcbiAgICAgICAgICByZXR1cm4gXCJcXHVGRkZEXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuICAgICAgICByZXR1cm4gY2guc2xpY2UoMCwgLTEpICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KGNoLmxlbmd0aCAtIDEpLnRvU3RyaW5nKDE2KSArIFwiIFwiO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG4gICAgICByZXR1cm4gXCJcXFxcXCIgKyBjaDtcbiAgICB9XG5cbiAgICBqUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsKSB7XG4gICAgICByZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UocmNzc2VzY2FwZSwgZmNzc2VzY2FwZSk7XG4gICAgfTtcblxuXG5cblxuICAgIHZhciBwcmVmZXJyZWREb2MgPSBkb2N1bWVudCxcbiAgICAgIHB1c2hOYXRpdmUgPSBwdXNoO1xuXG4gICAgKGZ1bmN0aW9uICgpIHtcblxuICAgICAgdmFyIGksXG4gICAgICAgIEV4cHIsXG4gICAgICAgIG91dGVybW9zdENvbnRleHQsXG4gICAgICAgIHNvcnRJbnB1dCxcbiAgICAgICAgaGFzRHVwbGljYXRlLFxuICAgICAgICBwdXNoID0gcHVzaE5hdGl2ZSxcblxuICAgICAgICAvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG4gICAgICAgIGRvY3VtZW50LFxuICAgICAgICBkb2N1bWVudEVsZW1lbnQsXG4gICAgICAgIGRvY3VtZW50SXNIVE1MLFxuICAgICAgICByYnVnZ3lRU0EsXG4gICAgICAgIG1hdGNoZXMsXG5cbiAgICAgICAgLy8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuICAgICAgICBleHBhbmRvID0galF1ZXJ5LmV4cGFuZG8sXG4gICAgICAgIGRpcnJ1bnMgPSAwLFxuICAgICAgICBkb25lID0gMCxcbiAgICAgICAgY2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgIHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICBjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICAgICAgbm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgIHNvcnRPcmRlciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8XCIgK1xuICAgICAgICAgIFwibG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG4gICAgICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNpZGVudC10b2tlbi1kaWFncmFtXG4gICAgICAgIGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICtcbiAgICAgICAgICBcIj98XFxcXFxcXFxbXlxcXFxyXFxcXG5cXFxcZl18W1xcXFx3LV18W15cXDAtXFxcXHg3Zl0pK1wiLFxuXG4gICAgICAgIC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcbiAgICAgICAgYXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblxuICAgICAgICAgIC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG4gICAgICAgICAgXCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblxuICAgICAgICAgIC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG4gICAgICAgICAgXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArXG4gICAgICAgICAgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG5cbiAgICAgICAgcHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cbiAgICAgICAgICAvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuICAgICAgICAgIC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuICAgICAgICAgIFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXG4gICAgICAgICAgLy8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG4gICAgICAgICAgXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXG4gICAgICAgICAgLy8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuICAgICAgICAgIFwiLipcIiArXG4gICAgICAgICAgXCIpXFxcXCl8KVwiLFxuXG4gICAgICAgIC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcbiAgICAgICAgcndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIpLFxuXG4gICAgICAgIHJjb21tYSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiKSxcbiAgICAgICAgcmxlYWRpbmdDb21iaW5hdG9yID0gbmV3IFJlZ0V4cChcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgK1xuICAgICAgICAgIHdoaXRlc3BhY2UgKyBcIipcIiksXG4gICAgICAgIHJkZXNjZW5kID0gbmV3IFJlZ0V4cCh3aGl0ZXNwYWNlICsgXCJ8PlwiKSxcblxuICAgICAgICBycHNldWRvID0gbmV3IFJlZ0V4cChwc2V1ZG9zKSxcbiAgICAgICAgcmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiKSxcblxuICAgICAgICBtYXRjaEV4cHIgPSB7XG4gICAgICAgICAgSUQ6IG5ldyBSZWdFeHAoXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiksXG4gICAgICAgICAgQ0xBU1M6IG5ldyBSZWdFeHAoXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIpLFxuICAgICAgICAgIFRBRzogbmV3IFJlZ0V4cChcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiKSxcbiAgICAgICAgICBBVFRSOiBuZXcgUmVnRXhwKFwiXlwiICsgYXR0cmlidXRlcyksXG4gICAgICAgICAgUFNFVURPOiBuZXcgUmVnRXhwKFwiXlwiICsgcHNldWRvcyksXG4gICAgICAgICAgQ0hJTEQ6IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgK1xuICAgICAgICAgICAgd2hpdGVzcGFjZSArIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICtcbiAgICAgICAgICAgIHdoaXRlc3BhY2UgKyBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIpLFxuICAgICAgICAgIGJvb2w6IG5ldyBSZWdFeHAoXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIpLFxuXG4gICAgICAgICAgLy8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG4gICAgICAgICAgLy8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuICAgICAgICAgIG5lZWRzQ29udGV4dDogbmV3IFJlZ0V4cChcIl5cIiArIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG4gICAgICAgICAgICBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIpXG4gICAgICAgIH0sXG5cbiAgICAgICAgcmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG4gICAgICAgIHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cbiAgICAgICAgLy8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG4gICAgICAgIHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuICAgICAgICByc2libGluZyA9IC9bK35dLyxcblxuICAgICAgICAvLyBDU1MgZXNjYXBlc1xuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuICAgICAgICBydW5lc2NhcGUgPSBuZXcgUmVnRXhwKFwiXFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgK1xuICAgICAgICAgIFwiP3xcXFxcXFxcXChbXlxcXFxyXFxcXG5cXFxcZl0pXCIsIFwiZ1wiKSxcbiAgICAgICAgZnVuZXNjYXBlID0gZnVuY3Rpb24gKGVzY2FwZSwgbm9uSGV4KSB7XG4gICAgICAgICAgdmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGUuc2xpY2UoMSkgLSAweDEwMDAwO1xuXG4gICAgICAgICAgaWYgKG5vbkhleCkge1xuXG4gICAgICAgICAgICAvLyBTdHJpcCB0aGUgYmFja3NsYXNoIHByZWZpeCBmcm9tIGEgbm9uLWhleCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgIHJldHVybiBub25IZXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVwbGFjZSBhIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbmNvZGVkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTErXG4gICAgICAgICAgLy8gRm9yIHZhbHVlcyBvdXRzaWRlIHRoZSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmUgKEJNUCksIG1hbnVhbGx5IGNvbnN0cnVjdCBhXG4gICAgICAgICAgLy8gc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICByZXR1cm4gaGlnaCA8IDAgP1xuICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShoaWdoICsgMHgxMDAwMCkgOlxuICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFVzZWQgZm9yIGlmcmFtZXM7IHNlZSBgc2V0RG9jdW1lbnRgLlxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG4gICAgICAgIC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuICAgICAgICAvLyBlcnJvciBpbiBJRS9FZGdlLlxuICAgICAgICB1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNldERvY3VtZW50KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcbiAgICAgICAgICBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgbm9kZU5hbWUoZWxlbSwgXCJmaWVsZHNldFwiKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG4gICAgICAgICk7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAvLyBBY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gdGhyb3cgdW5leHBlY3RlZGx5XG4gICAgICAvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzOTNcbiAgICAgIGZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHsgfVxuICAgICAgfVxuXG4gICAgICAvLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxuICAgICAgdHJ5IHtcbiAgICAgICAgcHVzaC5hcHBseShcbiAgICAgICAgICAoYXJyID0gc2xpY2UuY2FsbChwcmVmZXJyZWREb2MuY2hpbGROb2RlcykpLFxuICAgICAgICAgIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMFxuICAgICAgICAvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgICAgYXJyW3ByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aF0ubm9kZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHB1c2ggPSB7XG4gICAgICAgICAgYXBwbHk6IGZ1bmN0aW9uICh0YXJnZXQsIGVscykge1xuICAgICAgICAgICAgcHVzaE5hdGl2ZS5hcHBseSh0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYWxsOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBwdXNoTmF0aXZlLmFwcGx5KHRhcmdldCwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpIHtcbiAgICAgICAgdmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG4gICAgICAgICAgbmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG4gICAgICAgICAgLy8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuICAgICAgICAgIG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG4gICAgICAgIC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG4gICAgICAgICAgbm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExKSB7XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcbiAgICAgICAgaWYgKCFzZWVkKSB7XG4gICAgICAgICAgc2V0RG9jdW1lbnQoY29udGV4dCk7XG4gICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgICBpZiAoZG9jdW1lbnRJc0hUTUwpIHtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2RcbiAgICAgICAgICAgIC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcbiAgICAgICAgICAgIGlmIChub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKHNlbGVjdG9yKSkpIHtcblxuICAgICAgICAgICAgICAvLyBJRCBzZWxlY3RvclxuICAgICAgICAgICAgICBpZiAoKG0gPSBtYXRjaFsxXSkpIHtcblxuICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQobSkpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgOSBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0uaWQgPT09IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwocmVzdWx0cywgZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IG9ubHlcbiAgICAgICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZChtKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgZmluZC5jb250YWlucyhjb250ZXh0LCBlbGVtKSAmJlxuICAgICAgICAgICAgICAgICAgICBlbGVtLmlkID09PSBtKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcHVzaC5jYWxsKHJlc3VsdHMsIGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUeXBlIHNlbGVjdG9yXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc2VsZWN0b3IpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcblxuICAgICAgICAgICAgICAgIC8vIENsYXNzIHNlbGVjdG9yXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG0gPSBtYXRjaFszXSkgJiYgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcbiAgICAgICAgICAgIGlmICghbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVtzZWxlY3RvciArIFwiIFwiXSAmJlxuICAgICAgICAgICAgICAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3Qoc2VsZWN0b3IpKSkge1xuXG4gICAgICAgICAgICAgIG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgIG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXG4gICAgICAgICAgICAgIC8vIHFTQSBjb25zaWRlcnMgZWxlbWVudHMgb3V0c2lkZSBhIHNjb3Bpbmcgcm9vdCB3aGVuIGV2YWx1YXRpbmcgY2hpbGQgb3JcbiAgICAgICAgICAgICAgLy8gZGVzY2VuZGFudCBjb21iaW5hdG9ycywgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC5cbiAgICAgICAgICAgICAgLy8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcbiAgICAgICAgICAgICAgLy8gbGlzdCB3aXRoIGFuIElEIHNlbGVjdG9yIHJlZmVyZW5jaW5nIHRoZSBzY29wZSBjb250ZXh0LlxuICAgICAgICAgICAgICAvLyBUaGUgdGVjaG5pcXVlIGhhcyB0byBiZSB1c2VkIGFzIHdlbGwgd2hlbiBhIGxlYWRpbmcgY29tYmluYXRvciBpcyB1c2VkXG4gICAgICAgICAgICAgIC8vIGFzIHN1Y2ggc2VsZWN0b3JzIGFyZSBub3QgcmVjb2duaXplZCBieSBxdWVyeVNlbGVjdG9yQWxsLlxuICAgICAgICAgICAgICAvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB0ZWNobmlxdWUuXG4gICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIChyZGVzY2VuZC50ZXN0KHNlbGVjdG9yKSB8fCBybGVhZGluZ0NvbWJpbmF0b3IudGVzdChzZWxlY3RvcikpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdChzZWxlY3RvcikgJiYgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fFxuICAgICAgICAgICAgICAgICAgY29udGV4dDtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgOnNjb3BlIGluc3RlYWQgb2YgdGhlIElEIGhhY2sgaWYgdGhlIGJyb3dzZXJcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0cyBpdCAmIGlmIHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgY29udGV4dC5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcbiAgICAgICAgICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuXG4gICAgICAgICAgICAgICAgLy8gc3RyaWN0LWNvbXBhcmluZyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgICAgIGlmIChuZXdDb250ZXh0ICE9IGNvbnRleHQgfHwgIXN1cHBvcnQuc2NvcGUpIHtcblxuICAgICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgIGlmICgobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmlkID0galF1ZXJ5LmVzY2FwZVNlbGVjdG9yKG5pZCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldEF0dHJpYnV0ZShcImlkXCIsIChuaWQgPSBleHBhbmRvKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgZ3JvdXBzID0gdG9rZW5pemUoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGkgPSBncm91cHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgIGdyb3Vwc1tpXSA9IChuaWQgPyBcIiNcIiArIG5pZCA6IFwiOnNjb3BlXCIpICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICB0b1NlbGVjdG9yKGdyb3Vwc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsXG4gICAgICAgICAgICAgICAgICBuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwobmV3U2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgfSBjYXRjaCAocXNhRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBub25uYXRpdmVTZWxlY3RvckNhY2hlKHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAobmlkID09PSBleHBhbmRvKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbCBvdGhlcnNcbiAgICAgICAgcmV0dXJuIHNlbGVjdChzZWxlY3Rvci5yZXBsYWNlKHJ0cmltQ1NTLCBcIiQxXCIpLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAgICAgICAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICAgICAgICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG4gICAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gY2FjaGUoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgICAgLy8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgLy8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9pc3N1ZXMvMTU3KVxuICAgICAgICAgIGlmIChrZXlzLnB1c2goa2V5ICsgXCIgXCIpID4gRXhwci5jYWNoZUxlbmd0aCkge1xuXG4gICAgICAgICAgICAvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXlzLnNoaWZ0KCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKGNhY2hlW2tleSArIFwiIFwiXSA9IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBqUXVlcnkgc2VsZWN0b3IgbW9kdWxlXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBtYXJrRnVuY3Rpb24oZm4pIHtcbiAgICAgICAgZm5bZXhwYW5kb10gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gYXNzZXJ0KGZuKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAhIWZuKGVsKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcblxuICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuICAgICAgICAgIGVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGVOYW1lKGVsZW0sIFwiaW5wdXRcIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgcmV0dXJuIChub2RlTmFtZShlbGVtLCBcImlucHV0XCIpIHx8IG5vZGVOYW1lKGVsZW0sIFwiYnV0dG9uXCIpKSAmJlxuICAgICAgICAgICAgZWxlbS50eXBlID09PSB0eXBlO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKGRpc2FibGVkKSB7XG5cbiAgICAgICAgLy8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuXG4gICAgICAgICAgLy8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcbiAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG4gICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcbiAgICAgICAgICBpZiAoXCJmb3JtXCIgaW4gZWxlbSkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG4gICAgICAgICAgICAvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuICAgICAgICAgICAgLy8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuICAgICAgICAgICAgLy8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcbiAgICAgICAgICAgIC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcbiAgICAgICAgICAgIC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuICAgICAgICAgICAgLy8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuICAgICAgICAgICAgaWYgKGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSkge1xuXG4gICAgICAgICAgICAgIC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG4gICAgICAgICAgICAgIGlmIChcImxhYmVsXCIgaW4gZWxlbSkge1xuICAgICAgICAgICAgICAgIGlmIChcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDYgLSAxMStcbiAgICAgICAgICAgICAgLy8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuICAgICAgICAgICAgICAgIC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG4gICAgICAgICAgICAgICAgZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICBpbkRpc2FibGVkRmllbGRzZXQoZWxlbSkgPT09IGRpc2FibGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cbiAgICAgICAgICAgIC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cbiAgICAgICAgICAgIC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuICAgICAgICAgICAgLy8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICAgICAgfSBlbHNlIGlmIChcImxhYmVsXCIgaW4gZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZm4pIHtcbiAgICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgICAgICBhcmd1bWVudCA9ICthcmd1bWVudDtcbiAgICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWVkLCBtYXRjaGVzKSB7XG4gICAgICAgICAgICB2YXIgaixcbiAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzID0gZm4oW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCksXG4gICAgICAgICAgICAgIGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgaWYgKHNlZWRbKGogPSBtYXRjaEluZGV4ZXNbaV0pXSkge1xuICAgICAgICAgICAgICAgIHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIGpRdWVyeSBzZWxlY3RvciBjb250ZXh0XG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICAgICAgICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHRlc3RDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtub2RlXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICAgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBzZXREb2N1bWVudChub2RlKSB7XG4gICAgICAgIHZhciBzdWJXaW5kb3csXG4gICAgICAgICAgZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG4gICAgICAgIC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcbiAgICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgIGlmIChkb2MgPT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcbiAgICAgICAgZG9jdW1lbnQgPSBkb2M7XG4gICAgICAgIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgZG9jdW1lbnRJc0hUTUwgPSAhalF1ZXJ5LmlzWE1MRG9jKGRvY3VtZW50KTtcblxuICAgICAgICAvLyBTdXBwb3J0OiBpT1MgNyBvbmx5LCBJRSA5IC0gMTErXG4gICAgICAgIC8vIE9sZGVyIGJyb3dzZXJzIGRpZG4ndCBzdXBwb3J0IHVucHJlZml4ZWQgYG1hdGNoZXNgLlxuICAgICAgICBtYXRjaGVzID0gZG9jdW1lbnRFbGVtZW50Lm1hdGNoZXMgfHxcbiAgICAgICAgICBkb2N1bWVudEVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgZG9jdW1lbnRFbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcbiAgICAgICAgLy8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzXG4gICAgICAgIC8vIChzZWUgdHJhYy0xMzkzNikuXG4gICAgICAgIC8vIExpbWl0IHRoZSBmaXggdG8gSUUgJiBFZGdlIExlZ2FjeTsgZGVzcGl0ZSBFZGdlIDE1KyBpbXBsZW1lbnRpbmcgYG1hdGNoZXNgLFxuICAgICAgICAvLyBhbGwgSUUgOSsgYW5kIEVkZ2UgTGVnYWN5IHZlcnNpb25zIGltcGxlbWVudCBgbXNNYXRjaGVzU2VsZWN0b3JgIGFzIHdlbGwuXG4gICAgICAgIGlmIChkb2N1bWVudEVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3IgJiZcblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuICAgICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuICAgICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgcHJlZmVycmVkRG9jICE9IGRvY3VtZW50ICYmXG4gICAgICAgICAgKHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cpIHtcblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcbiAgICAgICAgICBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDwxMFxuICAgICAgICAvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcbiAgICAgICAgLy8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG4gICAgICAgIC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuICAgICAgICBzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGVsKS5pZCA9IGpRdWVyeS5leHBhbmRvO1xuICAgICAgICAgIHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHxcbiAgICAgICAgICAgICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShqUXVlcnkuZXhwYW5kbykubGVuZ3RoO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IG9ubHlcbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgIC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUuXG4gICAgICAgIHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbCwgXCIqXCIpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG4gICAgICAgIC8vIElFL0VkZ2UgZG9uJ3Qgc3VwcG9ydCB0aGUgOnNjb3BlIHBzZXVkby1jbGFzcy5cbiAgICAgICAgc3VwcG9ydC5zY29wZSA9IGFzc2VydChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6c2NvcGVcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSAxMDUgLSAxMTEgb25seSwgU2FmYXJpIDE1LjQgLSAxNi4zIG9ubHlcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBgOmhhcygpYCBhcmd1bWVudCBpcyBwYXJzZWQgdW5mb3JnaXZpbmdseS5cbiAgICAgICAgLy8gV2UgaW5jbHVkZSBgKmAgaW4gdGhlIHRlc3QgdG8gZGV0ZWN0IGJ1Z2d5IGltcGxlbWVudGF0aW9ucyB0aGF0IGFyZVxuICAgICAgICAvLyBfc2VsZWN0aXZlbHlfIGZvcmdpdmluZyAoc3BlY2lmaWNhbGx5IHdoZW4gdGhlIGxpc3QgaW5jbHVkZXMgYXQgbGVhc3RcbiAgICAgICAgLy8gb25lIHZhbGlkIHNlbGVjdG9yKS5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIHRyZWF0IGNvbXBsZXRlIGxhY2sgb2Ygc3VwcG9ydCBmb3IgYDpoYXMoKWAgYXMgaWYgaXQgd2VyZVxuICAgICAgICAvLyBzcGVjLWNvbXBsaWFudCBzdXBwb3J0LCB3aGljaCBpcyBmaW5lIGJlY2F1c2UgdXNlIG9mIGA6aGFzKClgIGluIHN1Y2hcbiAgICAgICAgLy8gZW52aXJvbm1lbnRzIHdpbGwgZmFpbCBpbiB0aGUgcVNBIHBhdGggYW5kIGZhbGwgYmFjayB0byBqUXVlcnkgdHJhdmVyc2FsXG4gICAgICAgIC8vIGFueXdheS5cbiAgICAgICAgc3VwcG9ydC5jc3NIYXMgPSBhc3NlcnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiOmhhcygqLDpqcWZha2UpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSUQgZmlsdGVyIGFuZCBmaW5kXG4gICAgICAgIGlmIChzdXBwb3J0LmdldEJ5SWQpIHtcbiAgICAgICAgICBFeHByLmZpbHRlci5JRCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgICAgRXhwci5maW5kLklEID0gZnVuY3Rpb24gKGlkLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwpIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPyBbZWxlbV0gOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEV4cHIuZmlsdGVyLklEID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICAgIHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcbiAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG4gICAgICAgICAgRXhwci5maW5kLklEID0gZnVuY3Rpb24gKGlkLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUsIGksIGVsZW1zLFxuICAgICAgICAgICAgICAgIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICAgICAgICBpZiAoZWxlbSkge1xuXG4gICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICBub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbZWxlbV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG4gICAgICAgICAgICAgICAgZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKGlkKTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtc1tpKytdKSkge1xuICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRhZ1xuICAgICAgICBFeHByLmZpbmQuVEFHID0gZnVuY3Rpb24gKHRhZywgY29udGV4dCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTtcblxuICAgICAgICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwodGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2xhc3NcbiAgICAgICAgRXhwci5maW5kLkNMQVNTID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgY29udGV4dCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qIFFTQS9tYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgICAgIC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuICAgICAgICByYnVnZ3lRU0EgPSBbXTtcblxuICAgICAgICAvLyBCdWlsZCBRU0EgcmVnZXhcbiAgICAgICAgLy8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuICAgICAgICBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG5cbiAgICAgICAgICB2YXIgaW5wdXQ7XG5cbiAgICAgICAgICBkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZWwpLmlubmVySFRNTCA9XG4gICAgICAgICAgICBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIicgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG4gICAgICAgICAgICBcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIGRpc2FibGVkPSdkaXNhYmxlZCc+XCIgK1xuICAgICAgICAgICAgXCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG4gICAgICAgICAgLy8gU3VwcG9ydDogaU9TIDw9NyAtIDggb25seVxuICAgICAgICAgIC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHkgaW4gc29tZSBYTUwgZG9jdW1lbnRzXG4gICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IGlPUyA8PTcgLSA4IG9ubHlcbiAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIikubGVuZ3RoKSB7XG4gICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IGlPUyA4IG9ubHlcbiAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG4gICAgICAgICAgLy8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuICAgICAgICAgIGlmICghZWwucXVlcnlTZWxlY3RvckFsbChcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MTA1KywgRmlyZWZveCA8PTEwNCssIFNhZmFyaSA8PTE1LjQrXG4gICAgICAgICAgLy8gSW4gc29tZSBvZiB0aGUgZG9jdW1lbnQga2luZHMsIHRoZXNlIHNlbGVjdG9ycyB3b3VsZG4ndCB3b3JrIG5hdGl2ZWx5LlxuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgT0sgYnV0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3ZSB3YW50IHRvIG1haW50YWluXG4gICAgICAgICAgLy8gaGFuZGxpbmcgdGhlbSB0aHJvdWdoIGpRdWVyeSB0cmF2ZXJzYWwgaW4galF1ZXJ5IDMueC5cbiAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG4gICAgICAgICAgLy8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG4gICAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZChpbnB1dCkuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcIkRcIik7XG5cbiAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG4gICAgICAgICAgLy8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG4gICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MTA1KywgRmlyZWZveCA8PTEwNCssIFNhZmFyaSA8PTE1LjQrXG4gICAgICAgICAgLy8gSW4gc29tZSBvZiB0aGUgZG9jdW1lbnQga2luZHMsIHRoZXNlIHNlbGVjdG9ycyB3b3VsZG4ndCB3b3JrIG5hdGl2ZWx5LlxuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgT0sgYnV0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3ZSB3YW50IHRvIG1haW50YWluXG4gICAgICAgICAgLy8gaGFuZGxpbmcgdGhlbSB0aHJvdWdoIGpRdWVyeSB0cmF2ZXJzYWwgaW4galF1ZXJ5IDMueC5cbiAgICAgICAgICBkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZWwpLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE1IC0gMTgrXG4gICAgICAgICAgLy8gSUUgMTEvRWRnZSBkb24ndCBmaW5kIGVsZW1lbnRzIG9uIGEgYFtuYW1lPScnXWAgcXVlcnkgaW4gc29tZSBjYXNlcy5cbiAgICAgICAgICAvLyBBZGRpbmcgYSB0ZW1wb3JhcnkgYXR0cmlidXRlIHRvIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHNlbGVjdGlvbiB3b3Jrc1xuICAgICAgICAgIC8vIGFyb3VuZCB0aGUgaXNzdWUuXG4gICAgICAgICAgLy8gSW50ZXJlc3RpbmdseSwgSUUgMTAgJiBvbGRlciBkb24ndCBzZWVtIHRvIGhhdmUgdGhlIGlzc3VlLlxuICAgICAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJcIik7XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgIGlmICghZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPScnXVwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIipuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqPVwiICtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghc3VwcG9ydC5jc3NIYXMpIHtcblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSAxMDUgLSAxMTArLCBTYWZhcmkgMTUuNCAtIDE2LjMrXG4gICAgICAgICAgLy8gT3VyIHJlZ3VsYXIgYHRyeS1jYXRjaGAgbWVjaGFuaXNtIGZhaWxzIHRvIGRldGVjdCBuYXRpdmVseS11bnN1cHBvcnRlZFxuICAgICAgICAgIC8vIHBzZXVkby1jbGFzc2VzIGluc2lkZSBgOmhhcygpYCAoc3VjaCBhcyBgOmhhcyg6Y29udGFpbnMoXCJGb29cIikpYClcbiAgICAgICAgICAvLyBpbiBicm93c2VycyB0aGF0IHBhcnNlIHRoZSBgOmhhcygpYCBhcmd1bWVudCBhcyBhIGZvcmdpdmluZyBzZWxlY3RvciBsaXN0LlxuICAgICAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9zZWxlY3RvcnMvI3JlbGF0aW9uYWwgbm93IHJlcXVpcmVzIHRoZSBhcmd1bWVudFxuICAgICAgICAgIC8vIHRvIGJlIHBhcnNlZCB1bmZvcmdpdmluZ2x5LCBidXQgYnJvd3NlcnMgaGF2ZSBub3QgeWV0IGZ1bGx5IGFkanVzdGVkLlxuICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmhhc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cChyYnVnZ3lRU0Euam9pbihcInxcIikpO1xuXG4gICAgICAgIC8qIFNvcnRpbmdcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgICAgIC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcbiAgICAgICAgc29ydE9yZGVyID0gZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgICAgICAgIC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG4gICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gICAgICAgICAgdmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuICAgICAgICAgIGlmIChjb21wYXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG4gICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG4gICAgICAgICAgLy8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG4gICAgICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICBjb21wYXJlID0gKGEub3duZXJEb2N1bWVudCB8fCBhKSA9PSAoYi5vd25lckRvY3VtZW50IHx8IGIpID9cbiAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgOlxuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcbiAgICAgICAgICAgIDE7XG5cbiAgICAgICAgICAvLyBEaXNjb25uZWN0ZWQgbm9kZXNcbiAgICAgICAgICBpZiAoY29tcGFyZSAmIDEgfHxcbiAgICAgICAgICAgICghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhKSA9PT0gY29tcGFyZSkpIHtcblxuICAgICAgICAgICAgLy8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcbiAgICAgICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuICAgICAgICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgaWYgKGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcbiAgICAgICAgICAgICAgZmluZC5jb250YWlucyhwcmVmZXJyZWREb2MsIGEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG4gICAgICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcbiAgICAgICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICAgIGlmIChiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG4gICAgICAgICAgICAgIGZpbmQuY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcbiAgICAgICAgICAgIHJldHVybiBzb3J0SW5wdXQgP1xuICAgICAgICAgICAgICAoaW5kZXhPZi5jYWxsKHNvcnRJbnB1dCwgYSkgLSBpbmRleE9mLmNhbGwoc29ydElucHV0LCBiKSkgOlxuICAgICAgICAgICAgICAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGZpbmQubWF0Y2hlcyA9IGZ1bmN0aW9uIChleHByLCBlbGVtZW50cykge1xuICAgICAgICByZXR1cm4gZmluZChleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBmaW5kLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uIChlbGVtLCBleHByKSB7XG4gICAgICAgIHNldERvY3VtZW50KGVsZW0pO1xuXG4gICAgICAgIGlmIChkb2N1bWVudElzSFRNTCAmJlxuICAgICAgICAgICFub25uYXRpdmVTZWxlY3RvckNhY2hlW2V4cHIgKyBcIiBcIl0gJiZcbiAgICAgICAgICAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoZXhwcikpKSB7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJldCA9IG1hdGNoZXMuY2FsbChlbGVtLCBleHByKTtcblxuICAgICAgICAgICAgLy8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuICAgICAgICAgICAgaWYgKHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cbiAgICAgICAgICAgICAgLy8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcbiAgICAgICAgICAgICAgLy8gZnJhZ21lbnQgaW4gSUUgOVxuICAgICAgICAgICAgICBlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbm9ubmF0aXZlU2VsZWN0b3JDYWNoZShleHByLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmluZChleHByLCBkb2N1bWVudCwgbnVsbCwgW2VsZW1dKS5sZW5ndGggPiAwO1xuICAgICAgfTtcblxuICAgICAgZmluZC5jb250YWlucyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVtKSB7XG5cbiAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuICAgICAgICAvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcbiAgICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgIGlmICgoY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQpICE9IGRvY3VtZW50KSB7XG4gICAgICAgICAgc2V0RG9jdW1lbnQoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5jb250YWlucyhjb250ZXh0LCBlbGVtKTtcbiAgICAgIH07XG5cblxuICAgICAgZmluZC5hdHRyID0gZnVuY3Rpb24gKGVsZW0sIG5hbWUpIHtcblxuICAgICAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG4gICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuICAgICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgaWYgKChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkgIT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBzZXREb2N1bWVudChlbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVtuYW1lLnRvTG93ZXJDYXNlKCldLFxuXG4gICAgICAgICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSB0cmFjLTEzODA3KVxuICAgICAgICAgIHZhbCA9IGZuICYmIGhhc093bi5jYWxsKEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpKSA/XG4gICAgICAgICAgICBmbihlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwpIDpcbiAgICAgICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgfTtcblxuICAgICAgZmluZC5lcnJvciA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gICAgICAgKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICAgICAgICovXG4gICAgICBqUXVlcnkudW5pcXVlU29ydCA9IGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgIGR1cGxpY2F0ZXMgPSBbXSxcbiAgICAgICAgICBqID0gMCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgICAvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjArXG4gICAgICAgIC8vIFRlc3RpbmcgZm9yIGRldGVjdGluZyBkdXBsaWNhdGVzIGlzIHVucHJlZGljdGFibGUgc28gaW5zdGVhZCBhc3N1bWUgd2UgY2FuJ3RcbiAgICAgICAgLy8gZGVwZW5kIG9uIGR1cGxpY2F0ZSBkZXRlY3Rpb24gaW4gYWxsIGJyb3dzZXJzIHdpdGhvdXQgYSBzdGFibGUgc29ydC5cbiAgICAgICAgaGFzRHVwbGljYXRlID0gIXN1cHBvcnQuc29ydFN0YWJsZTtcbiAgICAgICAgc29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiBzbGljZS5jYWxsKHJlc3VsdHMsIDApO1xuICAgICAgICBzb3J0LmNhbGwocmVzdWx0cywgc29ydE9yZGVyKTtcblxuICAgICAgICBpZiAoaGFzRHVwbGljYXRlKSB7XG4gICAgICAgICAgd2hpbGUgKChlbGVtID0gcmVzdWx0c1tpKytdKSkge1xuICAgICAgICAgICAgaWYgKGVsZW0gPT09IHJlc3VsdHNbaV0pIHtcbiAgICAgICAgICAgICAgaiA9IGR1cGxpY2F0ZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwocmVzdWx0cywgZHVwbGljYXRlc1tqXSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG4gICAgICAgIHNvcnRJbnB1dCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9O1xuXG4gICAgICBqUXVlcnkuZm4udW5pcXVlU29ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGpRdWVyeS51bmlxdWVTb3J0KHNsaWNlLmFwcGx5KHRoaXMpKSk7XG4gICAgICB9O1xuXG4gICAgICBFeHByID0galF1ZXJ5LmV4cHIgPSB7XG5cbiAgICAgICAgLy8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG4gICAgICAgIGNhY2hlTGVuZ3RoOiA1MCxcblxuICAgICAgICBjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuICAgICAgICBtYXRjaDogbWF0Y2hFeHByLFxuXG4gICAgICAgIGF0dHJIYW5kbGU6IHt9LFxuXG4gICAgICAgIGZpbmQ6IHt9LFxuXG4gICAgICAgIHJlbGF0aXZlOiB7XG4gICAgICAgICAgXCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcbiAgICAgICAgICBcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG4gICAgICAgICAgXCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuICAgICAgICAgIFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlRmlsdGVyOiB7XG4gICAgICAgICAgQVRUUjogZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuXG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuICAgICAgICAgICAgbWF0Y2hbM10gPSAobWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIilcbiAgICAgICAgICAgICAgLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hbMl0gPT09IFwifj1cIikge1xuICAgICAgICAgICAgICBtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDAsIDQpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBDSElMRDogZnVuY3Rpb24gKG1hdGNoKSB7XG5cbiAgICAgICAgICAgIC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuICAgICAgICAgICAgICAxIHR5cGUgKG9ubHl8bnRofC4uLilcbiAgICAgICAgICAgICAgMiB3aGF0IChjaGlsZHxvZi10eXBlKVxuICAgICAgICAgICAgICAzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuICAgICAgICAgICAgICA0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcbiAgICAgICAgICAgICAgNSBzaWduIG9mIHhuLWNvbXBvbmVudFxuICAgICAgICAgICAgICA2IHggb2YgeG4tY29tcG9uZW50XG4gICAgICAgICAgICAgIDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuICAgICAgICAgICAgICA4IHkgb2YgeS1jb21wb25lbnRcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaFsxXS5zbGljZSgwLCAzKSA9PT0gXCJudGhcIikge1xuXG4gICAgICAgICAgICAgIC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG4gICAgICAgICAgICAgIGlmICghbWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmaW5kLmVycm9yKG1hdGNoWzBdKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuICAgICAgICAgICAgICAvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG4gICAgICAgICAgICAgIG1hdGNoWzRdID0gKyhtYXRjaFs0XSA/XG4gICAgICAgICAgICAgICAgbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOlxuICAgICAgICAgICAgICAgIDIgKiAobWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBtYXRjaFs1XSA9ICsoKG1hdGNoWzddICsgbWF0Y2hbOF0pIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiKTtcblxuICAgICAgICAgICAgICAvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgZmluZC5lcnJvcihtYXRjaFswXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgUFNFVURPOiBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBleGNlc3MsXG4gICAgICAgICAgICAgIHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hFeHByLkNISUxELnRlc3QobWF0Y2hbMF0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgIG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuICAgICAgICAgICAgICAvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QodW5xdW90ZWQpICYmXG5cbiAgICAgICAgICAgICAgLy8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcbiAgICAgICAgICAgICAgKGV4Y2VzcyA9IHRva2VuaXplKHVucXVvdGVkLCB0cnVlKSkgJiZcblxuICAgICAgICAgICAgICAvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgICAgICAgKGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcykgLSB1bnF1b3RlZC5sZW5ndGgpKSB7XG5cbiAgICAgICAgICAgICAgLy8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcbiAgICAgICAgICAgICAgbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSgwLCBleGNlc3MpO1xuICAgICAgICAgICAgICBtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKDAsIGV4Y2Vzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDAsIDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXI6IHtcblxuICAgICAgICAgIFRBRzogZnVuY3Rpb24gKG5vZGVOYW1lU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZE5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cbiAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZU5hbWUoZWxlbSwgZXhwZWN0ZWROb2RlTmFtZSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIENMQVNTOiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbY2xhc3NOYW1lICsgXCIgXCJdO1xuXG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybiB8fFxuICAgICAgICAgICAgICAocGF0dGVybiA9IG5ldyBSZWdFeHAoXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArXG4gICAgICAgICAgICAgICAgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIikpICYmXG4gICAgICAgICAgICAgIGNsYXNzQ2FjaGUoY2xhc3NOYW1lLCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QoXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHxcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fFxuICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBBVFRSOiBmdW5jdGlvbiAobmFtZSwgb3BlcmF0b3IsIGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZpbmQuYXR0cihlbGVtLCBuYW1lKTtcblxuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIW9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcIjtcblxuICAgICAgICAgICAgICBpZiAob3BlcmF0b3IgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gY2hlY2s7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSBcIiE9XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICE9PSBjaGVjaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3BlcmF0b3IgPT09IFwiXj1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVjayAmJiByZXN1bHQuaW5kZXhPZihjaGVjaykgPT09IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSBcIio9XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoY2hlY2spID4gLTE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSBcIiQ9XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKC1jaGVjay5sZW5ndGgpID09PSBjaGVjaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3BlcmF0b3IgPT09IFwifj1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXCIgXCIgKyByZXN1bHQucmVwbGFjZShyd2hpdGVzcGFjZSwgXCIgXCIpICsgXCIgXCIpXG4gICAgICAgICAgICAgICAgICAuaW5kZXhPZihjaGVjaykgPiAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAob3BlcmF0b3IgPT09IFwifD1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSgwLCBjaGVjay5sZW5ndGggKyAxKSA9PT0gY2hlY2sgKyBcIi1cIjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIENISUxEOiBmdW5jdGlvbiAodHlwZSwgd2hhdCwgX2FyZ3VtZW50LCBmaXJzdCwgbGFzdCkge1xuICAgICAgICAgICAgdmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoMCwgMykgIT09IFwibnRoXCIsXG4gICAgICAgICAgICAgIGZvcndhcmQgPSB0eXBlLnNsaWNlKC00KSAhPT0gXCJsYXN0XCIsXG4gICAgICAgICAgICAgIG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cbiAgICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0sIF9jb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG4gICAgICAgICAgICAgICAgICBkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuICAgICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgbmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICB1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcbiAgICAgICAgICAgICAgICAgIGRpZmYgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgLy8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuICAgICAgICAgICAgICAgICAgaWYgKHNpbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZVtkaXJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mVHlwZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lKG5vZGUsIG5hbWUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gW2ZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGRdO1xuXG4gICAgICAgICAgICAgICAgICAvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuICAgICAgICAgICAgICAgICAgaWYgKGZvcndhcmQgJiYgdXNlQ2FjaGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IHBhcmVudFtleHBhbmRvXSB8fCAocGFyZW50W2V4cGFuZG9dID0ge30pO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IG91dGVyQ2FjaGVbdHlwZV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xuICAgICAgICAgICAgICAgICAgICBkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWzJdO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzW25vZGVJbmRleF07XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlW2Rpcl0gfHxcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgKGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGVbdHlwZV0gPSBbZGlycnVucywgbm9kZUluZGV4LCBkaWZmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICBpZiAodXNlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gZWxlbVtleHBhbmRvXSB8fCAoZWxlbVtleHBhbmRvXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IG91dGVyQ2FjaGVbdHlwZV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgZGlmZiA9IG5vZGVJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlW2Rpcl0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob2ZUeXBlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWUobm9kZSwgbmFtZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVUeXBlID09PSAxKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICArK2RpZmYpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlW2V4cGFuZG9dIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9kZVtleHBhbmRvXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlW3R5cGVdID0gW2RpcnJ1bnMsIGRpZmZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuICAgICAgICAgICAgICAgICAgZGlmZiAtPSBsYXN0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8IChkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgUFNFVURPOiBmdW5jdGlvbiAocHNldWRvLCBhcmd1bWVudCkge1xuXG4gICAgICAgICAgICAvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG4gICAgICAgICAgICAvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuICAgICAgICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgICAgIGZuID0gRXhwci5wc2V1ZG9zW3BzZXVkb10gfHwgRXhwci5zZXRGaWx0ZXJzW3BzZXVkby50b0xvd2VyQ2FzZSgpXSB8fFxuICAgICAgICAgICAgICAgIGZpbmQuZXJyb3IoXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvKTtcblxuICAgICAgICAgICAgLy8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuICAgICAgICAgICAgLy8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGp1c3QgYXMgalF1ZXJ5IGRvZXNcbiAgICAgICAgICAgIGlmIChmbltleHBhbmRvXSkge1xuICAgICAgICAgICAgICByZXR1cm4gZm4oYXJndW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcbiAgICAgICAgICAgIGlmIChmbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSBbcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50XTtcbiAgICAgICAgICAgICAgcmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShwc2V1ZG8udG9Mb3dlckNhc2UoKSkgP1xuICAgICAgICAgICAgICAgIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgdmFyIGlkeCxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZuKHNlZWQsIGFyZ3VtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZHggPSBpbmRleE9mLmNhbGwoc2VlZCwgbWF0Y2hlZFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIHNlZWRbaWR4XSA9ICEobWF0Y2hlc1tpZHhdID0gbWF0Y2hlZFtpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZm4oZWxlbSwgMCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwc2V1ZG9zOiB7XG5cbiAgICAgICAgICAvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3NcbiAgICAgICAgICBub3Q6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblxuICAgICAgICAgICAgLy8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG4gICAgICAgICAgICAvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IFtdLFxuICAgICAgICAgICAgICByZXN1bHRzID0gW10sXG4gICAgICAgICAgICAgIG1hdGNoZXIgPSBjb21waWxlKHNlbGVjdG9yLnJlcGxhY2UocnRyaW1DU1MsIFwiJDFcIikpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcltleHBhbmRvXSA/XG4gICAgICAgICAgICAgIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgbWF0Y2hlcywgX2NvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgICAgdW5tYXRjaGVkID0gbWF0Y2hlcihzZWVkLCBudWxsLCB4bWwsIFtdKSxcbiAgICAgICAgICAgICAgICAgIGkgPSBzZWVkLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSB1bm1hdGNoZWRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0sIF9jb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICAgICAgICBpbnB1dFswXSA9IGVsZW07XG4gICAgICAgICAgICAgICAgbWF0Y2hlcihpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzKTtcblxuICAgICAgICAgICAgICAgIC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL2lzc3Vlcy8yOTkpXG4gICAgICAgICAgICAgICAgaW5wdXRbMF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiAhcmVzdWx0cy5wb3AoKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcblxuICAgICAgICAgIGhhczogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5kKHNlbGVjdG9yLCBlbGVtKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcblxuICAgICAgICAgIGNvbnRhaW5zOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoZWxlbS50ZXh0Q29udGVudCB8fCBqUXVlcnkudGV4dChlbGVtKSkuaW5kZXhPZih0ZXh0KSA+IC0xO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcblxuICAgICAgICAgIC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuICAgICAgICAgIC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG4gICAgICAgICAgLy8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcbiAgICAgICAgICAvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuICAgICAgICAgIC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAgICAgIC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcbiAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuICAgICAgICAgIGxhbmc6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAobGFuZykge1xuXG4gICAgICAgICAgICAvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG4gICAgICAgICAgICBpZiAoIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSkge1xuICAgICAgICAgICAgICBmaW5kLmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhbmcgPSBsYW5nLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1MYW5nO1xuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cbiAgICAgICAgICAgICAgICAgIGVsZW0ubGFuZyA6XG4gICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkpIHtcblxuICAgICAgICAgICAgICAgICAgZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YobGFuZyArIFwiLVwiKSA9PT0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gd2hpbGUgKChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcblxuICAgICAgICAgIC8vIE1pc2NlbGxhbmVvdXNcbiAgICAgICAgICB0YXJnZXQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgICAgICAgIHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoMSkgPT09IGVsZW0uaWQ7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHJvb3Q6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBmb2N1czogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmXG4gICAgICAgICAgICAgIGRvY3VtZW50Lmhhc0ZvY3VzKCkgJiZcbiAgICAgICAgICAgICAgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIEJvb2xlYW4gcHJvcGVydGllc1xuICAgICAgICAgIGVuYWJsZWQ6IGNyZWF0ZURpc2FibGVkUHNldWRvKGZhbHNlKSxcbiAgICAgICAgICBkaXNhYmxlZDogY3JlYXRlRGlzYWJsZWRQc2V1ZG8odHJ1ZSksXG5cbiAgICAgICAgICBjaGVja2VkOiBmdW5jdGlvbiAoZWxlbSkge1xuXG4gICAgICAgICAgICAvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuICAgICAgICAgICAgcmV0dXJuIChub2RlTmFtZShlbGVtLCBcImlucHV0XCIpICYmICEhZWxlbS5jaGVja2VkKSB8fFxuICAgICAgICAgICAgICAobm9kZU5hbWUoZWxlbSwgXCJvcHRpb25cIikgJiYgISFlbGVtLnNlbGVjdGVkKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2VsZWN0ZWQ6IGZ1bmN0aW9uIChlbGVtKSB7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTErXG4gICAgICAgICAgICAvLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbiAgICAgICAgICAgIC8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byB0cmVhdCB0aGUgZGVmYXVsdCBvcHRpb24gYXNcbiAgICAgICAgICAgIC8vIHNlbGVjdGVkIHdoZW4gaW4gYW4gb3B0Z3JvdXAuXG4gICAgICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBDb250ZW50c1xuICAgICAgICAgIGVtcHR5OiBmdW5jdGlvbiAoZWxlbSkge1xuXG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cbiAgICAgICAgICAgIC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcbiAgICAgICAgICAgIC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG4gICAgICAgICAgICAvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG4gICAgICAgICAgICBmb3IgKGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlIDwgNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHBhcmVudDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiAhRXhwci5wc2V1ZG9zLmVtcHR5KGVsZW0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBFbGVtZW50L2lucHV0IHR5cGVzXG4gICAgICAgICAgaGVhZGVyOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHJoZWFkZXIudGVzdChlbGVtLm5vZGVOYW1lKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gcmlucHV0cy50ZXN0KGVsZW0ubm9kZU5hbWUpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBidXR0b246IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZU5hbWUoZWxlbSwgXCJpbnB1dFwiKSAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHxcbiAgICAgICAgICAgICAgbm9kZU5hbWUoZWxlbSwgXCJidXR0b25cIik7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHRleHQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgICAgIHJldHVybiBub2RlTmFtZShlbGVtLCBcImlucHV0XCIpICYmIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8MTAgb25seVxuICAgICAgICAgICAgICAvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyXG4gICAgICAgICAgICAgIC8vIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuICAgICAgICAgICAgICAoKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuICAgICAgICAgIGZpcnN0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbMF07XG4gICAgICAgICAgfSksXG5cbiAgICAgICAgICBsYXN0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChfbWF0Y2hJbmRleGVzLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGVuZ3RoIC0gMV07XG4gICAgICAgICAgfSksXG5cbiAgICAgICAgICBlcTogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAoX21hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFthcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50XTtcbiAgICAgICAgICB9KSxcblxuICAgICAgICAgIGV2ZW46IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKG1hdGNoSW5kZXhlcywgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICB9KSxcblxuICAgICAgICAgIG9kZDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAobWF0Y2hJbmRleGVzLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgbHQ6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgIGlmIChhcmd1bWVudCA8IDApIHtcbiAgICAgICAgICAgICAgaSA9IGFyZ3VtZW50ICsgbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICBpID0gbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaSA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICB9KSxcblxuICAgICAgICAgIGd0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcbiAgICAgICAgICAgIGZvciAoOyArK2kgPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBFeHByLnBzZXVkb3MubnRoID0gRXhwci5wc2V1ZG9zLmVxO1xuXG4gICAgICAvLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuICAgICAgZm9yIChpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSkge1xuICAgICAgICBFeHByLnBzZXVkb3NbaV0gPSBjcmVhdGVJbnB1dFBzZXVkbyhpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSkge1xuICAgICAgICBFeHByLnBzZXVkb3NbaV0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuICAgICAgZnVuY3Rpb24gc2V0RmlsdGVycygpIHsgfVxuICAgICAgc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG4gICAgICBFeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG4gICAgICBmdW5jdGlvbiB0b2tlbml6ZShzZWxlY3RvciwgcGFyc2VPbmx5KSB7XG4gICAgICAgIHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuICAgICAgICAgIHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG4gICAgICAgICAgY2FjaGVkID0gdG9rZW5DYWNoZVtzZWxlY3RvciArIFwiIFwiXTtcblxuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBzb0ZhciA9IHNlbGVjdG9yO1xuICAgICAgICBncm91cHMgPSBbXTtcbiAgICAgICAgcHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG4gICAgICAgIHdoaWxlIChzb0Zhcikge1xuXG4gICAgICAgICAgLy8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuICAgICAgICAgIGlmICghbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyhzb0ZhcikpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcblxuICAgICAgICAgICAgICAvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuICAgICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoWzBdLmxlbmd0aCkgfHwgc29GYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncm91cHMucHVzaCgodG9rZW5zID0gW10pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXRjaGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBDb21iaW5hdG9yc1xuICAgICAgICAgIGlmICgobWF0Y2ggPSBybGVhZGluZ0NvbWJpbmF0b3IuZXhlYyhzb0ZhcikpKSB7XG4gICAgICAgICAgICBtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoZWQsXG5cbiAgICAgICAgICAgICAgLy8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG4gICAgICAgICAgICAgIHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UocnRyaW1DU1MsIFwiIFwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoZWQubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBGaWx0ZXJzXG4gICAgICAgICAgZm9yICh0eXBlIGluIEV4cHIuZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKG1hdGNoID0gbWF0Y2hFeHByW3R5cGVdLmV4ZWMoc29GYXIpKSAmJiAoIXByZUZpbHRlcnNbdHlwZV0gfHxcbiAgICAgICAgICAgICAgKG1hdGNoID0gcHJlRmlsdGVyc1t0eXBlXShtYXRjaCkpKSkge1xuICAgICAgICAgICAgICBtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBtYXRjaGVkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgbWF0Y2hlczogbWF0Y2hcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UobWF0Y2hlZC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG4gICAgICAgIC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuICAgICAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcbiAgICAgICAgaWYgKHBhcnNlT25seSkge1xuICAgICAgICAgIHJldHVybiBzb0Zhci5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc29GYXIgP1xuICAgICAgICAgIGZpbmQuZXJyb3Ioc2VsZWN0b3IpIDpcblxuICAgICAgICAgIC8vIENhY2hlIHRoZSB0b2tlbnNcbiAgICAgICAgICB0b2tlbkNhY2hlKHNlbGVjdG9yLCBncm91cHMpLnNsaWNlKDApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0b1NlbGVjdG9yKHRva2Vucykge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgbGVuID0gdG9rZW5zLmxlbmd0aCxcbiAgICAgICAgICBzZWxlY3RvciA9IFwiXCI7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRDb21iaW5hdG9yKG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UpIHtcbiAgICAgICAgdmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuICAgICAgICAgIHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG4gICAgICAgICAga2V5ID0gc2tpcCB8fCBkaXIsXG4gICAgICAgICAgY2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcbiAgICAgICAgICBkb25lTmFtZSA9IGRvbmUrKztcblxuICAgICAgICByZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cbiAgICAgICAgICAvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcbiAgICAgICAgICBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtW2Rpcl0pKSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcihlbGVtLCBjb250ZXh0LCB4bWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSA6XG5cbiAgICAgICAgICAvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcbiAgICAgICAgICBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICB2YXIgb2xkQ2FjaGUsIG91dGVyQ2FjaGUsXG4gICAgICAgICAgICAgIG5ld0NhY2hlID0gW2RpcnJ1bnMsIGRvbmVOYW1lXTtcblxuICAgICAgICAgICAgLy8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG4gICAgICAgICAgICBpZiAoeG1sKSB7XG4gICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW1bZGlyXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcihlbGVtLCBjb250ZXh0LCB4bWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gZWxlbVtkaXJdKSkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBlbGVtW2V4cGFuZG9dIHx8IChlbGVtW2V4cGFuZG9dID0ge30pO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoc2tpcCAmJiBub2RlTmFtZShlbGVtLCBza2lwKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbVtkaXJdIHx8IGVsZW07XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChvbGRDYWNoZSA9IG91dGVyQ2FjaGVba2V5XSkgJiZcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbMV0gPT09IGRvbmVOYW1lKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuZXdDYWNoZVsyXSA9IG9sZENhY2hlWzJdKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlW2tleV0gPSBuZXdDYWNoZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKChuZXdDYWNoZVsyXSA9IG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cbiAgICAgICAgICBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICB2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgaWYgKCFtYXRjaGVyc1tpXShlbGVtLCBjb250ZXh0LCB4bWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IDpcbiAgICAgICAgICBtYXRjaGVyc1swXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyhzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGZpbmQoc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29uZGVuc2UodW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgIG5ld1VubWF0Y2hlZCA9IFtdLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG4gICAgICAgICAgbWFwcGVkID0gbWFwICE9IG51bGw7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICgoZWxlbSA9IHVubWF0Y2hlZFtpXSkpIHtcbiAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlbGVtLCBjb250ZXh0LCB4bWwpKSB7XG4gICAgICAgICAgICAgIG5ld1VubWF0Y2hlZC5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgbWFwLnB1c2goaSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3VW5tYXRjaGVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRNYXRjaGVyKHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3Rvcikge1xuICAgICAgICBpZiAocG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlcltleHBhbmRvXSkge1xuICAgICAgICAgIHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKHBvc3RGaWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3N0RmluZGVyICYmICFwb3N0RmluZGVyW2V4cGFuZG9dKSB7XG4gICAgICAgICAgcG9zdEZpbmRlciA9IHNldE1hdGNoZXIocG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICB2YXIgdGVtcCwgaSwgZWxlbSwgbWF0Y2hlck91dCxcbiAgICAgICAgICAgIHByZU1hcCA9IFtdLFxuICAgICAgICAgICAgcG9zdE1hcCA9IFtdLFxuICAgICAgICAgICAgcHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuICAgICAgICAgICAgLy8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcbiAgICAgICAgICAgIGVsZW1zID0gc2VlZCB8fFxuICAgICAgICAgICAgICBtdWx0aXBsZUNvbnRleHRzKHNlbGVjdG9yIHx8IFwiKlwiLFxuICAgICAgICAgICAgICAgIGNvbnRleHQubm9kZVR5cGUgPyBbY29udGV4dF0gOiBjb250ZXh0LCBbXSksXG5cbiAgICAgICAgICAgIC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuICAgICAgICAgICAgbWF0Y2hlckluID0gcHJlRmlsdGVyICYmIChzZWVkIHx8ICFzZWxlY3RvcikgP1xuICAgICAgICAgICAgICBjb25kZW5zZShlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCkgOlxuICAgICAgICAgICAgICBlbGVtcztcblxuICAgICAgICAgIGlmIChtYXRjaGVyKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyXG4gICAgICAgICAgICAvLyBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuICAgICAgICAgICAgbWF0Y2hlck91dCA9IHBvc3RGaW5kZXIgfHwgKHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyKSA/XG5cbiAgICAgICAgICAgICAgLy8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgIFtdIDpcblxuICAgICAgICAgICAgICAvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcbiAgICAgICAgICAgICAgcmVzdWx0cztcblxuICAgICAgICAgICAgLy8gRmluZCBwcmltYXJ5IG1hdGNoZXNcbiAgICAgICAgICAgIG1hdGNoZXIobWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaGVyT3V0ID0gbWF0Y2hlckluO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFwcGx5IHBvc3RGaWx0ZXJcbiAgICAgICAgICBpZiAocG9zdEZpbHRlcikge1xuICAgICAgICAgICAgdGVtcCA9IGNvbmRlbnNlKG1hdGNoZXJPdXQsIHBvc3RNYXApO1xuICAgICAgICAgICAgcG9zdEZpbHRlcih0ZW1wLCBbXSwgY29udGV4dCwgeG1sKTtcblxuICAgICAgICAgICAgLy8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuICAgICAgICAgICAgaSA9IHRlbXAubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICBpZiAoKGVsZW0gPSB0ZW1wW2ldKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXJPdXRbcG9zdE1hcFtpXV0gPSAhKG1hdGNoZXJJbltwb3N0TWFwW2ldXSA9IGVsZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZWQpIHtcbiAgICAgICAgICAgIGlmIChwb3N0RmluZGVyIHx8IHByZUZpbHRlcikge1xuICAgICAgICAgICAgICBpZiAocG9zdEZpbmRlcikge1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG4gICAgICAgICAgICAgICAgdGVtcCA9IFtdO1xuICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIHRlbXAucHVzaCgobWF0Y2hlckluW2ldID0gZWxlbSkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3N0RmluZGVyKG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcbiAgICAgICAgICAgICAgaSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcbiAgICAgICAgICAgICAgICAgICh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YuY2FsbChzZWVkLCBlbGVtKSA6IHByZU1hcFtpXSkgPiAtMSkge1xuXG4gICAgICAgICAgICAgICAgICBzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG4gICAgICAgICAgICAgIG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQuc3BsaWNlKHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCkgOlxuICAgICAgICAgICAgICAgIG1hdGNoZXJPdXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocG9zdEZpbmRlcikge1xuICAgICAgICAgICAgICBwb3N0RmluZGVyKG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIG1hdGNoZXJPdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKHRva2Vucykge1xuICAgICAgICB2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuICAgICAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgbGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVt0b2tlbnNbMF0udHlwZV0sXG4gICAgICAgICAgaW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcbiAgICAgICAgICBpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cbiAgICAgICAgICAvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuICAgICAgICAgIG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG4gICAgICAgICAgfSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSksXG4gICAgICAgICAgbWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvcihmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbChjaGVja0NvbnRleHQsIGVsZW0pID4gLTE7XG4gICAgICAgICAgfSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSksXG4gICAgICAgICAgbWF0Y2hlcnMgPSBbZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcbiAgICAgICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuICAgICAgICAgICAgLy8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgdmFyIHJldCA9ICghbGVhZGluZ1JlbGF0aXZlICYmICh4bWwgfHwgY29udGV4dCAhPSBvdXRlcm1vc3RDb250ZXh0KSkgfHwgKFxuICAgICAgICAgICAgICAoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuICAgICAgICAgICAgICAgIG1hdGNoQ29udGV4dChlbGVtLCBjb250ZXh0LCB4bWwpIDpcbiAgICAgICAgICAgICAgICBtYXRjaEFueUNvbnRleHQoZWxlbSwgY29udGV4dCwgeG1sKSk7XG5cbiAgICAgICAgICAgIC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50XG4gICAgICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL2lzc3Vlcy8yOTkpXG4gICAgICAgICAgICBjaGVja0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVt0b2tlbnNbaV0udHlwZV0pKSB7XG4gICAgICAgICAgICBtYXRjaGVycyA9IFthZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKSwgbWF0Y2hlcildO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaGVyID0gRXhwci5maWx0ZXJbdG9rZW5zW2ldLnR5cGVdLmFwcGx5KG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzKTtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcbiAgICAgICAgICAgIGlmIChtYXRjaGVyW2V4cGFuZG9dKSB7XG5cbiAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG4gICAgICAgICAgICAgIGogPSArK2k7XG4gICAgICAgICAgICAgIGZvciAoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRXhwci5yZWxhdGl2ZVt0b2tlbnNbal0udHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc2V0TWF0Y2hlcihcbiAgICAgICAgICAgICAgICBpID4gMSAmJiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycyksXG4gICAgICAgICAgICAgICAgaSA+IDEgJiYgdG9TZWxlY3RvcihcblxuICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5zbGljZSgwLCBpIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbaSAtIDJdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG4gICAgICAgICAgICAgICAgKS5yZXBsYWNlKHJ0cmltQ1NTLCBcIiQxXCIpLFxuICAgICAgICAgICAgICAgIG1hdGNoZXIsXG4gICAgICAgICAgICAgICAgaSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zLnNsaWNlKGksIGopKSxcbiAgICAgICAgICAgICAgICBqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoaikpKSxcbiAgICAgICAgICAgICAgICBqIDwgbGVuICYmIHRvU2VsZWN0b3IodG9rZW5zKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hlcnMucHVzaChtYXRjaGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycykge1xuICAgICAgICB2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgIGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgIHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uIChzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCkge1xuICAgICAgICAgICAgdmFyIGVsZW0sIGosIG1hdGNoZXIsXG4gICAgICAgICAgICAgIG1hdGNoZWRDb3VudCA9IDAsXG4gICAgICAgICAgICAgIGkgPSBcIjBcIixcbiAgICAgICAgICAgICAgdW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcbiAgICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IFtdLFxuICAgICAgICAgICAgICBjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblxuICAgICAgICAgICAgICAvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG4gICAgICAgICAgICAgIGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kLlRBRyhcIipcIiwgb3V0ZXJtb3N0KSxcblxuICAgICAgICAgICAgICAvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuICAgICAgICAgICAgICBkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcbiAgICAgICAgICAgICAgbGVuID0gZWxlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAob3V0ZXJtb3N0KSB7XG5cbiAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG4gICAgICAgICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuICAgICAgICAgICAgICAvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBpT1MgPD03IC0gOSBvbmx5XG4gICAgICAgICAgICAvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vIGVsZW1lbnRzIGJ5IGlkLiAoc2VlIHRyYWMtMTQxNDIpXG4gICAgICAgICAgICBmb3IgKDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoYnlFbGVtZW50ICYmIGVsZW0pIHtcbiAgICAgICAgICAgICAgICBqID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuICAgICAgICAgICAgICAgIC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuICAgICAgICAgICAgICAgIC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPSBkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoZWxlbSk7XG4gICAgICAgICAgICAgICAgICB4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXIoZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwocmVzdWx0cywgZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3V0ZXJtb3N0KSB7XG4gICAgICAgICAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG4gICAgICAgICAgICAgIGlmIChieVNldCkge1xuXG4gICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuICAgICAgICAgICAgICAgIGlmICgoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG4gICAgICAgICAgICAgICAgaWYgKHNlZWQpIHtcbiAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZC5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG4gICAgICAgICAgICAvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuICAgICAgICAgICAgbWF0Y2hlZENvdW50ICs9IGk7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuICAgICAgICAgICAgLy8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuICAgICAgICAgICAgLy8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG4gICAgICAgICAgICAvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuICAgICAgICAgICAgLy8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuICAgICAgICAgICAgLy8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG4gICAgICAgICAgICAvLyBudW1lcmljYWxseSB6ZXJvLlxuICAgICAgICAgICAgaWYgKGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCkge1xuICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVyKHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChzZWVkKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcbiAgICAgICAgICAgICAgICBzZXRNYXRjaGVkID0gY29uZGVuc2Uoc2V0TWF0Y2hlZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG4gICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc2V0TWF0Y2hlZCk7XG5cbiAgICAgICAgICAgICAgLy8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG4gICAgICAgICAgICAgIGlmIChvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgKG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCkgPiAxKSB7XG5cbiAgICAgICAgICAgICAgICBqUXVlcnkudW5pcXVlU29ydChyZXN1bHRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcbiAgICAgICAgICAgIGlmIChvdXRlcm1vc3QpIHtcbiAgICAgICAgICAgICAgZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG4gICAgICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdW5tYXRjaGVkO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGJ5U2V0ID9cbiAgICAgICAgICBtYXJrRnVuY3Rpb24oc3VwZXJNYXRjaGVyKSA6XG4gICAgICAgICAgc3VwZXJNYXRjaGVyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb21waWxlKHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICBzZXRNYXRjaGVycyA9IFtdLFxuICAgICAgICAgIGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuICAgICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbc2VsZWN0b3IgKyBcIiBcIl07XG5cbiAgICAgICAgaWYgKCFjYWNoZWQpIHtcblxuICAgICAgICAgIC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIG1hdGNoID0gdG9rZW5pemUoc2VsZWN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpID0gbWF0Y2gubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKG1hdGNoW2ldKTtcbiAgICAgICAgICAgIGlmIChjYWNoZWRbZXhwYW5kb10pIHtcbiAgICAgICAgICAgICAgc2V0TWF0Y2hlcnMucHVzaChjYWNoZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzLnB1c2goY2FjaGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cbiAgICAgICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlKHNlbGVjdG9yLFxuICAgICAgICAgICAgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMpKTtcblxuICAgICAgICAgIC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuICAgICAgICAgIGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBqUXVlcnkncyBjb21waWxlZFxuICAgICAgICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICAgICAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAgICAgICAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIGpRdWVyeSBzZWxlY3RvciBjb21waWxlXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICAgICAgICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gc2VsZWN0KHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKSB7XG4gICAgICAgIHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuICAgICAgICAgIGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG4gICAgICAgICAgbWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSgoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikpO1xuXG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG4gICAgICAgIC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG4gICAgICAgIC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcbiAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgICAgLy8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcbiAgICAgICAgICB0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKDApO1xuICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuICAgICAgICAgICAgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlW3Rva2Vuc1sxXS50eXBlXSkge1xuXG4gICAgICAgICAgICBjb250ZXh0ID0gKEV4cHIuZmluZC5JRChcbiAgICAgICAgICAgICAgdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSxcbiAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgKSB8fCBbXSlbMF07XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cbiAgICAgICAgICAgICAgLy8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21waWxlZCkge1xuICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuICAgICAgICAgIGkgPSBtYXRjaEV4cHIubmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3IpID8gMCA6IHRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgICAgIC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3JcbiAgICAgICAgICAgIGlmIChFeHByLnJlbGF0aXZlWyh0eXBlID0gdG9rZW4udHlwZSldKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChmaW5kID0gRXhwci5maW5kW3R5cGVdKSkge1xuXG4gICAgICAgICAgICAgIC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuICAgICAgICAgICAgICBpZiAoKHNlZWQgPSBmaW5kKFxuICAgICAgICAgICAgICAgIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksXG4gICAgICAgICAgICAgICAgcnNpYmxpbmcudGVzdCh0b2tlbnNbMF0udHlwZSkgJiZcbiAgICAgICAgICAgICAgICB0ZXN0Q29udGV4dChjb250ZXh0LnBhcmVudE5vZGUpIHx8IGNvbnRleHRcbiAgICAgICAgICAgICAgKSkpIHtcblxuICAgICAgICAgICAgICAgIC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuICAgICAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKHRva2Vucyk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBzZWVkKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgIC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcbiAgICAgICAgKGNvbXBpbGVkIHx8IGNvbXBpbGUoc2VsZWN0b3IsIG1hdGNoKSkoXG4gICAgICAgICAgc2VlZCxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICFkb2N1bWVudElzSFRNTCxcbiAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3Qoc2VsZWN0b3IpICYmIHRlc3RDb250ZXh0KGNvbnRleHQucGFyZW50Tm9kZSkgfHwgY29udGV4dFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH1cblxuICAgICAgLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCAtIDQuMStcbiAgICAgIC8vIFNvcnQgc3RhYmlsaXR5XG4gICAgICBzdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoc29ydE9yZGVyKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4gICAgICAvLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbiAgICAgIHNldERvY3VtZW50KCk7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgLSA0LjErXG4gICAgICAvLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbiAgICAgIHN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuXG4gICAgICAgIC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuICAgICAgICByZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpKSAmIDE7XG4gICAgICB9KTtcblxuICAgICAgalF1ZXJ5LmZpbmQgPSBmaW5kO1xuXG4gICAgICAvLyBEZXByZWNhdGVkXG4gICAgICBqUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xuICAgICAgalF1ZXJ5LnVuaXF1ZSA9IGpRdWVyeS51bmlxdWVTb3J0O1xuXG4gICAgICAvLyBUaGVzZSBoYXZlIGFsd2F5cyBiZWVuIHByaXZhdGUsIGJ1dCB0aGV5IHVzZWQgdG8gYmUgZG9jdW1lbnRlZCBhcyBwYXJ0IG9mXG4gICAgICAvLyBTaXp6bGUgc28gbGV0J3MgbWFpbnRhaW4gdGhlbSBmb3Igbm93IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBwdXJwb3Nlcy5cbiAgICAgIGZpbmQuY29tcGlsZSA9IGNvbXBpbGU7XG4gICAgICBmaW5kLnNlbGVjdCA9IHNlbGVjdDtcbiAgICAgIGZpbmQuc2V0RG9jdW1lbnQgPSBzZXREb2N1bWVudDtcbiAgICAgIGZpbmQudG9rZW5pemUgPSB0b2tlbml6ZTtcblxuICAgICAgZmluZC5lc2NhcGUgPSBqUXVlcnkuZXNjYXBlU2VsZWN0b3I7XG4gICAgICBmaW5kLmdldFRleHQgPSBqUXVlcnkudGV4dDtcbiAgICAgIGZpbmQuaXNYTUwgPSBqUXVlcnkuaXNYTUxEb2M7XG4gICAgICBmaW5kLnNlbGVjdG9ycyA9IGpRdWVyeS5leHByO1xuICAgICAgZmluZC5zdXBwb3J0ID0galF1ZXJ5LnN1cHBvcnQ7XG4gICAgICBmaW5kLnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlU29ydDtcblxuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gICAgfSkoKTtcblxuXG4gICAgdmFyIGRpciA9IGZ1bmN0aW9uIChlbGVtLCBkaXIsIHVudGlsKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9IFtdLFxuICAgICAgICB0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW1bZGlyXSkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSkge1xuICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIGlmICh0cnVuY2F0ZSAmJiBqUXVlcnkoZWxlbSkuaXModW50aWwpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF0Y2hlZC5wdXNoKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICB9O1xuXG5cbiAgICB2YXIgc2libGluZ3MgPSBmdW5jdGlvbiAobiwgZWxlbSkge1xuICAgICAgdmFyIG1hdGNoZWQgPSBbXTtcblxuICAgICAgZm9yICg7IG47IG4gPSBuLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGlmIChuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0pIHtcbiAgICAgICAgICBtYXRjaGVkLnB1c2gobik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfTtcblxuXG4gICAgdmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbiAgICB2YXIgcnNpbmdsZVRhZyA9ICgvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSk7XG5cblxuXG4gICAgLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbiAgICBmdW5jdGlvbiB3aW5ub3coZWxlbWVudHMsIHF1YWxpZmllciwgbm90KSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihxdWFsaWZpZXIpKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW0sIGkpIHtcbiAgICAgICAgICByZXR1cm4gISFxdWFsaWZpZXIuY2FsbChlbGVtLCBpLCBlbGVtKSAhPT0gbm90O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2luZ2xlIGVsZW1lbnRcbiAgICAgIGlmIChxdWFsaWZpZXIubm9kZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgIHJldHVybiAoZWxlbSA9PT0gcXVhbGlmaWVyKSAhPT0gbm90O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG4gICAgICBpZiAodHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgcmV0dXJuIChpbmRleE9mLmNhbGwocXVhbGlmaWVyLCBlbGVtKSA+IC0xKSAhPT0gbm90O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuICAgICAgcmV0dXJuIGpRdWVyeS5maWx0ZXIocXVhbGlmaWVyLCBlbGVtZW50cywgbm90KTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24gKGV4cHIsIGVsZW1zLCBub3QpIHtcbiAgICAgIHZhciBlbGVtID0gZWxlbXNbMF07XG5cbiAgICAgIGlmIChub3QpIHtcbiAgICAgICAgZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoZWxlbSwgZXhwcikgPyBbZWxlbV0gOiBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoZXhwciwgalF1ZXJ5LmdyZXAoZWxlbXMsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgIGZpbmQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgaSwgcmV0LFxuICAgICAgICAgIGxlbiA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soalF1ZXJ5KHNlbGVjdG9yKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChqUXVlcnkuY29udGFpbnMoc2VsZltpXSwgdGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IHRoaXMucHVzaFN0YWNrKFtdKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBqUXVlcnkuZmluZChzZWxlY3Rvciwgc2VsZltpXSwgcmV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQocmV0KSA6IHJldDtcbiAgICAgIH0sXG4gICAgICBmaWx0ZXI6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sod2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSkpO1xuICAgICAgfSxcbiAgICAgIG5vdDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayh3aW5ub3codGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUpKTtcbiAgICAgIH0sXG4gICAgICBpczogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiAhIXdpbm5vdyhcbiAgICAgICAgICB0aGlzLFxuXG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuICAgICAgICAgIC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cbiAgICAgICAgICB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KHNlbGVjdG9yKSA/XG4gICAgICAgICAgICBqUXVlcnkoc2VsZWN0b3IpIDpcbiAgICAgICAgICAgIHNlbGVjdG9yIHx8IFtdLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICkubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbiAgICAvLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbiAgICB2YXIgcm9vdGpRdWVyeSxcblxuICAgICAgLy8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3NcbiAgICAgIC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICh0cmFjLTk1MjEpXG4gICAgICAvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAodHJhYy0xMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG4gICAgICAvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG4gICAgICBycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cbiAgICAgIGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCwgcm9vdCkge1xuICAgICAgICB2YXIgbWF0Y2gsIGVsZW07XG5cbiAgICAgICAgLy8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG4gICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuICAgICAgICAvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG4gICAgICAgIHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cbiAgICAgICAgLy8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdG9yWzBdID09PSBcIjxcIiAmJlxuICAgICAgICAgICAgc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV0gPT09IFwiPlwiICYmXG4gICAgICAgICAgICBzZWxlY3Rvci5sZW5ndGggPj0gMykge1xuXG4gICAgICAgICAgICAvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuICAgICAgICAgICAgbWF0Y2ggPSBbbnVsbCwgc2VsZWN0b3IsIG51bGxdO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKHNlbGVjdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG4gICAgICAgICAgaWYgKG1hdGNoICYmIChtYXRjaFsxXSB8fCAhY29udGV4dCkpIHtcblxuICAgICAgICAgICAgLy8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WzBdIDogY29udGV4dDtcblxuICAgICAgICAgICAgICAvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcbiAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG4gICAgICAgICAgICAgICAgbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgY29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgIC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcbiAgICAgICAgICAgICAgaWYgKHJzaW5nbGVUYWcudGVzdChtYXRjaFsxXSkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKG1hdGNoIGluIGNvbnRleHQpIHtcblxuICAgICAgICAgICAgICAgICAgLy8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1ttYXRjaF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbbWF0Y2hdKGNvbnRleHRbbWF0Y2hdKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHIobWF0Y2gsIGNvbnRleHRbbWF0Y2hdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoI2lkKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1hdGNoWzJdKTtcblxuICAgICAgICAgICAgICBpZiAoZWxlbSkge1xuXG4gICAgICAgICAgICAgICAgLy8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3RcbiAgICAgICAgICAgICAgICB0aGlzWzBdID0gZWxlbTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG4gICAgICAgICAgfSBlbHNlIGlmICghY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIChjb250ZXh0IHx8IHJvb3QpLmZpbmQoc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICAvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcbiAgICAgICAgICAgIC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcihjb250ZXh0KS5maW5kKHNlbGVjdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rvci5ub2RlVHlwZSkge1xuICAgICAgICAgIHRoaXNbMF0gPSBzZWxlY3RvcjtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG4gICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHJvb3QucmVhZHkoc2VsZWN0b3IpIDpcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuICAgICAgICAgICAgc2VsZWN0b3IoalF1ZXJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkubWFrZUFycmF5KHNlbGVjdG9yLCB0aGlzKTtcbiAgICAgIH07XG5cbiAgICAvLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG4gICAgaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbiAgICAvLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG4gICAgcm9vdGpRdWVyeSA9IGpRdWVyeShkb2N1bWVudCk7XG5cblxuICAgIHZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuICAgICAgLy8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcbiAgICAgIGd1YXJhbnRlZWRVbmlxdWUgPSB7XG4gICAgICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgICAgICBjb250ZW50czogdHJ1ZSxcbiAgICAgICAgbmV4dDogdHJ1ZSxcbiAgICAgICAgcHJldjogdHJ1ZVxuICAgICAgfTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgaGFzOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciB0YXJnZXRzID0galF1ZXJ5KHRhcmdldCwgdGhpcyksXG4gICAgICAgICAgbCA9IHRhcmdldHMubGVuZ3RoO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmNvbnRhaW5zKHRoaXMsIHRhcmdldHNbaV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBjbG9zZXN0OiBmdW5jdGlvbiAoc2VsZWN0b3JzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjdXIsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgIG1hdGNoZWQgPSBbXSxcbiAgICAgICAgICB0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoc2VsZWN0b3JzKTtcblxuICAgICAgICAvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG4gICAgICAgIGlmICghcm5lZWRzQ29udGV4dC50ZXN0KHNlbGVjdG9ycykpIHtcbiAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm9yIChjdXIgPSB0aGlzW2ldOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuXG4gICAgICAgICAgICAgIC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuICAgICAgICAgICAgICBpZiAoY3VyLm5vZGVUeXBlIDwgMTEgJiYgKHRhcmdldHMgP1xuICAgICAgICAgICAgICAgIHRhcmdldHMuaW5kZXgoY3VyKSA+IC0xIDpcblxuICAgICAgICAgICAgICAgIC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIGpRdWVyeSNmaW5kXG4gICAgICAgICAgICAgICAgY3VyLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGN1ciwgc2VsZWN0b3JzKSkpIHtcblxuICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaChjdXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KG1hdGNoZWQpIDogbWF0Y2hlZCk7XG4gICAgICB9LFxuXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcbiAgICAgIGluZGV4OiBmdW5jdGlvbiAoZWxlbSkge1xuXG4gICAgICAgIC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG4gICAgICAgIGlmICghZWxlbSkge1xuICAgICAgICAgIHJldHVybiAodGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUpID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluZGV4IGluIHNlbGVjdG9yXG4gICAgICAgIGlmICh0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwoalF1ZXJ5KGVsZW0pLCB0aGlzWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuICAgICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKHRoaXMsXG5cbiAgICAgICAgICAvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcbiAgICAgICAgICBlbGVtLmpxdWVyeSA/IGVsZW1bMF0gOiBlbGVtXG4gICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICBhZGQ6IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soXG4gICAgICAgICAgalF1ZXJ5LnVuaXF1ZVNvcnQoXG4gICAgICAgICAgICBqUXVlcnkubWVyZ2UodGhpcy5nZXQoKSwgalF1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0KSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICBhZGRCYWNrOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHNlbGVjdG9yID09IG51bGwgP1xuICAgICAgICAgIHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoc2VsZWN0b3IpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBzaWJsaW5nKGN1ciwgZGlyKSB7XG4gICAgICB3aGlsZSAoKGN1ciA9IGN1cltkaXJdKSAmJiBjdXIubm9kZVR5cGUgIT09IDEpIHsgfVxuICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG5cbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICBwYXJlbnQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG4gICAgICB9LFxuICAgICAgcGFyZW50czogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGRpcihlbGVtLCBcInBhcmVudE5vZGVcIik7XG4gICAgICB9LFxuICAgICAgcGFyZW50c1VudGlsOiBmdW5jdGlvbiAoZWxlbSwgX2ksIHVudGlsKSB7XG4gICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsKTtcbiAgICAgIH0sXG4gICAgICBuZXh0OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICByZXR1cm4gc2libGluZyhlbGVtLCBcIm5leHRTaWJsaW5nXCIpO1xuICAgICAgfSxcbiAgICAgIHByZXY6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBzaWJsaW5nKGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIpO1xuICAgICAgfSxcbiAgICAgIG5leHRBbGw6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJuZXh0U2libGluZ1wiKTtcbiAgICAgIH0sXG4gICAgICBwcmV2QWxsOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIpO1xuICAgICAgfSxcbiAgICAgIG5leHRVbnRpbDogZnVuY3Rpb24gKGVsZW0sIF9pLCB1bnRpbCkge1xuICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwpO1xuICAgICAgfSxcbiAgICAgIHByZXZVbnRpbDogZnVuY3Rpb24gKGVsZW0sIF9pLCB1bnRpbCkge1xuICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsKTtcbiAgICAgIH0sXG4gICAgICBzaWJsaW5nczogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHNpYmxpbmdzKChlbGVtLnBhcmVudE5vZGUgfHwge30pLmZpcnN0Q2hpbGQsIGVsZW0pO1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICByZXR1cm4gc2libGluZ3MoZWxlbS5maXJzdENoaWxkKTtcbiAgICAgIH0sXG4gICAgICBjb250ZW50czogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgaWYgKGVsZW0uY29udGVudERvY3VtZW50ICE9IG51bGwgJiZcblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExK1xuICAgICAgICAgIC8vIDxvYmplY3Q+IGVsZW1lbnRzIHdpdGggbm8gYGRhdGFgIGF0dHJpYnV0ZSBoYXMgYW4gb2JqZWN0XG4gICAgICAgICAgLy8gYGNvbnRlbnREb2N1bWVudGAgd2l0aCBhIGBudWxsYCBwcm90b3R5cGUuXG4gICAgICAgICAgZ2V0UHJvdG8oZWxlbS5jb250ZW50RG9jdW1lbnQpKSB7XG5cbiAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcbiAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXG4gICAgICAgIGlmIChub2RlTmFtZShlbGVtLCBcInRlbXBsYXRlXCIpKSB7XG4gICAgICAgICAgZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZShbXSwgZWxlbS5jaGlsZE5vZGVzKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uICh1bnRpbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKHRoaXMsIGZuLCB1bnRpbCk7XG5cbiAgICAgICAgaWYgKG5hbWUuc2xpY2UoLTUpICE9PSBcIlVudGlsXCIpIHtcbiAgICAgICAgICBzZWxlY3RvciA9IHVudGlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKHNlbGVjdG9yLCBtYXRjaGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcblxuICAgICAgICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzXG4gICAgICAgICAgaWYgKCFndWFyYW50ZWVkVW5pcXVlW25hbWVdKSB7XG4gICAgICAgICAgICBqUXVlcnkudW5pcXVlU29ydChtYXRjaGVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuICAgICAgICAgIGlmIChycGFyZW50c3ByZXYudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgbWF0Y2hlZC5yZXZlcnNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG1hdGNoZWQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgcm5vdGh0bWx3aGl0ZSA9ICgvW15cXHgyMFxcdFxcclxcblxcZl0rL2cpO1xuXG5cblxuICAgIC8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG4gICAgZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICBqUXVlcnkuZWFjaChvcHRpb25zLm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFtdLCBmdW5jdGlvbiAoXywgZmxhZykge1xuICAgICAgICBvYmplY3RbZmxhZ10gPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgICpcbiAgICAgKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICAgICAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAgICAgKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gICAgICpcbiAgICAgKiBQb3NzaWJsZSBvcHRpb25zOlxuICAgICAqXG4gICAgICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICAgICAqXG4gICAgICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gICAgICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICAgICAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICAgICAqXG4gICAgICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAgICAgKlxuICAgICAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICAgICAqXG4gICAgICovXG4gICAgalF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAgIC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcbiAgICAgIC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcbiAgICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG4gICAgICAgIGNyZWF0ZU9wdGlvbnMob3B0aW9ucykgOlxuICAgICAgICBqUXVlcnkuZXh0ZW5kKHt9LCBvcHRpb25zKTtcblxuICAgICAgdmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcbiAgICAgICAgZmlyaW5nLFxuXG4gICAgICAgIC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG4gICAgICAgIG1lbW9yeSxcblxuICAgICAgICAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuICAgICAgICBmaXJlZCxcblxuICAgICAgICAvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG4gICAgICAgIGxvY2tlZCxcblxuICAgICAgICAvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuICAgICAgICBsaXN0ID0gW10sXG5cbiAgICAgICAgLy8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcbiAgICAgICAgcXVldWUgPSBbXSxcblxuICAgICAgICAvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcbiAgICAgICAgZmlyaW5nSW5kZXggPSAtMSxcblxuICAgICAgICAvLyBGaXJlIGNhbGxiYWNrc1xuICAgICAgICBmaXJlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgLy8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG4gICAgICAgICAgbG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuICAgICAgICAgIC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuICAgICAgICAgIC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcbiAgICAgICAgICBmaXJlZCA9IGZpcmluZyA9IHRydWU7XG4gICAgICAgICAgZm9yICg7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSkge1xuICAgICAgICAgICAgbWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIHdoaWxlICgrK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICAvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuICAgICAgICAgICAgICBpZiAobGlzdFtmaXJpbmdJbmRleF0uYXBwbHkobWVtb3J5WzBdLCBtZW1vcnlbMV0pID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RvcE9uRmFsc2UpIHtcblxuICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcbiAgICAgICAgICAgICAgICBmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG1lbW9yeSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuICAgICAgICAgIGlmICghb3B0aW9ucy5tZW1vcnkpIHtcbiAgICAgICAgICAgIG1lbW9yeSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpcmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2RcbiAgICAgICAgICBpZiAobG9ja2VkKSB7XG5cbiAgICAgICAgICAgIC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcbiAgICAgICAgICAgIGlmIChtZW1vcnkpIHtcbiAgICAgICAgICAgICAgbGlzdCA9IFtdO1xuXG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxpc3QgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuICAgICAgICBzZWxmID0ge1xuXG4gICAgICAgICAgLy8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuICAgICAgICAgIGFkZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGxpc3QpIHtcblxuICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuICAgICAgICAgICAgICBpZiAobWVtb3J5ICYmICFmaXJpbmcpIHtcbiAgICAgICAgICAgICAgICBmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKG1lbW9yeSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAoZnVuY3Rpb24gYWRkKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaChhcmdzLCBmdW5jdGlvbiAoXywgYXJnKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoYXJnKSAhPT0gXCJzdHJpbmdcIikge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICAgICAgYWRkKGFyZyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgaWYgKG1lbW9yeSAmJiAhZmlyaW5nKSB7XG4gICAgICAgICAgICAgICAgZmlyZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgalF1ZXJ5LmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbiAoXywgYXJnKSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgICAgd2hpbGUgKChpbmRleCA9IGpRdWVyeS5pbkFycmF5KGFyZywgbGlzdCwgaW5kZXgpKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDw9IGZpcmluZ0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICBmaXJpbmdJbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cbiAgICAgICAgICBoYXM6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgcmV0dXJuIGZuID9cbiAgICAgICAgICAgICAgalF1ZXJ5LmluQXJyYXkoZm4sIGxpc3QpID4gLTEgOlxuICAgICAgICAgICAgICBsaXN0Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3RcbiAgICAgICAgICBlbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgICAgbGlzdCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcbiAgICAgICAgICAvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcbiAgICAgICAgICAvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcbiAgICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuICAgICAgICAgICAgbGlzdCA9IG1lbW9yeSA9IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc2FibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIWxpc3Q7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIERpc2FibGUgLmZpcmVcbiAgICAgICAgICAvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuICAgICAgICAgIC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcbiAgICAgICAgICBsb2NrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuICAgICAgICAgICAgaWYgKCFtZW1vcnkgJiYgIWZpcmluZykge1xuICAgICAgICAgICAgICBsaXN0ID0gbWVtb3J5ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbG9ja2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISFsb2NrZWQ7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcbiAgICAgICAgICBmaXJlV2l0aDogZnVuY3Rpb24gKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmICghbG9ja2VkKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAgICAgICAgICAgICBhcmdzID0gW2NvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzXTtcbiAgICAgICAgICAgICAgcXVldWUucHVzaChhcmdzKTtcbiAgICAgICAgICAgICAgaWYgKCFmaXJpbmcpIHtcbiAgICAgICAgICAgICAgICBmaXJlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgIGZpcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuZmlyZVdpdGgodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2VcbiAgICAgICAgICBmaXJlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhZmlyZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBJZGVudGl0eSh2KSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgZnVuY3Rpb24gVGhyb3dlcihleCkge1xuICAgICAgdGhyb3cgZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRvcHRWYWx1ZSh2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlKSB7XG4gICAgICB2YXIgbWV0aG9kO1xuXG4gICAgICB0cnkge1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3JcbiAgICAgICAgaWYgKHZhbHVlICYmIGlzRnVuY3Rpb24oKG1ldGhvZCA9IHZhbHVlLnByb21pc2UpKSkge1xuICAgICAgICAgIG1ldGhvZC5jYWxsKHZhbHVlKS5kb25lKHJlc29sdmUpLmZhaWwocmVqZWN0KTtcblxuICAgICAgICAgIC8vIE90aGVyIHRoZW5hYmxlc1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIGlzRnVuY3Rpb24oKG1ldGhvZCA9IHZhbHVlLnRoZW4pKSkge1xuICAgICAgICAgIG1ldGhvZC5jYWxsKHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgICAgLy8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuICAgICAgICAgIC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcbiAgICAgICAgICAvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuICAgICAgICAgIHJlc29sdmUuYXBwbHkodW5kZWZpbmVkLCBbdmFsdWVdLnNsaWNlKG5vVmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuICAgICAgICAvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG4gICAgICAgIC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG4gICAgICB9IGNhdGNoICh2YWx1ZSkge1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcbiAgICAgICAgLy8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuICAgICAgICByZWplY3QuYXBwbHkodW5kZWZpbmVkLCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcblxuICAgICAgRGVmZXJyZWQ6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIHZhciB0dXBsZXMgPSBbXG5cbiAgICAgICAgICAvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuICAgICAgICAgIC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cbiAgICAgICAgICBbXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLFxuICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyhcIm1lbW9yeVwiKSwgMl0sXG4gICAgICAgICAgW1wicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxuICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCAwLCBcInJlc29sdmVkXCJdLFxuICAgICAgICAgIFtcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxuICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCAxLCBcInJlamVjdGVkXCJdXG4gICAgICAgIF0sXG4gICAgICAgICAgc3RhdGUgPSBcInBlbmRpbmdcIixcbiAgICAgICAgICBwcm9taXNlID0ge1xuICAgICAgICAgICAgc3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsd2F5czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBkZWZlcnJlZC5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImNhdGNoXCI6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKG51bGwsIGZuKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcbiAgICAgICAgICAgIHBpcGU6IGZ1bmN0aW9uICggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8pIHtcbiAgICAgICAgICAgICAgdmFyIGZucyA9IGFyZ3VtZW50cztcblxuICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LkRlZmVycmVkKGZ1bmN0aW9uIChuZXdEZWZlcikge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKHR1cGxlcywgZnVuY3Rpb24gKF9pLCB0dXBsZSkge1xuXG4gICAgICAgICAgICAgICAgICAvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgIHZhciBmbiA9IGlzRnVuY3Rpb24oZm5zW3R1cGxlWzRdXSkgJiYgZm5zW3R1cGxlWzRdXTtcblxuICAgICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG4gICAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcbiAgICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG4gICAgICAgICAgICAgICAgICBkZWZlcnJlZFt0dXBsZVsxXV0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQgJiYgaXNGdW5jdGlvbihyZXR1cm5lZC5wcm9taXNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkLnByb21pc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnByb2dyZXNzKG5ld0RlZmVyLm5vdGlmeSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kb25lKG5ld0RlZmVyLnJlc29sdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmFpbChuZXdEZWZlci5yZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyW3R1cGxlWzBdICsgXCJXaXRoXCJdKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuID8gW3JldHVybmVkXSA6IGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZucyA9IG51bGw7XG4gICAgICAgICAgICAgIH0pLnByb21pc2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgdmFyIG1heERlcHRoID0gMDtcbiAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZShkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBtaWdodFRocm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5lZCwgdGhlbjtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG4gICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPCBtYXhEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkID0gaGFuZGxlci5hcHBseSh0aGF0LCBhcmdzKTtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcbiAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG4gICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAgdGhlbiA9IHJldHVybmVkICYmXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZC50aGVuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGVuKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhEZXB0aCsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4uY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IElkZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbcmV0dXJuZWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIChzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoKSh0aGF0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MgPSBzcGVjaWFsID9cbiAgICAgICAgICAgICAgICAgICAgICBtaWdodFRocm93IDpcbiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtaWdodFRocm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoICsgMSA+PSBtYXhEZXB0aCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSBUaHJvd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKHRoYXQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcbiAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG4gICAgICAgICAgICAgICAgICAvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG4gICAgICAgICAgICAgICAgICAvLyBzdWJzZXF1ZW50IGVycm9yc1xuICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgZXJyb3IsIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LkRlZmVycmVkLmdldEVycm9ySG9vaykge1xuICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZXJyb3IgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0RXJyb3JIb29rKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGVwcmVjYXRlZCBhbGlhcyBvZiB0aGUgYWJvdmUuIFdoaWxlIHRoZSBuYW1lIHN1Z2dlc3RzXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuaW5nIHRoZSBzdGFjaywgbm90IGFuIGVycm9yIGluc3RhbmNlLCBqUXVlcnkganVzdCBwYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBkaXJlY3RseSB0byBgY29uc29sZS53YXJuYCBzbyBib3RoIHdpbGwgd29yazsgYW4gaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGJldHRlciBjb29wZXJhdGVzIHdpdGggc291cmNlIG1hcHMuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaykge1xuICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZXJyb3IgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQocHJvY2Vzcyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuRGVmZXJyZWQoZnVuY3Rpb24gKG5ld0RlZmVyKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG4gICAgICAgICAgICAgICAgdHVwbGVzWzBdWzNdLmFkZChcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKG9uUHJvZ3Jlc3MpID9cbiAgICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzIDpcbiAgICAgICAgICAgICAgICAgICAgICBJZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXIubm90aWZ5V2l0aFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuICAgICAgICAgICAgICAgIHR1cGxlc1sxXVszXS5hZGQoXG4gICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBuZXdEZWZlcixcbiAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgP1xuICAgICAgICAgICAgICAgICAgICAgIG9uRnVsZmlsbGVkIDpcbiAgICAgICAgICAgICAgICAgICAgICBJZGVudGl0eVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG4gICAgICAgICAgICAgICAgdHVwbGVzWzJdWzNdLmFkZChcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKG9uUmVqZWN0ZWQpID9cbiAgICAgICAgICAgICAgICAgICAgICBvblJlamVjdGVkIDpcbiAgICAgICAgICAgICAgICAgICAgICBUaHJvd2VyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSkucHJvbWlzZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuICAgICAgICAgICAgLy8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuICAgICAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKG9iaiwgcHJvbWlzZSkgOiBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmZXJyZWQgPSB7fTtcblxuICAgICAgICAvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG4gICAgICAgIGpRdWVyeS5lYWNoKHR1cGxlcywgZnVuY3Rpb24gKGksIHR1cGxlKSB7XG4gICAgICAgICAgdmFyIGxpc3QgPSB0dXBsZVsyXSxcbiAgICAgICAgICAgIHN0YXRlU3RyaW5nID0gdHVwbGVbNV07XG5cbiAgICAgICAgICAvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcbiAgICAgICAgICAvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuICAgICAgICAgIC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG4gICAgICAgICAgcHJvbWlzZVt0dXBsZVsxXV0gPSBsaXN0LmFkZDtcblxuICAgICAgICAgIC8vIEhhbmRsZSBzdGF0ZVxuICAgICAgICAgIGlmIChzdGF0ZVN0cmluZykge1xuICAgICAgICAgICAgbGlzdC5hZGQoXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG4gICAgICAgICAgICAgICAgLy8gc3RhdGUgPSBcInJlamVjdGVkXCJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgIC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG4gICAgICAgICAgICAgIC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuICAgICAgICAgICAgICB0dXBsZXNbMyAtIGldWzJdLmRpc2FibGUsXG5cbiAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuICAgICAgICAgICAgICAvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuICAgICAgICAgICAgICB0dXBsZXNbMyAtIGldWzNdLmRpc2FibGUsXG5cbiAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcbiAgICAgICAgICAgICAgdHVwbGVzWzBdWzJdLmxvY2ssXG5cbiAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuICAgICAgICAgICAgICB0dXBsZXNbMF1bM10ubG9ja1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG4gICAgICAgICAgLy8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcbiAgICAgICAgICAvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG4gICAgICAgICAgbGlzdC5hZGQodHVwbGVbM10uZmlyZSk7XG5cbiAgICAgICAgICAvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cbiAgICAgICAgICAvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuICAgICAgICAgIC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuICAgICAgICAgIGRlZmVycmVkW3R1cGxlWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlZmVycmVkW3R1cGxlWzBdICsgXCJXaXRoXCJdKHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuICAgICAgICAgIC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuICAgICAgICAgIC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG4gICAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF0gKyBcIldpdGhcIl0gPSBsaXN0LmZpcmVXaXRoO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2VcbiAgICAgICAgcHJvbWlzZS5wcm9taXNlKGRlZmVycmVkKTtcblxuICAgICAgICAvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG4gICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgZnVuYy5jYWxsKGRlZmVycmVkLCBkZWZlcnJlZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGwgZG9uZSFcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgICAgfSxcblxuICAgICAgLy8gRGVmZXJyZWQgaGVscGVyXG4gICAgICB3aGVuOiBmdW5jdGlvbiAoc2luZ2xlVmFsdWUpIHtcbiAgICAgICAgdmFyXG5cbiAgICAgICAgICAvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcbiAgICAgICAgICByZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG4gICAgICAgICAgLy8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG4gICAgICAgICAgaSA9IHJlbWFpbmluZyxcblxuICAgICAgICAgIC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcbiAgICAgICAgICByZXNvbHZlQ29udGV4dHMgPSBBcnJheShpKSxcbiAgICAgICAgICByZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuXG4gICAgICAgICAgLy8gdGhlIHByaW1hcnkgRGVmZXJyZWRcbiAgICAgICAgICBwcmltYXJ5ID0galF1ZXJ5LkRlZmVycmVkKCksXG5cbiAgICAgICAgICAvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG4gICAgICAgICAgdXBkYXRlRnVuYyA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJlc29sdmVDb250ZXh0c1tpXSA9IHRoaXM7XG4gICAgICAgICAgICAgIHJlc29sdmVWYWx1ZXNbaV0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoYXJndW1lbnRzKSA6IHZhbHVlO1xuICAgICAgICAgICAgICBpZiAoISgtLXJlbWFpbmluZykpIHtcbiAgICAgICAgICAgICAgICBwcmltYXJ5LnJlc29sdmVXaXRoKHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcblxuICAgICAgICAvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAxKSB7XG4gICAgICAgICAgYWRvcHRWYWx1ZShzaW5nbGVWYWx1ZSwgcHJpbWFyeS5kb25lKHVwZGF0ZUZ1bmMoaSkpLnJlc29sdmUsIHByaW1hcnkucmVqZWN0LFxuICAgICAgICAgICAgIXJlbWFpbmluZyk7XG5cbiAgICAgICAgICAvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG4gICAgICAgICAgaWYgKHByaW1hcnkuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcbiAgICAgICAgICAgIGlzRnVuY3Rpb24ocmVzb2x2ZVZhbHVlc1tpXSAmJiByZXNvbHZlVmFsdWVzW2ldLnRoZW4pKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBwcmltYXJ5LnRoZW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgYWRvcHRWYWx1ZShyZXNvbHZlVmFsdWVzW2ldLCB1cGRhdGVGdW5jKGkpLCBwcmltYXJ5LnJlamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJpbWFyeS5wcm9taXNlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuICAgIC8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxuICAgIHZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG4gICAgLy8gSWYgYGpRdWVyeS5EZWZlcnJlZC5nZXRFcnJvckhvb2tgIGlzIGRlZmluZWQsIGBhc3luY0Vycm9yYCBpcyBhbiBlcnJvclxuICAgIC8vIGNhcHR1cmVkIGJlZm9yZSB0aGUgYXN5bmMgYmFycmllciB0byBnZXQgdGhlIG9yaWdpbmFsIGVycm9yIGNhdXNlXG4gICAgLy8gd2hpY2ggbWF5IG90aGVyd2lzZSBiZSBoaWRkZW4uXG4gICAgalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiAoZXJyb3IsIGFzeW5jRXJyb3IpIHtcblxuICAgICAgLy8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuICAgICAgLy8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcbiAgICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoZXJyb3IubmFtZSkpIHtcbiAgICAgICAgd2luZG93LmNvbnNvbGUud2FybihcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBlcnJvci5zdGFjaywgYXN5bmNFcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuXG5cblxuICAgIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuICAgIH07XG5cblxuXG5cbiAgICAvLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbiAgICB2YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbiAgICBqUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiAoZm4pIHtcblxuICAgICAgcmVhZHlMaXN0XG4gICAgICAgIC50aGVuKGZuKVxuXG4gICAgICAgIC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG4gICAgICAgIC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuICAgICAgICAvLyByZWdpc3RyYXRpb24uXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBqUXVlcnkucmVhZHlFeGNlcHRpb24oZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuXG4gICAgICAvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuICAgICAgaXNSZWFkeTogZmFsc2UsXG5cbiAgICAgIC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcbiAgICAgIC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlIHRyYWMtNjc4MVxuICAgICAgcmVhZHlXYWl0OiAxLFxuXG4gICAgICAvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG4gICAgICByZWFkeTogZnVuY3Rpb24gKHdhaXQpIHtcblxuICAgICAgICAvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG4gICAgICAgIGlmICh3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcbiAgICAgICAgalF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG4gICAgICAgIGlmICh3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG4gICAgICAgIHJlYWR5TGlzdC5yZXNvbHZlV2l0aChkb2N1bWVudCwgW2pRdWVyeV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuICAgIC8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG4gICAgZnVuY3Rpb24gY29tcGxldGVkKCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBjb21wbGV0ZWQpO1xuICAgICAgalF1ZXJ5LnJlYWR5KCk7XG4gICAgfVxuXG4gICAgLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbiAgICAvLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbiAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4gICAgLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuICAgICAgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwpKSB7XG5cbiAgICAgIC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuICAgICAgd2luZG93LnNldFRpbWVvdXQoalF1ZXJ5LnJlYWR5KTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCk7XG5cbiAgICAgIC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgY29tcGxldGVkKTtcbiAgICB9XG5cblxuXG5cbiAgICAvLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbiAgICAvLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbiAgICB2YXIgYWNjZXNzID0gZnVuY3Rpb24gKGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3KSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbiA9IGVsZW1zLmxlbmd0aCxcbiAgICAgICAgYnVsayA9IGtleSA9PSBudWxsO1xuXG4gICAgICAvLyBTZXRzIG1hbnkgdmFsdWVzXG4gICAgICBpZiAodG9UeXBlKGtleSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY2hhaW5hYmxlID0gdHJ1ZTtcbiAgICAgICAgZm9yIChpIGluIGtleSkge1xuICAgICAgICAgIGFjY2VzcyhlbGVtcywgZm4sIGksIGtleVtpXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXRzIG9uZSB2YWx1ZVxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNoYWluYWJsZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHJhdyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnVsaykge1xuXG4gICAgICAgICAgLy8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG4gICAgICAgICAgaWYgKHJhdykge1xuICAgICAgICAgICAgZm4uY2FsbChlbGVtcywgdmFsdWUpO1xuICAgICAgICAgICAgZm4gPSBudWxsO1xuXG4gICAgICAgICAgICAvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1bGsgPSBmbjtcbiAgICAgICAgICAgIGZuID0gZnVuY3Rpb24gKGVsZW0sIF9rZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBidWxrLmNhbGwoalF1ZXJ5KGVsZW0pLCB2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGZuKFxuICAgICAgICAgICAgICBlbGVtc1tpXSwga2V5LCByYXcgP1xuICAgICAgICAgICAgICB2YWx1ZSA6XG4gICAgICAgICAgICAgIHZhbHVlLmNhbGwoZWxlbXNbaV0sIGksIGZuKGVsZW1zW2ldLCBrZXkpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYWluYWJsZSkge1xuICAgICAgICByZXR1cm4gZWxlbXM7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldHNcbiAgICAgIGlmIChidWxrKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKGVsZW1zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxlbiA/IGZuKGVsZW1zWzBdLCBrZXkpIDogZW1wdHlHZXQ7XG4gICAgfTtcblxuXG4gICAgLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG4gICAgdmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG4gICAgICByZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbiAgICAvLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbiAgICBmdW5jdGlvbiBmY2FtZWxDYXNlKF9hbGwsIGxldHRlcikge1xuICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbiAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4gICAgLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKHRyYWMtOTU3MilcbiAgICBmdW5jdGlvbiBjYW1lbENhc2Uoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2Uocm1zUHJlZml4LCBcIm1zLVwiKS5yZXBsYWNlKHJkYXNoQWxwaGEsIGZjYW1lbENhc2UpO1xuICAgIH1cbiAgICB2YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uIChvd25lcikge1xuXG4gICAgICAvLyBBY2NlcHRzIG9ubHk6XG4gICAgICAvLyAgLSBOb2RlXG4gICAgICAvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG4gICAgICAvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuICAgICAgLy8gIC0gT2JqZWN0XG4gICAgICAvLyAgICAtIEFueVxuICAgICAgcmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoK293bmVyLm5vZGVUeXBlKTtcbiAgICB9O1xuXG5cblxuXG4gICAgZnVuY3Rpb24gRGF0YSgpIHtcbiAgICAgIHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbiAgICB9XG5cbiAgICBEYXRhLnVpZCA9IDE7XG5cbiAgICBEYXRhLnByb3RvdHlwZSA9IHtcblxuICAgICAgY2FjaGU6IGZ1bmN0aW9uIChvd25lcikge1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuICAgICAgICB2YXIgdmFsdWUgPSBvd25lclt0aGlzLmV4cGFuZG9dO1xuXG4gICAgICAgIC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUgPSB7fTtcblxuICAgICAgICAgIC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuICAgICAgICAgIC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgdHJhYy04MzM1LlxuICAgICAgICAgIC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuICAgICAgICAgIGlmIChhY2NlcHREYXRhKG93bmVyKSkge1xuXG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG4gICAgICAgICAgICAvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuICAgICAgICAgICAgaWYgKG93bmVyLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgIG93bmVyW3RoaXMuZXhwYW5kb10gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcbiAgICAgICAgICAgICAgLy8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcbiAgICAgICAgICAgICAgLy8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChvd25lciwgZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHByb3AsXG4gICAgICAgICAgY2FjaGUgPSB0aGlzLmNhY2hlKG93bmVyKTtcblxuICAgICAgICAvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG4gICAgICAgIC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1NylcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY2FjaGVbY2FtZWxDYXNlKGRhdGEpXSA9IHZhbHVlO1xuXG4gICAgICAgICAgLy8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3NcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG4gICAgICAgICAgZm9yIChwcm9wIGluIGRhdGEpIHtcbiAgICAgICAgICAgIGNhY2hlW2NhbWVsQ2FzZShwcm9wKV0gPSBkYXRhW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbiAob3duZXIsIGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHRoaXMuY2FjaGUob3duZXIpIDpcblxuICAgICAgICAgIC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1NylcbiAgICAgICAgICBvd25lclt0aGlzLmV4cGFuZG9dICYmIG93bmVyW3RoaXMuZXhwYW5kb11bY2FtZWxDYXNlKGtleSldO1xuICAgICAgfSxcbiAgICAgIGFjY2VzczogZnVuY3Rpb24gKG93bmVyLCBrZXksIHZhbHVlKSB7XG5cbiAgICAgICAgLy8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG4gICAgICAgIC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuICAgICAgICAvL1xuICAgICAgICAvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcbiAgICAgICAgLy8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG4gICAgICAgIC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKChrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgIHJldHVybiB0aGlzLmdldChvd25lciwga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG4gICAgICAgIC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG4gICAgICAgIC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMuc2V0KG93bmVyLCBrZXksIHZhbHVlKTtcblxuICAgICAgICAvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAob3duZXIsIGtleSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICBjYWNoZSA9IG93bmVyW3RoaXMuZXhwYW5kb107XG5cbiAgICAgICAgaWYgKGNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgIC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuXG4gICAgICAgICAgICAvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuICAgICAgICAgICAgLy8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG4gICAgICAgICAgICBrZXkgPSBrZXkubWFwKGNhbWVsQ2FzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IGNhbWVsQ2FzZShrZXkpO1xuXG4gICAgICAgICAgICAvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuICAgICAgICAgICAga2V5ID0ga2V5IGluIGNhY2hlID9cbiAgICAgICAgICAgICAgW2tleV0gOlxuICAgICAgICAgICAgICAoa2V5Lm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFtdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpID0ga2V5Lmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXlbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoY2FjaGUpKSB7XG5cbiAgICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG4gICAgICAgICAgLy8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcbiAgICAgICAgICAvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG4gICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcbiAgICAgICAgICBpZiAob3duZXIubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIG93bmVyW3RoaXMuZXhwYW5kb10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvd25lclt0aGlzLmV4cGFuZG9dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhc0RhdGE6IGZ1bmN0aW9uIChvd25lcikge1xuICAgICAgICB2YXIgY2FjaGUgPSBvd25lclt0aGlzLmV4cGFuZG9dO1xuICAgICAgICByZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoY2FjaGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxuICAgIHZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4gICAgLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbiAgICAvL1xuICAgIC8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4gICAgLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuICAgIC8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbiAgICAvL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbiAgICAvL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuICAgIC8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbiAgICAvL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbiAgICB2YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuICAgICAgcm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG4gICAgZnVuY3Rpb24gZ2V0RGF0YShkYXRhKSB7XG4gICAgICBpZiAoZGF0YSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhID09PSBcImZhbHNlXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG4gICAgICBpZiAoZGF0YSA9PT0gK2RhdGEgKyBcIlwiKSB7XG4gICAgICAgIHJldHVybiArZGF0YTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJicmFjZS50ZXN0KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXRhQXR0cihlbGVtLCBrZXksIGRhdGEpIHtcbiAgICAgIHZhciBuYW1lO1xuXG4gICAgICAvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG4gICAgICAvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcbiAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2Uocm11bHRpRGFzaCwgXCItJCZcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gZ2V0RGF0YShkYXRhKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuICAgICAgICAgIGRhdGFVc2VyLnNldChlbGVtLCBrZXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgaGFzRGF0YTogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoZWxlbSkgfHwgZGF0YVByaXYuaGFzRGF0YShlbGVtKTtcbiAgICAgIH0sXG5cbiAgICAgIGRhdGE6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhVXNlci5hY2Nlc3MoZWxlbSwgbmFtZSwgZGF0YSk7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSkge1xuICAgICAgICBkYXRhVXNlci5yZW1vdmUoZWxlbSwgbmFtZSk7XG4gICAgICB9LFxuXG4gICAgICAvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuICAgICAgLy8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG4gICAgICBfZGF0YTogZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFQcml2LmFjY2VzcyhlbGVtLCBuYW1lLCBkYXRhKTtcbiAgICAgIH0sXG5cbiAgICAgIF9yZW1vdmVEYXRhOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSkge1xuICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZWxlbSwgbmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgIGRhdGE6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBpLCBuYW1lLCBkYXRhLFxuICAgICAgICAgIGVsZW0gPSB0aGlzWzBdLFxuICAgICAgICAgIGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgLy8gR2V0cyBhbGwgdmFsdWVzXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YSA9IGRhdGFVc2VyLmdldChlbGVtKTtcblxuICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldChlbGVtLCBcImhhc0RhdGFBdHRyc1wiKSkge1xuICAgICAgICAgICAgICBpID0gYXR0cnMubGVuZ3RoO1xuICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG4gICAgICAgICAgICAgICAgLy8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICh0cmFjLTE0ODk0KVxuICAgICAgICAgICAgICAgIGlmIChhdHRyc1tpXSkge1xuICAgICAgICAgICAgICAgICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICAgICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKFwiZGF0YS1cIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lLnNsaWNlKDUpKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUF0dHIoZWxlbSwgbmFtZSwgZGF0YVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFQcml2LnNldChlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkYXRhVXNlci5zZXQodGhpcywga2V5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGRhdGE7XG5cbiAgICAgICAgICAvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuICAgICAgICAgIC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG4gICAgICAgICAgLy8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3RcbiAgICAgICAgICAvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG4gICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cbiAgICAgICAgICBpZiAoZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcbiAgICAgICAgICAgIC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG4gICAgICAgICAgICBkYXRhID0gZGF0YVVzZXIuZ2V0KGVsZW0sIGtleSk7XG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuICAgICAgICAgICAgLy8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuICAgICAgICAgICAgZGF0YSA9IGRhdGFBdHRyKGVsZW0sIGtleSk7XG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0IHRoZSBkYXRhLi4uXG4gICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgLy8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuICAgICAgICAgICAgZGF0YVVzZXIuc2V0KHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUpO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkYXRhVXNlci5yZW1vdmUodGhpcywga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgcXVldWU6IGZ1bmN0aW9uIChlbGVtLCB0eXBlLCBkYXRhKSB7XG4gICAgICAgIHZhciBxdWV1ZTtcblxuICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgIHR5cGUgPSAodHlwZSB8fCBcImZ4XCIpICsgXCJxdWV1ZVwiO1xuICAgICAgICAgIHF1ZXVlID0gZGF0YVByaXYuZ2V0KGVsZW0sIHR5cGUpO1xuXG4gICAgICAgICAgLy8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgcXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheShkYXRhKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcXVldWUgfHwgW107XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRlcXVldWU6IGZ1bmN0aW9uIChlbGVtLCB0eXBlKSB7XG4gICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuICAgICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoZWxlbSwgdHlwZSksXG4gICAgICAgICAgc3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG4gICAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpLFxuICAgICAgICAgIGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKGVsZW0sIHR5cGUpLFxuICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZShlbGVtLCB0eXBlKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcbiAgICAgICAgaWYgKGZuID09PSBcImlucHJvZ3Jlc3NcIikge1xuICAgICAgICAgIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICBzdGFydExlbmd0aC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZuKSB7XG5cbiAgICAgICAgICAvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG4gICAgICAgICAgLy8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuICAgICAgICAgIGlmICh0eXBlID09PSBcImZ4XCIpIHtcbiAgICAgICAgICAgIHF1ZXVlLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cbiAgICAgICAgICBkZWxldGUgaG9va3Muc3RvcDtcbiAgICAgICAgICBmbi5jYWxsKGVsZW0sIG5leHQsIGhvb2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhcnRMZW5ndGggJiYgaG9va3MpIHtcbiAgICAgICAgICBob29rcy5lbXB0eS5maXJlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG4gICAgICBfcXVldWVIb29rczogZnVuY3Rpb24gKGVsZW0sIHR5cGUpIHtcbiAgICAgICAgdmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcbiAgICAgICAgcmV0dXJuIGRhdGFQcml2LmdldChlbGVtLCBrZXkpIHx8IGRhdGFQcml2LmFjY2VzcyhlbGVtLCBrZXksIHtcbiAgICAgICAgICBlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZWxlbSwgW3R5cGUgKyBcInF1ZXVlXCIsIGtleV0pO1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICBxdWV1ZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgdmFyIHNldHRlciA9IDI7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgZGF0YSA9IHR5cGU7XG4gICAgICAgICAgdHlwZSA9IFwiZnhcIjtcbiAgICAgICAgICBzZXR0ZXItLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGpRdWVyeS5xdWV1ZSh0aGlzWzBdLCB0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHRoaXMgOlxuICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUodGhpcywgdHlwZSwgZGF0YSk7XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG4gICAgICAgICAgICBqUXVlcnkuX3F1ZXVlSG9va3ModGhpcywgdHlwZSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbMF0gIT09IFwiaW5wcm9ncmVzc1wiKSB7XG4gICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKHRoaXMsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRlcXVldWU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKHRoaXMsIHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjbGVhclF1ZXVlOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZSh0eXBlIHx8IFwiZnhcIiwgW10pO1xuICAgICAgfSxcblxuICAgICAgLy8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuICAgICAgLy8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG4gICAgICBwcm9taXNlOiBmdW5jdGlvbiAodHlwZSwgb2JqKSB7XG4gICAgICAgIHZhciB0bXAsXG4gICAgICAgICAgY291bnQgPSAxLFxuICAgICAgICAgIGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG4gICAgICAgICAgZWxlbWVudHMgPSB0aGlzLFxuICAgICAgICAgIGkgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICByZXNvbHZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCEoLS1jb3VudCkpIHtcbiAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZVdpdGgoZWxlbWVudHMsIFtlbGVtZW50c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgb2JqID0gdHlwZTtcbiAgICAgICAgICB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgdG1wID0gZGF0YVByaXYuZ2V0KGVsZW1lbnRzW2ldLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIpO1xuICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmVtcHR5KSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgdG1wLmVtcHR5LmFkZChyZXNvbHZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZShvYmopO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBwbnVtID0gKC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvKS5zb3VyY2U7XG5cbiAgICB2YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIpO1xuXG5cbiAgICB2YXIgY3NzRXhwYW5kID0gW1wiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCJdO1xuXG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbiAgICB2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICByZXR1cm4galF1ZXJ5LmNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSk7XG4gICAgfSxcbiAgICAgIGNvbXBvc2VkID0geyBjb21wb3NlZDogdHJ1ZSB9O1xuXG4gICAgLy8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcbiAgICAvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcbiAgICAvLyBTdXBwb3J0OiBpT1MgMTAuMC0xMC4yIG9ubHlcbiAgICAvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG4gICAgLy8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXG4gICAgaWYgKGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSkge1xuICAgICAgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKSB8fFxuICAgICAgICAgIGVsZW0uZ2V0Um9vdE5vZGUoY29tcG9zZWQpID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24gKGVsZW0sIGVsKSB7XG5cbiAgICAgIC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuICAgICAgLy8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG4gICAgICBlbGVtID0gZWwgfHwgZWxlbTtcblxuICAgICAgLy8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcbiAgICAgIHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG4gICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcbiAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcbiAgICAgICAgLy8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG4gICAgICAgIC8vIGluIHRoZSBkb2N1bWVudC5cbiAgICAgICAgaXNBdHRhY2hlZChlbGVtKSAmJlxuXG4gICAgICAgIGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpID09PSBcIm5vbmVcIjtcbiAgICB9O1xuXG5cblxuICAgIGZ1bmN0aW9uIGFkanVzdENTUyhlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2Vlbikge1xuICAgICAgdmFyIGFkanVzdGVkLCBzY2FsZSxcbiAgICAgICAgbWF4SXRlcmF0aW9ucyA9IDIwLFxuICAgICAgICBjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR3ZWVuLmN1cigpO1xuICAgICAgICAgIH0gOlxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuY3NzKGVsZW0sIHByb3AsIFwiXCIpO1xuICAgICAgICAgIH0sXG4gICAgICAgIGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcbiAgICAgICAgdW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1szXSB8fCAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSA/IFwiXCIgOiBcInB4XCIpLFxuXG4gICAgICAgIC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG4gICAgICAgIGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG4gICAgICAgICAgKGpRdWVyeS5jc3NOdW1iZXJbcHJvcF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsKSAmJlxuICAgICAgICAgIHJjc3NOdW0uZXhlYyhqUXVlcnkuY3NzKGVsZW0sIHByb3ApKTtcblxuICAgICAgaWYgKGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFszXSAhPT0gdW5pdCkge1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuICAgICAgICAvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG4gICAgICAgIGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuICAgICAgICAvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG4gICAgICAgIHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbM107XG5cbiAgICAgICAgLy8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcbiAgICAgICAgaW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cbiAgICAgICAgd2hpbGUgKG1heEl0ZXJhdGlvbnMtLSkge1xuXG4gICAgICAgICAgLy8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cbiAgICAgICAgICAvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG4gICAgICAgICAgalF1ZXJ5LnN0eWxlKGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0KTtcbiAgICAgICAgICBpZiAoKDEgLSBzY2FsZSkgKiAoMSAtIChzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUpKSA8PSAwKSB7XG4gICAgICAgICAgICBtYXhJdGVyYXRpb25zID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQpO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cbiAgICAgICAgdmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZVBhcnRzKSB7XG4gICAgICAgIGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG4gICAgICAgIC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuICAgICAgICBhZGp1c3RlZCA9IHZhbHVlUGFydHNbMV0gP1xuICAgICAgICAgIGluaXRpYWxJblVuaXQgKyAodmFsdWVQYXJ0c1sxXSArIDEpICogdmFsdWVQYXJ0c1syXSA6XG4gICAgICAgICAgK3ZhbHVlUGFydHNbMl07XG4gICAgICAgIGlmICh0d2Vlbikge1xuICAgICAgICAgIHR3ZWVuLnVuaXQgPSB1bml0O1xuICAgICAgICAgIHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcbiAgICAgICAgICB0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFkanVzdGVkO1xuICAgIH1cblxuXG4gICAgdmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbiAgICBmdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheShlbGVtKSB7XG4gICAgICB2YXIgdGVtcCxcbiAgICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuICAgICAgICBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG4gICAgICAgIGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFtub2RlTmFtZV07XG5cbiAgICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICAgIHJldHVybiBkaXNwbGF5O1xuICAgICAgfVxuXG4gICAgICB0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpKTtcbiAgICAgIGRpc3BsYXkgPSBqUXVlcnkuY3NzKHRlbXAsIFwiZGlzcGxheVwiKTtcblxuICAgICAgdGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXApO1xuXG4gICAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHREaXNwbGF5TWFwW25vZGVOYW1lXSA9IGRpc3BsYXk7XG5cbiAgICAgIHJldHVybiBkaXNwbGF5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dIaWRlKGVsZW1lbnRzLCBzaG93KSB7XG4gICAgICB2YXIgZGlzcGxheSwgZWxlbSxcbiAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2VcbiAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBlbGVtID0gZWxlbWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAoIWVsZW0uc3R5bGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIGlmIChzaG93KSB7XG5cbiAgICAgICAgICAvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG4gICAgICAgICAgLy8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG4gICAgICAgICAgLy8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuICAgICAgICAgIGlmIChkaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IGRhdGFQcml2LmdldChlbGVtLCBcImRpc3BsYXlcIikgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmICghdmFsdWVzW2luZGV4XSkge1xuICAgICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZShlbGVtKSkge1xuICAgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IGdldERlZmF1bHREaXNwbGF5KGVsZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZGlzcGxheSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBcIm5vbmVcIjtcblxuICAgICAgICAgICAgLy8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuICAgICAgICAgICAgZGF0YVByaXYuc2V0KGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbaW5kZXhdICE9IG51bGwpIHtcbiAgICAgICAgICBlbGVtZW50c1tpbmRleF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2hvd0hpZGUodGhpcywgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2hvd0hpZGUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGlzSGlkZGVuV2l0aGluVHJlZSh0aGlzKSkge1xuICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnNob3coKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciByY2hlY2thYmxlVHlwZSA9ICgvXig/OmNoZWNrYm94fHJhZGlvKSQvaSk7XG5cbiAgICB2YXIgcnRhZ05hbWUgPSAoLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pKTtcblxuICAgIHZhciByc2NyaXB0VHlwZSA9ICgvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pKTtcblxuXG5cbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICBkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxcbiAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcbiAgICAgIC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICh0cmFjLTExMjE3KVxuICAgICAgLy8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuICAgICAgLy8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICh0cmFjLTE0OTAxKVxuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInJhZGlvXCIpO1xuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIik7XG4gICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwidFwiKTtcblxuICAgICAgZGl2LmFwcGVuZENoaWxkKGlucHV0KTtcblxuICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG4gICAgICAvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcbiAgICAgIHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUodHJ1ZSkuY2xvbmVOb2RlKHRydWUpLmxhc3RDaGlsZC5jaGVja2VkO1xuXG4gICAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbiAgICAgIC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG4gICAgICBkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG4gICAgICBzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKHRydWUpLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAvLyBJRSA8PTkgcmVwbGFjZXMgPG9wdGlvbj4gdGFncyB3aXRoIHRoZWlyIGNvbnRlbnRzIHdoZW4gaW5zZXJ0ZWQgb3V0c2lkZSBvZlxuICAgICAgLy8gdGhlIHNlbGVjdCBlbGVtZW50LlxuICAgICAgZGl2LmlubmVySFRNTCA9IFwiPG9wdGlvbj48L29wdGlvbj5cIjtcbiAgICAgIHN1cHBvcnQub3B0aW9uID0gISFkaXYubGFzdENoaWxkO1xuICAgIH0pKCk7XG5cblxuICAgIC8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICh0cmFjLTEzMjAwKVxuICAgIHZhciB3cmFwTWFwID0ge1xuXG4gICAgICAvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuICAgICAgLy8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuICAgICAgLy8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuICAgICAgdGhlYWQ6IFsxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiXSxcbiAgICAgIGNvbDogWzIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCJdLFxuICAgICAgdHI6IFsyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiXSxcbiAgICAgIHRkOiBbMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sXG5cbiAgICAgIF9kZWZhdWx0OiBbMCwgXCJcIiwgXCJcIl1cbiAgICB9O1xuXG4gICAgd3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbiAgICB3cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgaWYgKCFzdXBwb3J0Lm9wdGlvbikge1xuICAgICAgd3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uID0gWzEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiXTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldEFsbChjb250ZXh0LCB0YWcpIHtcblxuICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgICAgLy8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAodHJhYy0xNTE1MSlcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyB8fCBcIipcIik7XG5cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwodGFnIHx8IFwiKlwiKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICh0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoY29udGV4dCwgdGFnKSkge1xuICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKFtjb250ZXh0XSwgcmV0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cblxuICAgIC8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuICAgIGZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoZWxlbXMsIHJlZkVsZW1lbnRzKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgIGwgPSBlbGVtcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGRhdGFQcml2LnNldChcbiAgICAgICAgICBlbGVtc1tpXSxcbiAgICAgICAgICBcImdsb2JhbEV2YWxcIixcbiAgICAgICAgICAhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KHJlZkVsZW1lbnRzW2ldLCBcImdsb2JhbEV2YWxcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIHZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuICAgIGZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCkge1xuICAgICAgdmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcbiAgICAgICAgZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgbm9kZXMgPSBbXSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGwgPSBlbGVtcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGVsZW0gPSBlbGVtc1tpXTtcblxuICAgICAgICBpZiAoZWxlbSB8fCBlbGVtID09PSAwKSB7XG5cbiAgICAgICAgICAvLyBBZGQgbm9kZXMgZGlyZWN0bHlcbiAgICAgICAgICBpZiAodG9UeXBlKGVsZW0pID09PSBcIm9iamVjdFwiKSB7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gW2VsZW1dIDogZWxlbSk7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuICAgICAgICAgIH0gZWxzZSBpZiAoIXJodG1sLnRlc3QoZWxlbSkpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goY29udGV4dC5jcmVhdGVUZXh0Tm9kZShlbGVtKSk7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcblxuICAgICAgICAgICAgLy8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgdGFnID0gKHJ0YWdOYW1lLmV4ZWMoZWxlbSkgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgd3JhcCA9IHdyYXBNYXBbdGFnXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuICAgICAgICAgICAgdG1wLmlubmVySFRNTCA9IHdyYXBbMV0gKyBqUXVlcnkuaHRtbFByZWZpbHRlcihlbGVtKSArIHdyYXBbMl07XG5cbiAgICAgICAgICAgIC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuICAgICAgICAgICAgaiA9IHdyYXBbMF07XG4gICAgICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICAgIHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKG5vZGVzLCB0bXAuY2hpbGROb2Rlcyk7XG5cbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG4gICAgICAgICAgICB0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICh0cmFjLTEyMzkyKVxuICAgICAgICAgICAgdG1wLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuICAgICAgZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG4gICAgICBpID0gMDtcbiAgICAgIHdoaWxlICgoZWxlbSA9IG5vZGVzW2krK10pKSB7XG5cbiAgICAgICAgLy8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4NylcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheShlbGVtLCBzZWxlY3Rpb24pID4gLTEpIHtcbiAgICAgICAgICBpZiAoaWdub3JlZCkge1xuICAgICAgICAgICAgaWdub3JlZC5wdXNoKGVsZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dGFjaGVkID0gaXNBdHRhY2hlZChlbGVtKTtcblxuICAgICAgICAvLyBBcHBlbmQgdG8gZnJhZ21lbnRcbiAgICAgICAgdG1wID0gZ2V0QWxsKGZyYWdtZW50LmFwcGVuZENoaWxkKGVsZW0pLCBcInNjcmlwdFwiKTtcblxuICAgICAgICAvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG4gICAgICAgIGlmIChhdHRhY2hlZCkge1xuICAgICAgICAgIHNldEdsb2JhbEV2YWwodG1wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcbiAgICAgICAgaWYgKHNjcmlwdHMpIHtcbiAgICAgICAgICBqID0gMDtcbiAgICAgICAgICB3aGlsZSAoKGVsZW0gPSB0bXBbaisrXSkpIHtcbiAgICAgICAgICAgIGlmIChyc2NyaXB0VHlwZS50ZXN0KGVsZW0udHlwZSB8fCBcIlwiKSkge1xuICAgICAgICAgICAgICBzY3JpcHRzLnB1c2goZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9XG5cblxuICAgIHZhciBydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbiAgICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb24oZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lKSB7XG4gICAgICB2YXIgb3JpZ0ZuLCB0eXBlO1xuXG4gICAgICAvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcbiAgICAgIGlmICh0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIpIHtcblxuICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiKSB7XG5cbiAgICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG4gICAgICAgICAgZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG4gICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh0eXBlIGluIHR5cGVzKSB7XG4gICAgICAgICAgb24oZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzW3R5cGVdLCBvbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwpIHtcblxuICAgICAgICAvLyAoIHR5cGVzLCBmbiApXG4gICAgICAgIGZuID0gc2VsZWN0b3I7XG4gICAgICAgIGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoZm4gPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG5cbiAgICAgICAgICAvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gKCB0eXBlcywgZGF0YSwgZm4gKVxuICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICBkYXRhID0gc2VsZWN0b3I7XG4gICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgZm4gPSByZXR1cm5GYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIWZuKSB7XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgfVxuXG4gICAgICBpZiAob25lID09PSAxKSB7XG4gICAgICAgIG9yaWdGbiA9IGZuO1xuICAgICAgICBmbiA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgICAgICAgLy8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG4gICAgICAgICAgalF1ZXJ5KCkub2ZmKGV2ZW50KTtcbiAgICAgICAgICByZXR1cm4gb3JpZ0ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cbiAgICAgICAgZm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8IChvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKyspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW0uZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGpRdWVyeS5ldmVudC5hZGQodGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3Rvcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAgICAgKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICAgICAqL1xuICAgIGpRdWVyeS5ldmVudCA9IHtcblxuICAgICAgZ2xvYmFsOiB7fSxcblxuICAgICAgYWRkOiBmdW5jdGlvbiAoZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yKSB7XG5cbiAgICAgICAgdmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuICAgICAgICAgIGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuICAgICAgICAgIHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcbiAgICAgICAgICBlbGVtRGF0YSA9IGRhdGFQcml2LmdldChlbGVtKTtcblxuICAgICAgICAvLyBPbmx5IGF0dGFjaCBldmVudHMgdG8gb2JqZWN0cyB0aGF0IGFjY2VwdCBkYXRhXG4gICAgICAgIGlmICghYWNjZXB0RGF0YShlbGVtKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuICAgICAgICBpZiAoaGFuZGxlci5oYW5kbGVyKSB7XG4gICAgICAgICAgaGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuICAgICAgICAgIHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG4gICAgICAgIC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoZG9jdW1lbnRFbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcbiAgICAgICAgaWYgKCFoYW5kbGVyLmd1aWQpIHtcbiAgICAgICAgICBoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICBpZiAoIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpKSB7XG4gICAgICAgICAgZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSkpIHtcbiAgICAgICAgICBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgICAgICAgIC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG4gICAgICAgICAgICAvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoZWxlbSwgYXJndW1lbnRzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuICAgICAgICB0eXBlcyA9ICh0eXBlcyB8fCBcIlwiKS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXCJcIl07XG4gICAgICAgIHQgPSB0eXBlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICh0LS0pIHtcbiAgICAgICAgICB0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKHR5cGVzW3RdKSB8fCBbXTtcbiAgICAgICAgICB0eXBlID0gb3JpZ1R5cGUgPSB0bXBbMV07XG4gICAgICAgICAgbmFtZXNwYWNlcyA9ICh0bXBbMl0gfHwgXCJcIikuc3BsaXQoXCIuXCIpLnNvcnQoKTtcblxuICAgICAgICAgIC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG4gICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW3R5cGVdIHx8IHt9O1xuXG4gICAgICAgICAgLy8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG4gICAgICAgICAgdHlwZSA9IChzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSkgfHwgdHlwZTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcbiAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XG5cbiAgICAgICAgICAvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuICAgICAgICAgIGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoe1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIG9yaWdUeXBlOiBvcmlnVHlwZSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgZ3VpZDogaGFuZGxlci5ndWlkLFxuICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgICAgICAgbmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChzZWxlY3RvciksXG4gICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbihcIi5cIilcbiAgICAgICAgICB9LCBoYW5kbGVPYmpJbik7XG5cbiAgICAgICAgICAvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuICAgICAgICAgIGlmICghKGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdKSkge1xuICAgICAgICAgICAgaGFuZGxlcnMgPSBldmVudHNbdHlwZV0gPSBbXTtcbiAgICAgICAgICAgIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG4gICAgICAgICAgICAvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2VcbiAgICAgICAgICAgIGlmICghc3BlY2lhbC5zZXR1cCB8fFxuICAgICAgICAgICAgICBzcGVjaWFsLnNldHVwLmNhbGwoZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUpID09PSBmYWxzZSkge1xuXG4gICAgICAgICAgICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZXZlbnRIYW5kbGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNwZWNpYWwuYWRkKSB7XG4gICAgICAgICAgICBzcGVjaWFsLmFkZC5jYWxsKGVsZW0sIGhhbmRsZU9iaik7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCkge1xuICAgICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG4gICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmopO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZU9iaik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuICAgICAgICAgIGpRdWVyeS5ldmVudC5nbG9iYWxbdHlwZV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIH0sXG5cbiAgICAgIC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcykge1xuXG4gICAgICAgIHZhciBqLCBvcmlnQ291bnQsIHRtcCxcbiAgICAgICAgICBldmVudHMsIHQsIGhhbmRsZU9iaixcbiAgICAgICAgICBzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG4gICAgICAgICAgZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKGVsZW0pICYmIGRhdGFQcml2LmdldChlbGVtKTtcblxuICAgICAgICBpZiAoIWVsZW1EYXRhIHx8ICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcbiAgICAgICAgdHlwZXMgPSAodHlwZXMgfHwgXCJcIikubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW1wiXCJdO1xuICAgICAgICB0ID0gdHlwZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAodC0tKSB7XG4gICAgICAgICAgdG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyh0eXBlc1t0XSkgfHwgW107XG4gICAgICAgICAgdHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuICAgICAgICAgIG5hbWVzcGFjZXMgPSAodG1wWzJdIHx8IFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCk7XG5cbiAgICAgICAgICAvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcbiAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIGZvciAodHlwZSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZShlbGVtLCB0eXBlICsgdHlwZXNbdF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTtcbiAgICAgICAgICB0eXBlID0gKHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlKSB8fCB0eXBlO1xuICAgICAgICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdIHx8IFtdO1xuICAgICAgICAgIHRtcCA9IHRtcFsyXSAmJlxuICAgICAgICAgICAgbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiKTtcblxuICAgICAgICAgIC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcbiAgICAgICAgICBvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzW2pdO1xuXG4gICAgICAgICAgICBpZiAoKG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUpICYmXG4gICAgICAgICAgICAgICghaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkKSAmJlxuICAgICAgICAgICAgICAoIXRtcCB8fCB0bXAudGVzdChoYW5kbGVPYmoubmFtZXNwYWNlKSkgJiZcbiAgICAgICAgICAgICAgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShqLCAxKTtcblxuICAgICAgICAgICAgICBpZiAoaGFuZGxlT2JqLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzcGVjaWFsLnJlbW92ZSkge1xuICAgICAgICAgICAgICAgIHNwZWNpYWwucmVtb3ZlLmNhbGwoZWxlbSwgaGFuZGxlT2JqKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3RcbiAgICAgICAgICAvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcbiAgICAgICAgICBpZiAob3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghc3BlY2lhbC50ZWFyZG93biB8fFxuICAgICAgICAgICAgICBzcGVjaWFsLnRlYXJkb3duLmNhbGwoZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlKSA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlRXZlbnQoZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuICAgICAgICBpZiAoalF1ZXJ5LmlzRW1wdHlPYmplY3QoZXZlbnRzKSkge1xuICAgICAgICAgIGRhdGFQcml2LnJlbW92ZShlbGVtLCBcImhhbmRsZSBldmVudHNcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAobmF0aXZlRXZlbnQpIHtcblxuICAgICAgICB2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcbiAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpLFxuXG4gICAgICAgICAgLy8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KG5hdGl2ZUV2ZW50KSxcblxuICAgICAgICAgIGhhbmRsZXJzID0gKFxuICAgICAgICAgICAgZGF0YVByaXYuZ2V0KHRoaXMsIFwiZXZlbnRzXCIpIHx8IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgICApW2V2ZW50LnR5cGVdIHx8IFtdLFxuICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFtldmVudC50eXBlXSB8fCB7fTtcblxuICAgICAgICAvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuICAgICAgICBhcmdzWzBdID0gZXZlbnQ7XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuICAgICAgICBpZiAoc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwodGhpcywgZXZlbnQpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBoYW5kbGVyc1xuICAgICAgICBoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLCBldmVudCwgaGFuZGxlcnMpO1xuXG4gICAgICAgIC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoKG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG4gICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgd2hpbGUgKChoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzW2orK10pICYmXG4gICAgICAgICAgICAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG4gICAgICAgICAgICAvLyBzcGVjaWFsbHkgdW5pdmVyc2FsIG9yIGl0cyBuYW1lc3BhY2VzIGFyZSBhIHN1cGVyc2V0IG9mIHRoZSBldmVudCdzLlxuICAgICAgICAgICAgaWYgKCFldmVudC5ybmFtZXNwYWNlIHx8IGhhbmRsZU9iai5uYW1lc3BhY2UgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgIGV2ZW50LnJuYW1lc3BhY2UudGVzdChoYW5kbGVPYmoubmFtZXNwYWNlKSkge1xuXG4gICAgICAgICAgICAgIGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcbiAgICAgICAgICAgICAgZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG4gICAgICAgICAgICAgIHJldCA9ICgoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbaGFuZGxlT2JqLm9yaWdUeXBlXSB8fCB7fSkuaGFuZGxlIHx8XG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqLmhhbmRsZXIpLmFwcGx5KG1hdGNoZWQuZWxlbSwgYXJncyk7XG5cbiAgICAgICAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKChldmVudC5yZXN1bHQgPSByZXQpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcbiAgICAgICAgaWYgKHNwZWNpYWwucG9zdERpc3BhdGNoKSB7XG4gICAgICAgICAgc3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xuICAgICAgfSxcblxuICAgICAgaGFuZGxlcnM6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcnMpIHtcbiAgICAgICAgdmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG4gICAgICAgICAgaGFuZGxlclF1ZXVlID0gW10sXG4gICAgICAgICAgZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG4gICAgICAgICAgY3VyID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgIC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcbiAgICAgICAgaWYgKGRlbGVnYXRlQ291bnQgJiZcblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OVxuICAgICAgICAgIC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuICAgICAgICAgIGN1ci5ub2RlVHlwZSAmJlxuXG4gICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG4gICAgICAgICAgLy8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcbiAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG4gICAgICAgICAgLy8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuICAgICAgICAgICEoZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxKSkge1xuXG4gICAgICAgICAgZm9yICg7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcykge1xuXG4gICAgICAgICAgICAvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKHRyYWMtMTMyMDgpXG4gICAgICAgICAgICAvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAodHJhYy02OTExLCB0cmFjLTgxNjUsIHRyYWMtMTEzODIsIHRyYWMtMTE3NjQpXG4gICAgICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09PSAxICYmICEoZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgbWF0Y2hlZEhhbmRsZXJzID0gW107XG4gICAgICAgICAgICAgIG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzW2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKHRyYWMtMTMyMDMpXG4gICAgICAgICAgICAgICAgc2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZFNlbGVjdG9yc1tzZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoZWRTZWxlY3RvcnNbc2VsXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoc2VsLCB0aGlzKS5pbmRleChjdXIpID4gLTEgOlxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZmluZChzZWwsIHRoaXMsIG51bGwsIFtjdXJdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkU2VsZWN0b3JzW3NlbF0pIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoZWRIYW5kbGVycy5wdXNoKGhhbmRsZU9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXRjaGVkSGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG4gICAgICAgIGN1ciA9IHRoaXM7XG4gICAgICAgIGlmIChkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZShkZWxlZ2F0ZUNvdW50KSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYW5kbGVyUXVldWU7XG4gICAgICB9LFxuXG4gICAgICBhZGRQcm9wOiBmdW5jdGlvbiAobmFtZSwgaG9vaykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgICAgICAgZ2V0OiBpc0Z1bmN0aW9uKGhvb2spID9cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2luYWxFdmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBob29rKHRoaXMub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFtuYW1lXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBmaXg6IGZ1bmN0aW9uIChvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEV2ZW50W2pRdWVyeS5leHBhbmRvXSA/XG4gICAgICAgICAgb3JpZ2luYWxFdmVudCA6XG4gICAgICAgICAgbmV3IGpRdWVyeS5FdmVudChvcmlnaW5hbEV2ZW50KTtcbiAgICAgIH0sXG5cbiAgICAgIHNwZWNpYWw6IHtcbiAgICAgICAgbG9hZDoge1xuXG4gICAgICAgICAgLy8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuICAgICAgICAgIG5vQnViYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGNsaWNrOiB7XG5cbiAgICAgICAgICAvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuICAgICAgICAgIHNldHVwOiBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgICAgICAgICAvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cbiAgICAgICAgICAgIC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cbiAgICAgICAgICAgIC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG4gICAgICAgICAgICBpZiAocmNoZWNrYWJsZVR5cGUudGVzdChlbC50eXBlKSAmJlxuICAgICAgICAgICAgICBlbC5jbGljayAmJiBub2RlTmFtZShlbCwgXCJpbnB1dFwiKSkge1xuXG4gICAgICAgICAgICAgIC8vIGRhdGFQcml2LnNldCggZWwsIFwiY2xpY2tcIiwgLi4uIClcbiAgICAgICAgICAgICAgbGV2ZXJhZ2VOYXRpdmUoZWwsIFwiY2xpY2tcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgICAgICAgICAvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cbiAgICAgICAgICAgIC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyaW5nIGEgY2xpY2tcbiAgICAgICAgICAgIGlmIChyY2hlY2thYmxlVHlwZS50ZXN0KGVsLnR5cGUpICYmXG4gICAgICAgICAgICAgIGVsLmNsaWNrICYmIG5vZGVOYW1lKGVsLCBcImlucHV0XCIpKSB7XG5cbiAgICAgICAgICAgICAgbGV2ZXJhZ2VOYXRpdmUoZWwsIFwiY2xpY2tcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgc3VwcHJlc3MgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG4gICAgICAgICAgLy8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG4gICAgICAgICAgX2RlZmF1bHQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHJldHVybiByY2hlY2thYmxlVHlwZS50ZXN0KHRhcmdldC50eXBlKSAmJlxuICAgICAgICAgICAgICB0YXJnZXQuY2xpY2sgJiYgbm9kZU5hbWUodGFyZ2V0LCBcImlucHV0XCIpICYmXG4gICAgICAgICAgICAgIGRhdGFQcml2LmdldCh0YXJnZXQsIFwiY2xpY2tcIikgfHxcbiAgICAgICAgICAgICAgbm9kZU5hbWUodGFyZ2V0LCBcImFcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJlZm9yZXVubG9hZDoge1xuICAgICAgICAgIHBvc3REaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG4gICAgICAgICAgICAvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG4gICAgICAgICAgICBpZiAoZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCkge1xuICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgdGhlIHByZXNlbmNlIG9mIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaGFuZGxlcyBtYW51YWxseS10cmlnZ2VyZWRcbiAgICAvLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbiAgICAvLyAqbmF0aXZlKiBldmVudHMgdGhhdCBpdCBmaXJlcyBkaXJlY3RseSwgZW5zdXJpbmcgdGhhdCBzdGF0ZSBjaGFuZ2VzIGhhdmVcbiAgICAvLyBhbHJlYWR5IG9jY3VycmVkIGJlZm9yZSBvdGhlciBsaXN0ZW5lcnMgYXJlIGludm9rZWQuXG4gICAgZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoZWwsIHR5cGUsIGlzU2V0dXApIHtcblxuICAgICAgLy8gTWlzc2luZyBgaXNTZXR1cGAgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuICAgICAgaWYgKCFpc1NldHVwKSB7XG4gICAgICAgIGlmIChkYXRhUHJpdi5nZXQoZWwsIHR5cGUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKGVsLCB0eXBlLCByZXR1cm5UcnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcbiAgICAgIGRhdGFQcml2LnNldChlbCwgdHlwZSwgZmFsc2UpO1xuICAgICAgalF1ZXJ5LmV2ZW50LmFkZChlbCwgdHlwZSwge1xuICAgICAgICBuYW1lc3BhY2U6IGZhbHNlLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgc2F2ZWQgPSBkYXRhUHJpdi5nZXQodGhpcywgdHlwZSk7XG5cbiAgICAgICAgICBpZiAoKGV2ZW50LmlzVHJpZ2dlciAmIDEpICYmIHRoaXNbdHlwZV0pIHtcblxuICAgICAgICAgICAgLy8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcbiAgICAgICAgICAgIGlmICghc2F2ZWQpIHtcblxuICAgICAgICAgICAgICAvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcbiAgICAgICAgICAgICAgLy8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IChhbiBldmVudCBvYmplY3QpLCBzbyB0aGlzIGFycmF5XG4gICAgICAgICAgICAgIC8vIHdpbGwgbm90IGJlIGNvbmZ1c2VkIHdpdGggYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdC5cbiAgICAgICAgICAgICAgc2F2ZWQgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIGRhdGFQcml2LnNldCh0aGlzLCB0eXBlLCBzYXZlZCk7XG5cbiAgICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgbmF0aXZlIGV2ZW50IGFuZCBjYXB0dXJlIGl0cyByZXN1bHRcbiAgICAgICAgICAgICAgdGhpc1t0eXBlXSgpO1xuICAgICAgICAgICAgICByZXN1bHQgPSBkYXRhUHJpdi5nZXQodGhpcywgdHlwZSk7XG4gICAgICAgICAgICAgIGRhdGFQcml2LnNldCh0aGlzLCB0eXBlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgaWYgKHNhdmVkICE9PSByZXN1bHQpIHtcblxuICAgICAgICAgICAgICAgIC8vIENhbmNlbCB0aGUgb3V0ZXIgc3ludGhldGljIGV2ZW50XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCBmb3IgYW4gZXZlbnQgd2l0aCBhIGJ1YmJsaW5nIHN1cnJvZ2F0ZVxuICAgICAgICAgICAgICAvLyAoZm9jdXMgb3IgYmx1ciksIGFzc3VtZSB0aGF0IHRoZSBzdXJyb2dhdGUgYWxyZWFkeSBwcm9wYWdhdGVkIGZyb20gdHJpZ2dlcmluZ1xuICAgICAgICAgICAgICAvLyB0aGUgbmF0aXZlIGV2ZW50IGFuZCBwcmV2ZW50IHRoYXQgZnJvbSBoYXBwZW5pbmcgYWdhaW4gaGVyZS5cbiAgICAgICAgICAgICAgLy8gVGhpcyB0ZWNobmljYWxseSBnZXRzIHRoZSBvcmRlcmluZyB3cm9uZyB3LnIudC4gdG8gYC50cmlnZ2VyKClgIChpbiB3aGljaCB0aGVcbiAgICAgICAgICAgICAgLy8gYnViYmxpbmcgc3Vycm9nYXRlIHByb3BhZ2F0ZXMgKmFmdGVyKiB0aGUgbm9uLWJ1YmJsaW5nIGJhc2UpLCBidXQgdGhhdCBzZWVtc1xuICAgICAgICAgICAgICAvLyBsZXNzIGJhZCB0aGFuIGR1cGxpY2F0aW9uLlxuICAgICAgICAgICAgfSBlbHNlIGlmICgoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge30pLmRlbGVnYXRlVHlwZSkge1xuICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5hdGl2ZSBldmVudCB0cmlnZ2VyZWQgYWJvdmUsIGV2ZXJ5dGhpbmcgaXMgbm93IGluIG9yZGVyXG4gICAgICAgICAgICAvLyBGaXJlIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCB3aXRoIHRoZSBvcmlnaW5hbCBhcmd1bWVudHNcbiAgICAgICAgICB9IGVsc2UgaWYgKHNhdmVkKSB7XG5cbiAgICAgICAgICAgIC8vIC4uLmFuZCBjYXB0dXJlIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGRhdGFQcml2LnNldCh0aGlzLCB0eXBlLCBqUXVlcnkuZXZlbnQudHJpZ2dlcihcbiAgICAgICAgICAgICAgc2F2ZWRbMF0sXG4gICAgICAgICAgICAgIHNhdmVkLnNsaWNlKDEpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgLy8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudCBieSBhbGwgalF1ZXJ5IGhhbmRsZXJzIHdoaWxlIGFsbG93aW5nXG4gICAgICAgICAgICAvLyBuYXRpdmUgaGFuZGxlcnMgb24gdGhlIHNhbWUgZWxlbWVudCB0byBydW4uIE9uIHRhcmdldCwgdGhpcyBpcyBhY2hpZXZlZFxuICAgICAgICAgICAgLy8gYnkgc3RvcHBpbmcgaW1tZWRpYXRlIHByb3BhZ2F0aW9uIGp1c3Qgb24gdGhlIGpRdWVyeSBldmVudC4gSG93ZXZlcixcbiAgICAgICAgICAgIC8vIHRoZSBuYXRpdmUgZXZlbnQgaXMgcmUtd3JhcHBlZCBieSBhIGpRdWVyeSBvbmUgb24gZWFjaCBsZXZlbCBvZiB0aGVcbiAgICAgICAgICAgIC8vIHByb3BhZ2F0aW9uIHNvIHRoZSBvbmx5IHdheSB0byBzdG9wIGl0IGZvciBqUXVlcnkgaXMgdG8gc3RvcCBpdCBmb3JcbiAgICAgICAgICAgIC8vIGV2ZXJ5b25lIHZpYSBuYXRpdmUgYHN0b3BQcm9wYWdhdGlvbigpYC4gVGhpcyBpcyBub3QgYSBwcm9ibGVtIGZvclxuICAgICAgICAgICAgLy8gZm9jdXMvYmx1ciB3aGljaCBkb24ndCBidWJibGUsIGJ1dCBpdCBkb2VzIGFsc28gc3RvcCBjbGljayBvbiBjaGVja2JveGVzXG4gICAgICAgICAgICAvLyBhbmQgcmFkaW9zLiBXZSBhY2NlcHQgdGhpcyBsaW1pdGF0aW9uLlxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBqUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgaGFuZGxlKSB7XG5cbiAgICAgIC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuICAgICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgalF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24gKHNyYywgcHJvcHMpIHtcblxuICAgICAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50KSkge1xuICAgICAgICByZXR1cm4gbmV3IGpRdWVyeS5FdmVudChzcmMsIHByb3BzKTtcbiAgICAgIH1cblxuICAgICAgLy8gRXZlbnQgb2JqZWN0XG4gICAgICBpZiAoc3JjICYmIHNyYy50eXBlKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcbiAgICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7XG5cbiAgICAgICAgLy8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcbiAgICAgICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcbiAgICAgICAgICBzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cbiAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcbiAgICAgICAgICBzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cbiAgICAgICAgICByZXR1cm5UcnVlIDpcbiAgICAgICAgICByZXR1cm5GYWxzZTtcblxuICAgICAgICAvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcbiAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuICAgICAgICAvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAodHJhYy01MDQsIHRyYWMtMTMxNDMpXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gKHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMykgP1xuICAgICAgICAgIHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG4gICAgICAgICAgc3JjLnRhcmdldDtcblxuICAgICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgICAgLy8gRXZlbnQgdHlwZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50eXBlID0gc3JjO1xuICAgICAgfVxuXG4gICAgICAvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGpRdWVyeS5leHRlbmQodGhpcywgcHJvcHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuICAgICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG4gICAgICAvLyBNYXJrIGl0IGFzIGZpeGVkXG4gICAgICB0aGlzW2pRdWVyeS5leHBhbmRvXSA9IHRydWU7XG4gICAgfTtcblxuICAgIC8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbiAgICBqUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuICAgICAgY29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcbiAgICAgIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG4gICAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgICBpc1NpbXVsYXRlZDogZmFsc2UsXG5cbiAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgICAgICBpZiAoZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgICAgICBpZiAoZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCkge1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cbiAgICAgICAgaWYgKGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQpIHtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICBhbHRLZXk6IHRydWUsXG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuICAgICAgY3RybEtleTogdHJ1ZSxcbiAgICAgIGRldGFpbDogdHJ1ZSxcbiAgICAgIGV2ZW50UGhhc2U6IHRydWUsXG4gICAgICBtZXRhS2V5OiB0cnVlLFxuICAgICAgcGFnZVg6IHRydWUsXG4gICAgICBwYWdlWTogdHJ1ZSxcbiAgICAgIHNoaWZ0S2V5OiB0cnVlLFxuICAgICAgdmlldzogdHJ1ZSxcbiAgICAgIFwiY2hhclwiOiB0cnVlLFxuICAgICAgY29kZTogdHJ1ZSxcbiAgICAgIGNoYXJDb2RlOiB0cnVlLFxuICAgICAga2V5OiB0cnVlLFxuICAgICAga2V5Q29kZTogdHJ1ZSxcbiAgICAgIGJ1dHRvbjogdHJ1ZSxcbiAgICAgIGJ1dHRvbnM6IHRydWUsXG4gICAgICBjbGllbnRYOiB0cnVlLFxuICAgICAgY2xpZW50WTogdHJ1ZSxcbiAgICAgIG9mZnNldFg6IHRydWUsXG4gICAgICBvZmZzZXRZOiB0cnVlLFxuICAgICAgcG9pbnRlcklkOiB0cnVlLFxuICAgICAgcG9pbnRlclR5cGU6IHRydWUsXG4gICAgICBzY3JlZW5YOiB0cnVlLFxuICAgICAgc2NyZWVuWTogdHJ1ZSxcbiAgICAgIHRhcmdldFRvdWNoZXM6IHRydWUsXG4gICAgICB0b0VsZW1lbnQ6IHRydWUsXG4gICAgICB0b3VjaGVzOiB0cnVlLFxuICAgICAgd2hpY2g6IHRydWVcbiAgICB9LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCk7XG5cbiAgICBqUXVlcnkuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uICh0eXBlLCBkZWxlZ2F0ZVR5cGUpIHtcblxuICAgICAgZnVuY3Rpb24gZm9jdXNNYXBwZWRIYW5kbGVyKG5hdGl2ZUV2ZW50KSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudE1vZGUpIHtcblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExK1xuICAgICAgICAgIC8vIEF0dGFjaCBhIHNpbmdsZSBmb2N1c2luL2ZvY3Vzb3V0IGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHNcbiAgICAgICAgICAvLyBmb2N1cy9ibHVyLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGZvcm1lciBhcmUgc3luY2hyb25vdXMgaW4gSUUgd2hpbGUgdGhlIGxhdHRlclxuICAgICAgICAgIC8vIGFyZSBhc3luYy4gSW4gb3RoZXIgYnJvd3NlcnMsIGFsbCB0aG9zZSBoYW5kbGVycyBhcmUgaW52b2tlZCBzeW5jaHJvbm91c2x5LlxuXG4gICAgICAgICAgLy8gYGhhbmRsZWAgZnJvbSBwcml2YXRlIGRhdGEgd291bGQgYWxyZWFkeSB3cmFwIHRoZSBldmVudCwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAvLyB0byBjaGFuZ2UgdGhlIGB0eXBlYCBoZXJlLlxuICAgICAgICAgIHZhciBoYW5kbGUgPSBkYXRhUHJpdi5nZXQodGhpcywgXCJoYW5kbGVcIiksXG4gICAgICAgICAgICBldmVudCA9IGpRdWVyeS5ldmVudC5maXgobmF0aXZlRXZlbnQpO1xuICAgICAgICAgIGV2ZW50LnR5cGUgPSBuYXRpdmVFdmVudC50eXBlID09PSBcImZvY3VzaW5cIiA/IFwiZm9jdXNcIiA6IFwiYmx1clwiO1xuICAgICAgICAgIGV2ZW50LmlzU2ltdWxhdGVkID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIEZpcnN0LCBoYW5kbGUgZm9jdXNpbi9mb2N1c291dFxuICAgICAgICAgIGhhbmRsZShuYXRpdmVFdmVudCk7XG5cbiAgICAgICAgICAvLyAuLi50aGVuLCBoYW5kbGUgZm9jdXMvYmx1clxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gZm9jdXMvYmx1ciBkb24ndCBidWJibGUgd2hpbGUgZm9jdXNpbi9mb2N1c291dCBkbzsgc2ltdWxhdGUgdGhlIGZvcm1lciBieSBvbmx5XG4gICAgICAgICAgLy8gaW52b2tpbmcgdGhlIGhhbmRsZXIgYXQgdGhlIGxvd2VyIGxldmVsLlxuICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcblxuICAgICAgICAgICAgLy8gVGhlIHNldHVwIHBhcnQgY2FsbHMgYGxldmVyYWdlTmF0aXZlYCwgd2hpY2gsIGluIHR1cm4sIGNhbGxzXG4gICAgICAgICAgICAvLyBgalF1ZXJ5LmV2ZW50LmFkZGAsIHNvIGV2ZW50IGhhbmRsZSB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIHNldFxuICAgICAgICAgICAgLy8gYnkgdGhpcyBwb2ludC5cbiAgICAgICAgICAgIGhhbmRsZShldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gRm9yIG5vbi1JRSBicm93c2VycywgYXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudFxuICAgICAgICAgIC8vIHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dC5cbiAgICAgICAgICBqUXVlcnkuZXZlbnQuc2ltdWxhdGUoZGVsZWdhdGVUeXBlLCBuYXRpdmVFdmVudC50YXJnZXQsXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuZml4KG5hdGl2ZUV2ZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gPSB7XG5cbiAgICAgICAgLy8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG4gICAgICAgIHNldHVwOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICB2YXIgYXR0YWNoZXM7XG5cbiAgICAgICAgICAvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuICAgICAgICAgIC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJmb2N1c1wiLCAuLi4gKVxuICAgICAgICAgIC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG4gICAgICAgICAgbGV2ZXJhZ2VOYXRpdmUodGhpcywgdHlwZSwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcbiAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgc2FtZSBuYXRpdmUgaGFuZGxlciBmb3IgZm9jdXNpbiAmIGZvY3VzIChhbmQgZm9jdXNvdXQgJiBibHVyKVxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBjb29yZGluYXRlIHNldHVwICYgdGVhcmRvd24gcGFydHMgYmV0d2VlbiB0aG9zZSBldmVudHMuXG4gICAgICAgICAgICAvLyBVc2UgYGRlbGVnYXRlVHlwZWAgYXMgdGhlIGtleSBhcyBgdHlwZWAgaXMgYWxyZWFkeSB1c2VkIGJ5IGBsZXZlcmFnZU5hdGl2ZWAuXG4gICAgICAgICAgICBhdHRhY2hlcyA9IGRhdGFQcml2LmdldCh0aGlzLCBkZWxlZ2F0ZVR5cGUpO1xuICAgICAgICAgICAgaWYgKCFhdHRhY2hlcykge1xuICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZGVsZWdhdGVUeXBlLCBmb2N1c01hcHBlZEhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YVByaXYuc2V0KHRoaXMsIGRlbGVnYXRlVHlwZSwgKGF0dGFjaGVzIHx8IDApICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgIC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG4gICAgICAgICAgbGV2ZXJhZ2VOYXRpdmUodGhpcywgdHlwZSk7XG5cbiAgICAgICAgICAvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXR0YWNoZXM7XG5cbiAgICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB7XG4gICAgICAgICAgICBhdHRhY2hlcyA9IGRhdGFQcml2LmdldCh0aGlzLCBkZWxlZ2F0ZVR5cGUpIC0gMTtcbiAgICAgICAgICAgIGlmICghYXR0YWNoZXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgZGF0YVByaXYucmVtb3ZlKHRoaXMsIGRlbGVnYXRlVHlwZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhUHJpdi5zZXQodGhpcywgZGVsZWdhdGVUeXBlLCBhdHRhY2hlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIHRvIGluZGljYXRlIHN0YW5kYXJkIHRlYXJkb3duIHNob3VsZCBiZSBhcHBsaWVkXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFN1cHByZXNzIG5hdGl2ZSBmb2N1cyBvciBibHVyIGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGVcbiAgICAgICAgLy8gYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG4gICAgICAgIF9kZWZhdWx0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YVByaXYuZ2V0KGV2ZW50LnRhcmdldCwgdHlwZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcbiAgICAgIH07XG5cbiAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuICAgICAgLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbiAgICAgIC8vXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbiAgICAgIC8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuICAgICAgLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4gICAgICAvLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuICAgICAgLy9cbiAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcbiAgICAgIC8vIFRvIHByZXNlcnZlIHJlbGF0aXZlIGZvY3VzaW4vZm9jdXMgJiBmb2N1c291dC9ibHVyIGV2ZW50IG9yZGVyIGd1YXJhbnRlZWQgb24gdGhlIDMueCBicmFuY2gsXG4gICAgICAvLyBhdHRhY2ggYSBzaW5nbGUgaGFuZGxlciBmb3IgYm90aCBldmVudHMgaW4gSUUuXG4gICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtkZWxlZ2F0ZVR5cGVdID0ge1xuICAgICAgICBzZXR1cDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgLy8gSGFuZGxlOiByZWd1bGFyIG5vZGVzICh2aWEgYHRoaXMub3duZXJEb2N1bWVudGApLCB3aW5kb3dcbiAgICAgICAgICAvLyAodmlhIGB0aGlzLmRvY3VtZW50YCkgJiBkb2N1bWVudCAodmlhIGB0aGlzYCkuXG4gICAgICAgICAgdmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG4gICAgICAgICAgICBkYXRhSG9sZGVyID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlID8gdGhpcyA6IGRvYyxcbiAgICAgICAgICAgIGF0dGFjaGVzID0gZGF0YVByaXYuZ2V0KGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSk7XG5cbiAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG4gICAgICAgICAgLy8gV2UgdXNlIHRoZSBzYW1lIG5hdGl2ZSBoYW5kbGVyIGZvciBmb2N1c2luICYgZm9jdXMgKGFuZCBmb2N1c291dCAmIGJsdXIpXG4gICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBjb29yZGluYXRlIHNldHVwICYgdGVhcmRvd24gcGFydHMgYmV0d2VlbiB0aG9zZSBldmVudHMuXG4gICAgICAgICAgLy8gVXNlIGBkZWxlZ2F0ZVR5cGVgIGFzIHRoZSBrZXkgYXMgYHR5cGVgIGlzIGFscmVhZHkgdXNlZCBieSBgbGV2ZXJhZ2VOYXRpdmVgLlxuICAgICAgICAgIGlmICghYXR0YWNoZXMpIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudE1vZGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFQcml2LnNldChkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUsIChhdHRhY2hlcyB8fCAwKSArIDEpO1xuICAgICAgICB9LFxuICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuICAgICAgICAgICAgZGF0YUhvbGRlciA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSA/IHRoaXMgOiBkb2MsXG4gICAgICAgICAgICBhdHRhY2hlcyA9IGRhdGFQcml2LmdldChkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUpIC0gMTtcblxuICAgICAgICAgIGlmICghYXR0YWNoZXMpIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudE1vZGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGRlbGVnYXRlVHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YVByaXYuc2V0KGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSwgYXR0YWNoZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuICAgIC8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4gICAgLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbiAgICAvL1xuICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbiAgICAvLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbiAgICAvLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxuICAgIGpRdWVyeS5lYWNoKHtcbiAgICAgIG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG4gICAgICBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG4gICAgICBwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcbiAgICAgIHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbiAgICB9LCBmdW5jdGlvbiAob3JpZywgZml4KSB7XG4gICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtvcmlnXSA9IHtcbiAgICAgICAgZGVsZWdhdGVUeXBlOiBmaXgsXG4gICAgICAgIGJpbmRUeXBlOiBmaXgsXG5cbiAgICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgcmV0LFxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcyxcbiAgICAgICAgICAgIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuICAgICAgICAgICAgaGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG4gICAgICAgICAgLy8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cbiAgICAgICAgICAvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuICAgICAgICAgIGlmICghcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnModGFyZ2V0LCByZWxhdGVkKSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG4gICAgICAgICAgICByZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgZXZlbnQudHlwZSA9IGZpeDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuXG4gICAgICBvbjogZnVuY3Rpb24gKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pIHtcbiAgICAgICAgcmV0dXJuIG9uKHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pO1xuICAgICAgfSxcbiAgICAgIG9uZTogZnVuY3Rpb24gKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pIHtcbiAgICAgICAgcmV0dXJuIG9uKHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEpO1xuICAgICAgfSxcbiAgICAgIG9mZjogZnVuY3Rpb24gKHR5cGVzLCBzZWxlY3RvciwgZm4pIHtcbiAgICAgICAgdmFyIGhhbmRsZU9iaiwgdHlwZTtcbiAgICAgICAgaWYgKHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaikge1xuXG4gICAgICAgICAgLy8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuICAgICAgICAgIGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcbiAgICAgICAgICBqUXVlcnkodHlwZXMuZGVsZWdhdGVUYXJnZXQpLm9mZihcbiAgICAgICAgICAgIGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuICAgICAgICAgICAgICBoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuICAgICAgICAgICAgICBoYW5kbGVPYmoub3JpZ1R5cGUsXG4gICAgICAgICAgICBoYW5kbGVPYmouc2VsZWN0b3IsXG4gICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlclxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIikge1xuXG4gICAgICAgICAgLy8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcbiAgICAgICAgICBmb3IgKHR5cGUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKHR5cGUsIHNlbGVjdG9yLCB0eXBlc1t0eXBlXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcblxuICAgICAgICAgIC8vICggdHlwZXMgWywgZm5dIClcbiAgICAgICAgICBmbiA9IHNlbGVjdG9yO1xuICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBmbiA9IHJldHVybkZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUodGhpcywgdHlwZXMsIGZuLCBzZWxlY3Rvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICB2YXJcblxuICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuICAgICAgLy8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cbiAgICAgIC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG4gICAgICBybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuICAgICAgLy8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG4gICAgICByY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cbiAgICAgIHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhXFxbQ0RBVEFcXFt8XFxdXFxdPlxccyokL2c7XG5cbiAgICAvLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbiAgICBmdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoZWxlbSwgY29udGVudCkge1xuICAgICAgaWYgKG5vZGVOYW1lKGVsZW0sIFwidGFibGVcIikgJiZcbiAgICAgICAgbm9kZU5hbWUoY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIpKSB7XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeShlbGVtKS5jaGlsZHJlbihcInRib2R5XCIpWzBdIHx8IGVsZW07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cblxuICAgIC8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbiAgICBmdW5jdGlvbiBkaXNhYmxlU2NyaXB0KGVsZW0pIHtcbiAgICAgIGVsZW0udHlwZSA9IChlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikgIT09IG51bGwpICsgXCIvXCIgKyBlbGVtLnR5cGU7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzdG9yZVNjcmlwdChlbGVtKSB7XG4gICAgICBpZiAoKGVsZW0udHlwZSB8fCBcIlwiKS5zbGljZSgwLCA1KSA9PT0gXCJ0cnVlL1wiKSB7XG4gICAgICAgIGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSg1KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoc3JjLCBkZXN0KSB7XG4gICAgICB2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG4gICAgICBpZiAoZGVzdC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG4gICAgICBpZiAoZGF0YVByaXYuaGFzRGF0YShzcmMpKSB7XG4gICAgICAgIHBkYXRhT2xkID0gZGF0YVByaXYuZ2V0KHNyYyk7XG4gICAgICAgIGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuICAgICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgICAgZGF0YVByaXYucmVtb3ZlKGRlc3QsIFwiaGFuZGxlIGV2ZW50c1wiKTtcblxuICAgICAgICAgIGZvciAodHlwZSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBldmVudHNbdHlwZV0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoZGVzdCwgdHlwZSwgZXZlbnRzW3R5cGVdW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gMi4gQ29weSB1c2VyIGRhdGFcbiAgICAgIGlmIChkYXRhVXNlci5oYXNEYXRhKHNyYykpIHtcbiAgICAgICAgdWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3Moc3JjKTtcbiAgICAgICAgdWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKHt9LCB1ZGF0YU9sZCk7XG5cbiAgICAgICAgZGF0YVVzZXIuc2V0KGRlc3QsIHVkYXRhQ3VyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbiAgICBmdW5jdGlvbiBmaXhJbnB1dChzcmMsIGRlc3QpIHtcbiAgICAgIHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgLy8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG4gICAgICBpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KHNyYy50eXBlKSkge1xuICAgICAgICBkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuICAgICAgICAvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuICAgICAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIpIHtcbiAgICAgICAgZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvbU1hbmlwKGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkKSB7XG5cbiAgICAgIC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcbiAgICAgIGFyZ3MgPSBmbGF0KGFyZ3MpO1xuXG4gICAgICB2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBsID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGlOb0Nsb25lID0gbCAtIDEsXG4gICAgICAgIHZhbHVlID0gYXJnc1swXSxcbiAgICAgICAgdmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbih2YWx1ZSk7XG5cbiAgICAgIC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuICAgICAgaWYgKHZhbHVlSXNGdW5jdGlvbiB8fFxuICAgICAgICAobCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgIXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoaW5kZXgpO1xuICAgICAgICAgIGlmICh2YWx1ZUlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB2YWx1ZS5jYWxsKHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvbU1hbmlwKHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsKSB7XG4gICAgICAgIGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudChhcmdzLCBjb2xsZWN0aW9uWzBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkKTtcbiAgICAgICAgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG4gICAgICAgIGlmIChmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGZyYWdtZW50ID0gZmlyc3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcbiAgICAgICAgaWYgKGZpcnN0IHx8IGlnbm9yZWQpIHtcbiAgICAgICAgICBzY3JpcHRzID0galF1ZXJ5Lm1hcChnZXRBbGwoZnJhZ21lbnQsIFwic2NyaXB0XCIpLCBkaXNhYmxlU2NyaXB0KTtcbiAgICAgICAgICBoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cbiAgICAgICAgICAvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG4gICAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG4gICAgICAgICAgLy8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKHRyYWMtODA3MCkuXG4gICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIG5vZGUgPSBmcmFnbWVudDtcblxuICAgICAgICAgICAgaWYgKGkgIT09IGlOb0Nsb25lKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBqUXVlcnkuY2xvbmUobm9kZSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgLy8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuICAgICAgICAgICAgICBpZiAoaGFzU2NyaXB0cykge1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG4gICAgICAgICAgICAgICAgLy8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZShzY3JpcHRzLCBnZXRBbGwobm9kZSwgXCJzY3JpcHRcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY29sbGVjdGlvbltpXSwgbm9kZSwgaSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhc1NjcmlwdHMpIHtcbiAgICAgICAgICAgIGRvYyA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5vd25lckRvY3VtZW50O1xuXG4gICAgICAgICAgICAvLyBSZS1lbmFibGUgc2NyaXB0c1xuICAgICAgICAgICAgalF1ZXJ5Lm1hcChzY3JpcHRzLCByZXN0b3JlU2NyaXB0KTtcblxuICAgICAgICAgICAgLy8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKykge1xuICAgICAgICAgICAgICBub2RlID0gc2NyaXB0c1tpXTtcbiAgICAgICAgICAgICAgaWYgKHJzY3JpcHRUeXBlLnRlc3Qobm9kZS50eXBlIHx8IFwiXCIpICYmXG4gICAgICAgICAgICAgICAgIWRhdGFQcml2LmFjY2Vzcyhub2RlLCBcImdsb2JhbEV2YWxcIikgJiZcbiAgICAgICAgICAgICAgICBqUXVlcnkuY29udGFpbnMoZG9jLCBub2RlKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc3JjICYmIChub2RlLnR5cGUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSAhPT0gXCJtb2R1bGVcIikge1xuXG4gICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5fZXZhbFVybCAmJiAhbm9kZS5ub01vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX2V2YWxVcmwobm9kZS5zcmMsIHtcbiAgICAgICAgICAgICAgICAgICAgICBub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZShcIm5vbmNlXCIpXG4gICAgICAgICAgICAgICAgICAgIH0sIGRvYyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgLy8gVW53cmFwIGEgQ0RBVEEgc2VjdGlvbiBjb250YWluaW5nIHNjcmlwdCBjb250ZW50cy4gVGhpcyBzaG91bGRuJ3QgYmVcbiAgICAgICAgICAgICAgICAgIC8vIG5lZWRlZCBhcyBpbiBYTUwgZG9jdW1lbnRzIHRoZXkncmUgYWxyZWFkeSBub3QgdmlzaWJsZSB3aGVuXG4gICAgICAgICAgICAgICAgICAvLyBpbnNwZWN0aW5nIGVsZW1lbnQgY29udGVudHMgYW5kIGluIEhUTUwgZG9jdW1lbnRzIHRoZXkgaGF2ZSBub1xuICAgICAgICAgICAgICAgICAgLy8gbWVhbmluZyBidXQgd2UncmUgcHJlc2VydmluZyB0aGF0IGxvZ2ljIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSByZW1vdmVkIGNvbXBsZXRlbHkgaW4gNC4wLiBTZWUgZ2gtNDkwNC5cbiAgICAgICAgICAgICAgICAgIERPTUV2YWwobm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKHJjbGVhblNjcmlwdCwgXCJcIiksIG5vZGUsIGRvYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZShlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEpIHtcbiAgICAgIHZhciBub2RlLFxuICAgICAgICBub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlcihzZWxlY3RvciwgZWxlbSkgOiBlbGVtLFxuICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IChub2RlID0gbm9kZXNbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgICBpZiAoIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGdldEFsbChub2RlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgaWYgKGtlZXBEYXRhICYmIGlzQXR0YWNoZWQobm9kZSkpIHtcbiAgICAgICAgICAgIHNldEdsb2JhbEV2YWwoZ2V0QWxsKG5vZGUsIFwic2NyaXB0XCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgaHRtbFByZWZpbHRlcjogZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICB9LFxuXG4gICAgICBjbG9uZTogZnVuY3Rpb24gKGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzKSB7XG4gICAgICAgIHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuICAgICAgICAgIGNsb25lID0gZWxlbS5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgICAgaW5QYWdlID0gaXNBdHRhY2hlZChlbGVtKTtcblxuICAgICAgICAvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcbiAgICAgICAgaWYgKCFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExKSAmJlxuICAgICAgICAgICFqUXVlcnkuaXNYTUxEb2MoZWxlbSkpIHtcblxuICAgICAgICAgIC8vIFdlIGVzY2hldyBqUXVlcnkjZmluZCBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOlxuICAgICAgICAgIC8vIGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcbiAgICAgICAgICBkZXN0RWxlbWVudHMgPSBnZXRBbGwoY2xvbmUpO1xuICAgICAgICAgIHNyY0VsZW1lbnRzID0gZ2V0QWxsKGVsZW0pO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZml4SW5wdXQoc3JjRWxlbWVudHNbaV0sIGRlc3RFbGVtZW50c1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuICAgICAgICBpZiAoZGF0YUFuZEV2ZW50cykge1xuICAgICAgICAgIGlmIChkZWVwRGF0YUFuZEV2ZW50cykge1xuICAgICAgICAgICAgc3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoZWxlbSk7XG4gICAgICAgICAgICBkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKGNsb25lKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICBjbG9uZUNvcHlFdmVudChzcmNFbGVtZW50c1tpXSwgZGVzdEVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xvbmVDb3B5RXZlbnQoZWxlbSwgY2xvbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcbiAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKGNsb25lLCBcInNjcmlwdFwiKTtcbiAgICAgICAgaWYgKGRlc3RFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2V0R2xvYmFsRXZhbChkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKGVsZW0sIFwic2NyaXB0XCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICB9LFxuXG4gICAgICBjbGVhbkRhdGE6IGZ1bmN0aW9uIChlbGVtcykge1xuICAgICAgICB2YXIgZGF0YSwgZWxlbSwgdHlwZSxcbiAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgZm9yICg7IChlbGVtID0gZWxlbXNbaV0pICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICAgIGlmIChhY2NlcHREYXRhKGVsZW0pKSB7XG4gICAgICAgICAgICBpZiAoKGRhdGEgPSBlbGVtW2RhdGFQcml2LmV4cGFuZG9dKSkge1xuICAgICAgICAgICAgICBpZiAoZGF0YS5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHR5cGUgaW4gZGF0YS5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoZWxlbSwgdHlwZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUV2ZW50KGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuICAgICAgICAgICAgICAvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcbiAgICAgICAgICAgICAgZWxlbVtkYXRhUHJpdi5leHBhbmRvXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtW2RhdGFVc2VyLmV4cGFuZG9dKSB7XG5cbiAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcbiAgICAgICAgICAgICAgLy8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG4gICAgICAgICAgICAgIGVsZW1bZGF0YVVzZXIuZXhwYW5kb10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgIGRldGFjaDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiByZW1vdmUodGhpcywgc2VsZWN0b3IsIHRydWUpO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZSh0aGlzLCBzZWxlY3Rvcik7XG4gICAgICB9LFxuXG4gICAgICB0ZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBqUXVlcnkudGV4dCh0aGlzKSA6XG4gICAgICAgICAgICB0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICB9LFxuXG4gICAgICBhcHBlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KHRoaXMsIGVsZW0pO1xuICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBwcmVwZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb21NYW5pcCh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCh0aGlzLCBlbGVtKTtcbiAgICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBiZWZvcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW0sIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBhZnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZG9tTWFuaXAodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbSwgdGhpcy5uZXh0U2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgIGZvciAoOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGdldEFsbChlbGVtLCBmYWxzZSkpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuICAgICAgICAgICAgZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBjbG9uZTogZnVuY3Rpb24gKGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzKSB7XG4gICAgICAgIGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG4gICAgICAgIGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBqUXVlcnkuY2xvbmUodGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIGh0bWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBlbGVtID0gdGhpc1swXSB8fCB7fSxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbCA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCh2YWx1ZSkgJiZcbiAgICAgICAgICAgICF3cmFwTWFwWyhydGFnTmFtZS5leGVjKHZhbHVlKSB8fCBbXCJcIiwgXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCldKSB7XG5cbiAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIodmFsdWUpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzW2ldIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoZ2V0QWxsKGVsZW0sIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVsZW0gPSAwO1xuXG4gICAgICAgICAgICAgIC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgIHRoaXMuZW1wdHkoKS5hcHBlbmQodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgfSxcblxuICAgICAgcmVwbGFjZVdpdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlnbm9yZWQgPSBbXTtcblxuICAgICAgICAvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcbiAgICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgaWYgKGpRdWVyeS5pbkFycmF5KHRoaXMsIGlnbm9yZWQpIDwgMCkge1xuICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YShnZXRBbGwodGhpcykpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGVsZW0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cbiAgICAgICAgfSwgaWdub3JlZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICBhcHBlbmRUbzogXCJhcHBlbmRcIixcbiAgICAgIHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG4gICAgICBpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG4gICAgICBpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuICAgICAgcmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG4gICAgfSwgZnVuY3Rpb24gKG5hbWUsIG9yaWdpbmFsKSB7XG4gICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGVsZW1zLFxuICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgIGluc2VydCA9IGpRdWVyeShzZWxlY3RvciksXG4gICAgICAgICAgbGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgIGZvciAoOyBpIDw9IGxhc3Q7IGkrKykge1xuICAgICAgICAgIGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKHRydWUpO1xuICAgICAgICAgIGpRdWVyeShpbnNlcnRbaV0pW29yaWdpbmFsXShlbGVtcyk7XG5cbiAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcbiAgICAgICAgICAvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICAgICAgcHVzaC5hcHBseShyZXQsIGVsZW1zLmdldCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhyZXQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIpO1xuXG4gICAgdmFyIHJjdXN0b21Qcm9wID0gL14tLS87XG5cblxuICAgIHZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiAoZWxlbSkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAodHJhYy0xNTA5OCwgdHJhYy0xNDE1MClcbiAgICAgIC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuICAgICAgLy8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG4gICAgICB2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuICAgICAgaWYgKCF2aWV3IHx8ICF2aWV3Lm9wZW5lcikge1xuICAgICAgICB2aWV3ID0gd2luZG93O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuICAgIH07XG5cbiAgICB2YXIgc3dhcCA9IGZ1bmN0aW9uIChlbGVtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHJldCwgbmFtZSxcbiAgICAgICAgb2xkID0ge307XG5cbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuICAgICAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgb2xkW25hbWVdID0gZWxlbS5zdHlsZVtuYW1lXTtcbiAgICAgICAgZWxlbS5zdHlsZVtuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIHJldCA9IGNhbGxiYWNrLmNhbGwoZWxlbSk7XG5cbiAgICAgIC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuICAgICAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgZWxlbS5zdHlsZVtuYW1lXSA9IG9sZFtuYW1lXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG5cbiAgICB2YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cChjc3NFeHBhbmQuam9pbihcInxcIiksIFwiaVwiKTtcblxuXG5cbiAgICAoZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcbiAgICAgIC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG4gICAgICBmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuICAgICAgICAvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG4gICAgICAgIGlmICghZGl2KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG4gICAgICAgICAgXCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcbiAgICAgICAgZGl2LnN0eWxlLmNzc1RleHQgPVxuICAgICAgICAgIFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcbiAgICAgICAgICBcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuICAgICAgICAgIFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuICAgICAgICBkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGFpbmVyKS5hcHBlbmRDaGlsZChkaXYpO1xuXG4gICAgICAgIHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRpdik7XG4gICAgICAgIHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG4gICAgICAgIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyhkaXZTdHlsZS5tYXJnaW5MZWZ0KSA9PT0gMTI7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG4gICAgICAgIC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuICAgICAgICBkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuICAgICAgICBwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyhkaXZTdHlsZS5yaWdodCkgPT09IDM2O1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG4gICAgICAgIC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcbiAgICAgICAgYm94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoZGl2U3R5bGUud2lkdGgpID09PSAzNjtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IG9ubHlcbiAgICAgICAgLy8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuICAgICAgICAvLyBEb24ndCBnZXQgdHJpY2tlZCB3aGVuIHpvb20gYWZmZWN0cyBvZmZzZXRXaWR0aCAoZ2gtNDAyOSlcbiAgICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKGRpdi5vZmZzZXRXaWR0aCAvIDMpID09PSAxMjtcblxuICAgICAgICBkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcblxuICAgICAgICAvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG4gICAgICAgIC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcbiAgICAgICAgZGl2ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKG1lYXN1cmUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChtZWFzdXJlKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG4gICAgICAgIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG4gICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAgIC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG4gICAgICBpZiAoIWRpdi5zdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcbiAgICAgIC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICh0cmFjLTg5MDgpXG4gICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG4gICAgICBkaXYuY2xvbmVOb2RlKHRydWUpLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcbiAgICAgIHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cbiAgICAgIGpRdWVyeS5leHRlbmQoc3VwcG9ydCwge1xuICAgICAgICBib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgICAgcmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuICAgICAgICB9LFxuICAgICAgICBwaXhlbEJveFN0eWxlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgICAgcmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xuICAgICAgICB9LFxuICAgICAgICBwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgICByZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgICByZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuICAgICAgICB9LFxuICAgICAgICBzY3JvbGxib3hTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgICByZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDE1IC0gMTgrXG4gICAgICAgIC8vIElFL0VkZ2UgbWlzcmVwb3J0IGBnZXRDb21wdXRlZFN0eWxlYCBvZiB0YWJsZSByb3dzIHdpdGggd2lkdGgvaGVpZ2h0XG4gICAgICAgIC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuICAgICAgICAvLyBCZWhhdmlvciBpbiBJRSA5IGlzIG1vcmUgc3VidGxlIHRoYW4gaW4gbmV3ZXIgdmVyc2lvbnMgJiBpdCBwYXNzZXNcbiAgICAgICAgLy8gc29tZSB2ZXJzaW9ucyBvZiB0aGlzIHRlc3Q7IG1ha2Ugc3VyZSBub3QgdG8gbWFrZSBpdCBwYXNzIHRoZXJlIVxuICAgICAgICAvL1xuICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDcwK1xuICAgICAgICAvLyBPbmx5IEZpcmVmb3ggaW5jbHVkZXMgYm9yZGVyIHdpZHRoc1xuICAgICAgICAvLyBpbiBjb21wdXRlZCBkaW1lbnNpb25zLiAoZ2gtNDUyOSlcbiAgICAgICAgcmVsaWFibGVUckRpbWVuc2lvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdGFibGUsIHRyLCB0ckNoaWxkLCB0clN0eWxlO1xuICAgICAgICAgIGlmIChyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKTtcbiAgICAgICAgICAgIHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xuICAgICAgICAgICAgdHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAgICAgICAgIHRhYmxlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7Ym9yZGVyLWNvbGxhcHNlOnNlcGFyYXRlXCI7XG4gICAgICAgICAgICB0ci5zdHlsZS5jc3NUZXh0ID0gXCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JvcmRlcjoxcHggc29saWRcIjtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDg2K1xuICAgICAgICAgICAgLy8gSGVpZ2h0IHNldCB0aHJvdWdoIGNzc1RleHQgZG9lcyBub3QgZ2V0IGFwcGxpZWQuXG4gICAgICAgICAgICAvLyBDb21wdXRlZCBoZWlnaHQgdGhlbiBjb21lcyBiYWNrIGFzIDAuXG4gICAgICAgICAgICB0ci5zdHlsZS5oZWlnaHQgPSBcIjFweFwiO1xuICAgICAgICAgICAgdHJDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjlweFwiO1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDggQ2hyb21lIDg2K1xuICAgICAgICAgICAgLy8gSW4gb3VyIGJvZHlCYWNrZ3JvdW5kLmh0bWwgaWZyYW1lLFxuICAgICAgICAgICAgLy8gZGlzcGxheSBmb3IgYWxsIGRpdiBlbGVtZW50cyBpcyBzZXQgdG8gXCJpbmxpbmVcIixcbiAgICAgICAgICAgIC8vIHdoaWNoIGNhdXNlcyBhIHByb2JsZW0gb25seSBpbiBBbmRyb2lkIDggQ2hyb21lIDg2LlxuICAgICAgICAgICAgLy8gRW5zdXJpbmcgdGhlIGRpdiBpcyBgZGlzcGxheTogYmxvY2tgXG4gICAgICAgICAgICAvLyBnZXRzIGFyb3VuZCB0aGlzIGlzc3VlLlxuICAgICAgICAgICAgdHJDaGlsZC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gICAgICAgICAgICBkb2N1bWVudEVsZW1lbnRcbiAgICAgICAgICAgICAgLmFwcGVuZENoaWxkKHRhYmxlKVxuICAgICAgICAgICAgICAuYXBwZW5kQ2hpbGQodHIpXG4gICAgICAgICAgICAgIC5hcHBlbmRDaGlsZCh0ckNoaWxkKTtcblxuICAgICAgICAgICAgdHJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRyKTtcbiAgICAgICAgICAgIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID0gKHBhcnNlSW50KHRyU3R5bGUuaGVpZ2h0LCAxMCkgK1xuICAgICAgICAgICAgICBwYXJzZUludCh0clN0eWxlLmJvcmRlclRvcFdpZHRoLCAxMCkgK1xuICAgICAgICAgICAgICBwYXJzZUludCh0clN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkpID09PSB0ci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0YWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkoKTtcblxuXG4gICAgZnVuY3Rpb24gY3VyQ1NTKGVsZW0sIG5hbWUsIGNvbXB1dGVkKSB7XG4gICAgICB2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuICAgICAgICBpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KG5hbWUpLFxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG4gICAgICAgIC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcbiAgICAgICAgLy8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuICAgICAgICAvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuICAgICAgICBzdHlsZSA9IGVsZW0uc3R5bGU7XG5cbiAgICAgIGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKGVsZW0pO1xuXG4gICAgICAvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG4gICAgICAvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksIHRyYWMtMTI1MzcpXG4gICAgICAvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpIChnaC0zMTQ0KVxuICAgICAgaWYgKGNvbXB1dGVkKSB7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4gICAgICAgIC8vIElFIG9ubHkgc3VwcG9ydHMgYFwiZmxvYXRcImAgaW4gYGdldFByb3BlcnR5VmFsdWVgOyBpbiBjb21wdXRlZCBzdHlsZXNcbiAgICAgICAgLy8gaXQncyBvbmx5IGF2YWlsYWJsZSBhcyBgXCJjc3NGbG9hdFwiYC4gV2Ugbm8gbG9uZ2VyIG1vZGlmeSBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIHNlbnQgdG8gYC5jc3MoKWAgYXBhcnQgZnJvbSBjYW1lbENhc2luZywgc28gd2UgbmVlZCB0byBjaGVjayBib3RoLlxuICAgICAgICAvLyBOb3JtYWxseSwgdGhpcyB3b3VsZCBjcmVhdGUgZGlmZmVyZW5jZSBpbiBiZWhhdmlvcjogaWZcbiAgICAgICAgLy8gYGdldFByb3BlcnR5VmFsdWVgIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLCB0aGUgdmFsdWUgcmV0dXJuZWRcbiAgICAgICAgLy8gYnkgYC5jc3MoKWAgd291bGQgYmUgYHVuZGVmaW5lZGAuIFRoaXMgaXMgdXN1YWxseSB0aGUgY2FzZSBmb3JcbiAgICAgICAgLy8gZGlzY29ubmVjdGVkIGVsZW1lbnRzLiBIb3dldmVyLCBpbiBJRSBldmVuIGRpc2Nvbm5lY3RlZCBlbGVtZW50c1xuICAgICAgICAvLyB3aXRoIG5vIHN0eWxlcyByZXR1cm4gYFwibm9uZVwiYCBmb3IgYGdldFByb3BlcnR5VmFsdWUoIFwiZmxvYXRcIiApYFxuICAgICAgICByZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpIHx8IGNvbXB1dGVkW25hbWVdO1xuXG4gICAgICAgIGlmIChpc0N1c3RvbVByb3AgJiYgcmV0KSB7XG5cbiAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDEwNSssIENocm9tZSA8PTEwNStcbiAgICAgICAgICAvLyBTcGVjIHJlcXVpcmVzIHRyaW1taW5nIHdoaXRlc3BhY2UgZm9yIGN1c3RvbSBwcm9wZXJ0aWVzIChnaC00OTI2KS5cbiAgICAgICAgICAvLyBGaXJlZm94IG9ubHkgdHJpbXMgbGVhZGluZyB3aGl0ZXNwYWNlLiBDaHJvbWUganVzdCBjb2xsYXBzZXNcbiAgICAgICAgICAvLyBib3RoIGxlYWRpbmcgJiB0cmFpbGluZyB3aGl0ZXNwYWNlIHRvIGEgc2luZ2xlIHNwYWNlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGB1bmRlZmluZWRgIGlmIGVtcHR5IHN0cmluZyByZXR1cm5lZC5cbiAgICAgICAgICAvLyBUaGlzIGNvbGxhcHNlcyBhIG1pc3NpbmcgZGVmaW5pdGlvbiB3aXRoIHByb3BlcnR5IGRlZmluZWRcbiAgICAgICAgICAvLyBhbmQgc2V0IHRvIGFuIGVtcHR5IHN0cmluZyBidXQgdGhlcmUncyBubyBzdGFuZGFyZCBBUElcbiAgICAgICAgICAvLyBhbGxvd2luZyB1cyB0byBkaWZmZXJlbnRpYXRlIHRoZW0gd2l0aG91dCBhIHBlcmZvcm1hbmNlIHBlbmFsdHlcbiAgICAgICAgICAvLyBhbmQgcmV0dXJuaW5nIGB1bmRlZmluZWRgIGFsaWducyB3aXRoIG9sZGVyIGpRdWVyeS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIHJ0cmltQ1NTIHRyZWF0cyBVKzAwMEQgQ0FSUklBR0UgUkVUVVJOIGFuZCBVKzAwMEMgRk9STSBGRUVEXG4gICAgICAgICAgLy8gYXMgd2hpdGVzcGFjZSB3aGlsZSBDU1MgZG9lcyBub3QsIGJ1dCB0aGlzIGlzIG5vdCBhIHByb2JsZW1cbiAgICAgICAgICAvLyBiZWNhdXNlIENTUyBwcmVwcm9jZXNzaW5nIHJlcGxhY2VzIHRoZW0gd2l0aCBVKzAwMEEgTElORSBGRUVEXG4gICAgICAgICAgLy8gKHdoaWNoICppcyogQ1NTIHdoaXRlc3BhY2UpXG4gICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jaW5wdXQtcHJlcHJvY2Vzc2luZ1xuICAgICAgICAgIHJldCA9IHJldC5yZXBsYWNlKHJ0cmltQ1NTLCBcIiQxXCIpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXQgPT09IFwiXCIgJiYgIWlzQXR0YWNoZWQoZWxlbSkpIHtcbiAgICAgICAgICByZXQgPSBqUXVlcnkuc3R5bGUoZWxlbSwgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG4gICAgICAgIC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuICAgICAgICAvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuICAgICAgICAvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG4gICAgICAgIGlmICghc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KHJldCkgJiYgcmJveFN0eWxlLnRlc3QobmFtZSkpIHtcblxuICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgICB3aWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgICAgIG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG4gICAgICAgICAgbWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuICAgICAgICAgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcbiAgICAgICAgICBzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG4gICAgICAgICAgcmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cbiAgICAgICAgICAvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG4gICAgICAgICAgc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICBzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuICAgICAgICAgIHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG4gICAgICAgIC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG4gICAgICAgIHJldCArIFwiXCIgOlxuICAgICAgICByZXQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBhZGRHZXRIb29rSWYoY29uZGl0aW9uRm4sIGhvb2tGbikge1xuXG4gICAgICAvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNvbmRpdGlvbkZuKCkpIHtcblxuICAgICAgICAgICAgLy8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG4gICAgICAgICAgICAvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5nZXQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG4gICAgICAgICAgcmV0dXJuICh0aGlzLmdldCA9IGhvb2tGbikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cblxuICAgIHZhciBjc3NQcmVmaXhlcyA9IFtcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCJdLFxuICAgICAgZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUsXG4gICAgICB2ZW5kb3JQcm9wcyA9IHt9O1xuXG4gICAgLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxuICAgIGZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKG5hbWUpIHtcblxuICAgICAgLy8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuICAgICAgdmFyIGNhcE5hbWUgPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLFxuICAgICAgICBpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIG5hbWUgPSBjc3NQcmVmaXhlc1tpXSArIGNhcE5hbWU7XG4gICAgICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG4gICAgZnVuY3Rpb24gZmluYWxQcm9wTmFtZShuYW1lKSB7XG4gICAgICB2YXIgZmluYWwgPSBqUXVlcnkuY3NzUHJvcHNbbmFtZV0gfHwgdmVuZG9yUHJvcHNbbmFtZV07XG5cbiAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICByZXR1cm4gZmluYWw7XG4gICAgICB9XG4gICAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZlbmRvclByb3BzW25hbWVdID0gdmVuZG9yUHJvcE5hbWUobmFtZSkgfHwgbmFtZTtcbiAgICB9XG5cblxuICAgIHZhclxuXG4gICAgICAvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG4gICAgICAvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcbiAgICAgIC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuICAgICAgcmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuICAgICAgY3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG4gICAgICBjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG4gICAgICAgIGxldHRlclNwYWNpbmc6IFwiMFwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcIjQwMFwiXG4gICAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoX2VsZW0sIHZhbHVlLCBzdWJ0cmFjdCkge1xuXG4gICAgICAvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG4gICAgICAvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcbiAgICAgIHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKHZhbHVlKTtcbiAgICAgIHJldHVybiBtYXRjaGVzID9cblxuICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuICAgICAgICBNYXRoLm1heCgwLCBtYXRjaGVzWzJdIC0gKHN1YnRyYWN0IHx8IDApKSArIChtYXRjaGVzWzNdIHx8IFwicHhcIikgOlxuICAgICAgICB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsKSB7XG4gICAgICB2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG4gICAgICAgIGV4dHJhID0gMCxcbiAgICAgICAgZGVsdGEgPSAwLFxuICAgICAgICBtYXJnaW5EZWx0YSA9IDA7XG5cbiAgICAgIC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3NhcnlcbiAgICAgIGlmIChib3ggPT09IChpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIikpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgNDsgaSArPSAyKSB7XG5cbiAgICAgICAgLy8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG4gICAgICAgIC8vIENvdW50IG1hcmdpbiBkZWx0YSBzZXBhcmF0ZWx5IHRvIG9ubHkgYWRkIGl0IGFmdGVyIHNjcm9sbCBndXR0ZXIgYWRqdXN0bWVudC5cbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgdG8gbWFrZSBuZWdhdGl2ZSBtYXJnaW5zIHdvcmsgd2l0aCBgb3V0ZXJIZWlnaHQoIHRydWUgKWAgKGdoLTM5ODIpLlxuICAgICAgICBpZiAoYm94ID09PSBcIm1hcmdpblwiKSB7XG4gICAgICAgICAgbWFyZ2luRGVsdGEgKz0galF1ZXJ5LmNzcyhlbGVtLCBib3ggKyBjc3NFeHBhbmRbaV0sIHRydWUsIHN0eWxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG4gICAgICAgIGlmICghaXNCb3JkZXJCb3gpIHtcblxuICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgICAgICAgZGVsdGEgKz0galF1ZXJ5LmNzcyhlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFtpXSwgdHJ1ZSwgc3R5bGVzKTtcblxuICAgICAgICAgIC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcbiAgICAgICAgICBpZiAoYm94ICE9PSBcInBhZGRpbmdcIikge1xuICAgICAgICAgICAgZGVsdGEgKz0galF1ZXJ5LmNzcyhlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kW2ldICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMpO1xuXG4gICAgICAgICAgICAvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXh0cmEgKz0galF1ZXJ5LmNzcyhlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kW2ldICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3JcbiAgICAgICAgICAvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcbiAgICAgICAgICBpZiAoYm94ID09PSBcImNvbnRlbnRcIikge1xuICAgICAgICAgICAgZGVsdGEgLT0galF1ZXJ5LmNzcyhlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFtpXSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuICAgICAgICAgIGlmIChib3ggIT09IFwibWFyZ2luXCIpIHtcbiAgICAgICAgICAgIGRlbHRhIC09IGpRdWVyeS5jc3MoZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFtpXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcbiAgICAgIGlmICghaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCkge1xuXG4gICAgICAgIC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcbiAgICAgICAgLy8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuICAgICAgICBkZWx0YSArPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoXG4gICAgICAgICAgZWxlbVtcIm9mZnNldFwiICsgZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSldIC1cbiAgICAgICAgICBjb21wdXRlZFZhbCAtXG4gICAgICAgICAgZGVsdGEgLVxuICAgICAgICAgIGV4dHJhIC1cbiAgICAgICAgICAwLjVcblxuICAgICAgICAgIC8vIElmIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyB1bmtub3duLCB0aGVuIHdlIGNhbid0IGRldGVybWluZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyXG4gICAgICAgICAgLy8gVXNlIGFuIGV4cGxpY2l0IHplcm8gdG8gYXZvaWQgTmFOIChnaC0zOTY0KVxuICAgICAgICApKSB8fCAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVsdGEgKyBtYXJnaW5EZWx0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEpIHtcblxuICAgICAgLy8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuICAgICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtKSxcblxuICAgICAgICAvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC00MzIyKS5cbiAgICAgICAgLy8gRmFrZSBjb250ZW50LWJveCB1bnRpbCB3ZSBrbm93IGl0J3MgbmVlZGVkIHRvIGtub3cgdGhlIHRydWUgdmFsdWUuXG4gICAgICAgIGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG4gICAgICAgIGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG4gICAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzKSA9PT0gXCJib3JkZXItYm94XCIsXG4gICAgICAgIHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCxcblxuICAgICAgICB2YWwgPSBjdXJDU1MoZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMpLFxuICAgICAgICBvZmZzZXRQcm9wID0gXCJvZmZzZXRcIiArIGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpO1xuXG4gICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcbiAgICAgIC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgaWYgKHJudW1ub25weC50ZXN0KHZhbCkpIHtcbiAgICAgICAgaWYgKCFleHRyYSkge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gXCJhdXRvXCI7XG4gICAgICB9XG5cblxuICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcbiAgICAgIC8vIFVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlLlxuICAgICAgLy8gSW4gdGhvc2UgY2FzZXMsIHRoZSBjb21wdXRlZCB2YWx1ZSBjYW4gYmUgdHJ1c3RlZCB0byBiZSBib3JkZXItYm94LlxuICAgICAgaWYgKCghc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpICYmIGlzQm9yZGVyQm94IHx8XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgMTAgLSAxMSssIEVkZ2UgMTUgLSAxOCtcbiAgICAgICAgLy8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcbiAgICAgICAgLy8gc2V0IGluIENTUyB3aGlsZSBgb2Zmc2V0KmAgcHJvcGVydGllcyByZXBvcnQgY29ycmVjdCB2YWx1ZXMuXG4gICAgICAgIC8vIEludGVyZXN0aW5nbHksIGluIHNvbWUgY2FzZXMgSUUgOSBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoaXMgaXNzdWUuXG4gICAgICAgICFzdXBwb3J0LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgbm9kZU5hbWUoZWxlbSwgXCJ0clwiKSB8fFxuXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuICAgICAgICAvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG4gICAgICAgIHZhbCA9PT0gXCJhdXRvXCIgfHxcblxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcbiAgICAgICAgLy8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcbiAgICAgICAgIXBhcnNlRmxvYXQodmFsKSAmJiBqUXVlcnkuY3NzKGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzKSA9PT0gXCJpbmxpbmVcIikgJiZcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSAmIGNvbm5lY3RlZFxuICAgICAgICBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKSB7XG5cbiAgICAgICAgaXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMpID09PSBcImJvcmRlci1ib3hcIjtcblxuICAgICAgICAvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG4gICAgICAgIC8vIFdoZXJlIG5vdCBhdmFpbGFibGUgKGUuZy4sIFNWRyksIGFzc3VtZSB1bnJlbGlhYmxlIGJveC1zaXppbmcgYW5kIGludGVycHJldCB0aGVcbiAgICAgICAgLy8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuICAgICAgICB2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuICAgICAgICBpZiAodmFsdWVJc0JvcmRlckJveCkge1xuICAgICAgICAgIHZhbCA9IGVsZW1bb2Zmc2V0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cbiAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKSB8fCAwO1xuXG4gICAgICAvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXG4gICAgICByZXR1cm4gKHZhbCArXG4gICAgICAgIGJveE1vZGVsQWRqdXN0bWVudChcbiAgICAgICAgICBlbGVtLFxuICAgICAgICAgIGRpbWVuc2lvbixcbiAgICAgICAgICBleHRyYSB8fCAoaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIpLFxuICAgICAgICAgIHZhbHVlSXNCb3JkZXJCb3gsXG4gICAgICAgICAgc3R5bGVzLFxuXG4gICAgICAgICAgLy8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcbiAgICAgICAgICB2YWxcbiAgICAgICAgKVxuICAgICAgKSArIFwicHhcIjtcbiAgICB9XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcblxuICAgICAgLy8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG4gICAgICAvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcbiAgICAgIGNzc0hvb2tzOiB7XG4gICAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlbGVtLCBjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG5cbiAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcbiAgICAgICAgICAgICAgdmFyIHJldCA9IGN1ckNTUyhlbGVtLCBcIm9wYWNpdHlcIik7XG4gICAgICAgICAgICAgIHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG4gICAgICBjc3NOdW1iZXI6IHtcbiAgICAgICAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gICAgICAgIGFzcGVjdFJhdGlvOiB0cnVlLFxuICAgICAgICBib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuICAgICAgICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgICAgICAgZmxleEdyb3c6IHRydWUsXG4gICAgICAgIGZsZXhTaHJpbms6IHRydWUsXG4gICAgICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgICAgIGdyaWRBcmVhOiB0cnVlLFxuICAgICAgICBncmlkQ29sdW1uOiB0cnVlLFxuICAgICAgICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICAgICAgICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gICAgICAgIGdyaWRSb3c6IHRydWUsXG4gICAgICAgIGdyaWRSb3dFbmQ6IHRydWUsXG4gICAgICAgIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgICAgICAgbGluZUhlaWdodDogdHJ1ZSxcbiAgICAgICAgb3BhY2l0eTogdHJ1ZSxcbiAgICAgICAgb3JkZXI6IHRydWUsXG4gICAgICAgIG9ycGhhbnM6IHRydWUsXG4gICAgICAgIHNjYWxlOiB0cnVlLFxuICAgICAgICB3aWRvd3M6IHRydWUsXG4gICAgICAgIHpJbmRleDogdHJ1ZSxcbiAgICAgICAgem9vbTogdHJ1ZSxcblxuICAgICAgICAvLyBTVkctcmVsYXRlZFxuICAgICAgICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgICAgICAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICAgICAgICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLy8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuICAgICAgLy8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuICAgICAgY3NzUHJvcHM6IHt9LFxuXG4gICAgICAvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuICAgICAgc3R5bGU6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEpIHtcblxuICAgICAgICAvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcbiAgICAgICAgaWYgKCFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuICAgICAgICB2YXIgcmV0LCB0eXBlLCBob29rcyxcbiAgICAgICAgICBvcmlnTmFtZSA9IGNhbWVsQ2FzZShuYW1lKSxcbiAgICAgICAgICBpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KG5hbWUpLFxuICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG4gICAgICAgIC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuICAgICAgICAvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG4gICAgICAgIGlmICghaXNDdXN0b21Qcm9wKSB7XG4gICAgICAgICAgbmFtZSA9IGZpbmFsUHJvcE5hbWUob3JpZ05hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cbiAgICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbbmFtZV0gfHwgalF1ZXJ5LmNzc0hvb2tzW29yaWdOYW1lXTtcblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgICAgICAgLy8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKHRyYWMtNzM0NSlcbiAgICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAocmV0ID0gcmNzc051bS5leGVjKHZhbHVlKSkgJiYgcmV0WzFdKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFkanVzdENTUyhlbGVtLCBuYW1lLCByZXQpO1xuXG4gICAgICAgICAgICAvLyBGaXhlcyBidWcgdHJhYy05MjM3XG4gICAgICAgICAgICB0eXBlID0gXCJudW1iZXJcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKHRyYWMtNzExNilcbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcbiAgICAgICAgICAvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG4gICAgICAgICAgLy8gXCJweFwiIHRvIGEgZmV3IGhhcmRjb2RlZCB2YWx1ZXMuXG4gICAgICAgICAgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWlzQ3VzdG9tUHJvcCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gcmV0ICYmIHJldFszXSB8fCAoalF1ZXJ5LmNzc051bWJlcltvcmlnTmFtZV0gPyBcIlwiIDogXCJweFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG4gICAgICAgICAgaWYgKCFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoXCJiYWNrZ3JvdW5kXCIpID09PSAwKSB7XG4gICAgICAgICAgICBzdHlsZVtuYW1lXSA9IFwiaW5oZXJpdFwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAgICAgIGlmICghaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fFxuICAgICAgICAgICAgKHZhbHVlID0gaG9va3Muc2V0KGVsZW0sIHZhbHVlLCBleHRyYSkpICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgaWYgKGlzQ3VzdG9tUHJvcCkge1xuICAgICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHlsZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG4gICAgICAgICAgaWYgKGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcbiAgICAgICAgICAgIChyZXQgPSBob29rcy5nZXQoZWxlbSwgZmFsc2UsIGV4dHJhKSkgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICAgICAgcmV0dXJuIHN0eWxlW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjc3M6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzKSB7XG4gICAgICAgIHZhciB2YWwsIG51bSwgaG9va3MsXG4gICAgICAgICAgb3JpZ05hbWUgPSBjYW1lbENhc2UobmFtZSksXG4gICAgICAgICAgaXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdChuYW1lKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG4gICAgICAgIC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcbiAgICAgICAgLy8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuICAgICAgICBpZiAoIWlzQ3VzdG9tUHJvcCkge1xuICAgICAgICAgIG5hbWUgPSBmaW5hbFByb3BOYW1lKG9yaWdOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcbiAgICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbbmFtZV0gfHwgalF1ZXJ5LmNzc0hvb2tzW29yaWdOYW1lXTtcblxuICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuICAgICAgICBpZiAoaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcykge1xuICAgICAgICAgIHZhbCA9IGhvb2tzLmdldChlbGVtLCB0cnVlLCBleHRyYSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YWwgPSBjdXJDU1MoZWxlbSwgbmFtZSwgc3R5bGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuICAgICAgICBpZiAodmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtKSB7XG4gICAgICAgICAgdmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtW25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG4gICAgICAgIGlmIChleHRyYSA9PT0gXCJcIiB8fCBleHRyYSkge1xuICAgICAgICAgIG51bSA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgICByZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUobnVtKSA/IG51bSB8fCAwIDogdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5lYWNoKFtcImhlaWdodFwiLCBcIndpZHRoXCJdLCBmdW5jdGlvbiAoX2ksIGRpbWVuc2lvbikge1xuICAgICAgalF1ZXJ5LmNzc0hvb2tzW2RpbWVuc2lvbl0gPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0sIGNvbXB1dGVkLCBleHRyYSkge1xuICAgICAgICAgIGlmIChjb21wdXRlZCkge1xuXG4gICAgICAgICAgICAvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cbiAgICAgICAgICAgIC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG4gICAgICAgICAgICByZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoalF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIikpICYmXG5cbiAgICAgICAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDgrXG4gICAgICAgICAgICAgIC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG4gICAgICAgICAgICAgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG4gICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAgICAgICAvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG4gICAgICAgICAgICAgIC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgKCFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKSA/XG4gICAgICAgICAgICAgIHN3YXAoZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEpO1xuICAgICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICAgIGdldFdpZHRoT3JIZWlnaHQoZWxlbSwgZGltZW5zaW9uLCBleHRyYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGVsZW0sIHZhbHVlLCBleHRyYSkge1xuICAgICAgICAgIHZhciBtYXRjaGVzLFxuICAgICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKGVsZW0pLFxuXG4gICAgICAgICAgICAvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG4gICAgICAgICAgICAvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxuICAgICAgICAgICAgc2Nyb2xsYm94U2l6ZUJ1Z2d5ID0gIXN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpICYmXG4gICAgICAgICAgICAgIHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG4gICAgICAgICAgICAvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxuICAgICAgICAgICAgYm94U2l6aW5nTmVlZGVkID0gc2Nyb2xsYm94U2l6ZUJ1Z2d5IHx8IGV4dHJhLFxuICAgICAgICAgICAgaXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcbiAgICAgICAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzKSA9PT0gXCJib3JkZXItYm94XCIsXG4gICAgICAgICAgICBzdWJ0cmFjdCA9IGV4dHJhID9cbiAgICAgICAgICAgICAgYm94TW9kZWxBZGp1c3RtZW50KFxuICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uLFxuICAgICAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgICAgICAgIGlzQm9yZGVyQm94LFxuICAgICAgICAgICAgICAgIHN0eWxlc1xuICAgICAgICAgICAgICApIDpcbiAgICAgICAgICAgICAgMDtcblxuICAgICAgICAgIC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuICAgICAgICAgIC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG4gICAgICAgICAgaWYgKGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSkge1xuICAgICAgICAgICAgc3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuICAgICAgICAgICAgICBlbGVtW1wib2Zmc2V0XCIgKyBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKV0gLVxuICAgICAgICAgICAgICBwYXJzZUZsb2F0KHN0eWxlc1tkaW1lbnNpb25dKSAtXG4gICAgICAgICAgICAgIGJveE1vZGVsQWRqdXN0bWVudChlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMpIC1cbiAgICAgICAgICAgICAgMC41XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG4gICAgICAgICAgaWYgKHN1YnRyYWN0ICYmIChtYXRjaGVzID0gcmNzc051bS5leGVjKHZhbHVlKSkgJiZcbiAgICAgICAgICAgIChtYXRjaGVzWzNdIHx8IFwicHhcIikgIT09IFwicHhcIikge1xuXG4gICAgICAgICAgICBlbGVtLnN0eWxlW2RpbWVuc2lvbl0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5LmNzcyhlbGVtLCBkaW1lbnNpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZXRQb3NpdGl2ZU51bWJlcihlbGVtLCB2YWx1ZSwgc3VidHJhY3QpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG4gICAgICBmdW5jdGlvbiAoZWxlbSwgY29tcHV0ZWQpIHtcbiAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgICAgcmV0dXJuIChwYXJzZUZsb2F0KGN1ckNTUyhlbGVtLCBcIm1hcmdpbkxlZnRcIikpIHx8XG4gICAgICAgICAgICBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuICAgICAgICAgICAgc3dhcChlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICBtYXJnaW46IFwiXCIsXG4gICAgICBwYWRkaW5nOiBcIlwiLFxuICAgICAgYm9yZGVyOiBcIldpZHRoXCJcbiAgICB9LCBmdW5jdGlvbiAocHJlZml4LCBzdWZmaXgpIHtcbiAgICAgIGpRdWVyeS5jc3NIb29rc1twcmVmaXggKyBzdWZmaXhdID0ge1xuICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGV4cGFuZGVkID0ge30sXG5cbiAgICAgICAgICAgIC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuICAgICAgICAgICAgcGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdChcIiBcIikgOiBbdmFsdWVdO1xuXG4gICAgICAgICAgZm9yICg7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIGV4cGFuZGVkW3ByZWZpeCArIGNzc0V4cGFuZFtpXSArIHN1ZmZpeF0gPVxuICAgICAgICAgICAgICBwYXJ0c1tpXSB8fCBwYXJ0c1tpIC0gMl0gfHwgcGFydHNbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAocHJlZml4ICE9PSBcIm1hcmdpblwiKSB7XG4gICAgICAgIGpRdWVyeS5jc3NIb29rc1twcmVmaXggKyBzdWZmaXhdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICBjc3M6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIHZhciBzdHlsZXMsIGxlbixcbiAgICAgICAgICAgIG1hcCA9IHt9LFxuICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKGVsZW0pO1xuICAgICAgICAgICAgbGVuID0gbmFtZS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgbWFwW25hbWVbaV1dID0galF1ZXJ5LmNzcyhlbGVtLCBuYW1lW2ldLCBmYWxzZSwgc3R5bGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgbmFtZSwgdmFsdWUpIDpcbiAgICAgICAgICAgIGpRdWVyeS5jc3MoZWxlbSwgbmFtZSk7XG4gICAgICAgIH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSk7XG4gICAgICB9XG4gICAgfSk7XG5cblxuICAgIGZ1bmN0aW9uIFR3ZWVuKGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nKSB7XG4gICAgICByZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nKTtcbiAgICB9XG4gICAgalF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cbiAgICBUd2Vlbi5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogVHdlZW4sXG4gICAgICBpbml0OiBmdW5jdGlvbiAoZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQpIHtcbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgICAgdGhpcy5wcm9wID0gcHJvcDtcbiAgICAgICAgdGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMudW5pdCA9IHVuaXQgfHwgKGpRdWVyeS5jc3NOdW1iZXJbcHJvcF0gPyBcIlwiIDogXCJweFwiKTtcbiAgICAgIH0sXG4gICAgICBjdXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzW3RoaXMucHJvcF07XG5cbiAgICAgICAgcmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG4gICAgICAgICAgaG9va3MuZ2V0KHRoaXMpIDpcbiAgICAgICAgICBUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHJ1bjogZnVuY3Rpb24gKHBlcmNlbnQpIHtcbiAgICAgICAgdmFyIGVhc2VkLFxuICAgICAgICAgIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzW3RoaXMucHJvcF07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbikge1xuICAgICAgICAgIHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nW3RoaXMuZWFzaW5nXShcbiAgICAgICAgICAgIHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3cgPSAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0ZXApIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhvb2tzICYmIGhvb2tzLnNldCkge1xuICAgICAgICAgIGhvb2tzLnNldCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUd2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cbiAgICBUd2Vlbi5wcm9wSG9va3MgPSB7XG4gICAgICBfZGVmYXVsdDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICh0d2Vlbikge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgICAvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuICAgICAgICAgIC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG4gICAgICAgICAgaWYgKHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcbiAgICAgICAgICAgIHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlW3R3ZWVuLnByb3BdID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAgICAgIC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG4gICAgICAgICAgLy8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG4gICAgICAgICAgLy8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cbiAgICAgICAgICByZXN1bHQgPSBqUXVlcnkuY3NzKHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIpO1xuXG4gICAgICAgICAgLy8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG4gICAgICAgICAgcmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHR3ZWVuKSB7XG5cbiAgICAgICAgICAvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cbiAgICAgICAgICAvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG4gICAgICAgICAgLy8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cbiAgICAgICAgICBpZiAoalF1ZXJ5LmZ4LnN0ZXBbdHdlZW4ucHJvcF0pIHtcbiAgICAgICAgICAgIGpRdWVyeS5meC5zdGVwW3R3ZWVuLnByb3BdKHR3ZWVuKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuICAgICAgICAgICAgalF1ZXJ5LmNzc0hvb2tzW3R3ZWVuLnByb3BdIHx8XG4gICAgICAgICAgICB0d2Vlbi5lbGVtLnN0eWxlW2ZpbmFsUHJvcE5hbWUodHdlZW4ucHJvcCldICE9IG51bGwpKSB7XG4gICAgICAgICAgICBqUXVlcnkuc3R5bGUodHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF0gPSB0d2Vlbi5ub3c7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG4gICAgVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuICAgICAgc2V0OiBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgaWYgKHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdHdlZW4uZWxlbVt0d2Vlbi5wcm9wXSA9IHR3ZWVuLm5vdztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBqUXVlcnkuZWFzaW5nID0ge1xuICAgICAgbGluZWFyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH0sXG4gICAgICBzd2luZzogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIDAuNSAtIE1hdGguY29zKHAgKiBNYXRoLlBJKSAvIDI7XG4gICAgICB9LFxuICAgICAgX2RlZmF1bHQ6IFwic3dpbmdcIlxuICAgIH07XG5cbiAgICBqUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuICAgIC8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG4gICAgalF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxuICAgIHZhclxuICAgICAgZnhOb3csIGluUHJvZ3Jlc3MsXG4gICAgICByZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcbiAgICAgIHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG4gICAgZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG4gICAgICBpZiAoaW5Qcm9ncmVzcykge1xuICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzY2hlZHVsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBqUXVlcnkuZngudGljaygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbiAgICBmdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnhOb3cgPSB1bmRlZmluZWQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoZnhOb3cgPSBEYXRlLm5vdygpKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuICAgIGZ1bmN0aW9uIGdlbkZ4KHR5cGUsIGluY2x1ZGVXaWR0aCkge1xuICAgICAgdmFyIHdoaWNoLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgYXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG4gICAgICAvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG4gICAgICAvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuICAgICAgaW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG4gICAgICBmb3IgKDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCkge1xuICAgICAgICB3aGljaCA9IGNzc0V4cGFuZFtpXTtcbiAgICAgICAgYXR0cnNbXCJtYXJnaW5cIiArIHdoaWNoXSA9IGF0dHJzW1wicGFkZGluZ1wiICsgd2hpY2hdID0gdHlwZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVXaWR0aCkge1xuICAgICAgICBhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVHdlZW4odmFsdWUsIHByb3AsIGFuaW1hdGlvbikge1xuICAgICAgdmFyIHR3ZWVuLFxuICAgICAgICBjb2xsZWN0aW9uID0gKEFuaW1hdGlvbi50d2VlbmVyc1twcm9wXSB8fCBbXSkuY29uY2F0KEFuaW1hdGlvbi50d2VlbmVyc1tcIipcIl0pLFxuICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGlmICgodHdlZW4gPSBjb2xsZWN0aW9uW2luZGV4XS5jYWxsKGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUpKSkge1xuXG4gICAgICAgICAgLy8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICByZXR1cm4gdHdlZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKGVsZW0sIHByb3BzLCBvcHRzKSB7XG4gICAgICB2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG4gICAgICAgIGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG4gICAgICAgIGFuaW0gPSB0aGlzLFxuICAgICAgICBvcmlnID0ge30sXG4gICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZSxcbiAgICAgICAgaGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoZWxlbSksXG4gICAgICAgIGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KGVsZW0sIFwiZnhzaG93XCIpO1xuXG4gICAgICAvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3NcbiAgICAgIGlmICghb3B0cy5xdWV1ZSkge1xuICAgICAgICBob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyhlbGVtLCBcImZ4XCIpO1xuICAgICAgICBpZiAoaG9va3MudW5xdWV1ZWQgPT0gbnVsbCkge1xuICAgICAgICAgIGhvb2tzLnVucXVldWVkID0gMDtcbiAgICAgICAgICBvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcbiAgICAgICAgICBob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFob29rcy51bnF1ZXVlZCkge1xuICAgICAgICAgICAgICBvbGRmaXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBob29rcy51bnF1ZXVlZCsrO1xuXG4gICAgICAgIGFuaW0uYWx3YXlzKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgIC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG4gICAgICAgICAgYW5pbS5hbHdheXMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaG9va3MudW5xdWV1ZWQtLTtcbiAgICAgICAgICAgIGlmICghalF1ZXJ5LnF1ZXVlKGVsZW0sIFwiZnhcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuICAgICAgZm9yIChwcm9wIGluIHByb3BzKSB7XG4gICAgICAgIHZhbHVlID0gcHJvcHNbcHJvcF07XG4gICAgICAgIGlmIChyZnh0eXBlcy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgIGRlbGV0ZSBwcm9wc1twcm9wXTtcbiAgICAgICAgICB0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSAoaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIikpIHtcblxuICAgICAgICAgICAgLy8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBoaWRkZW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAgIC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvcmlnW3Byb3BdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbcHJvcF0gfHwgalF1ZXJ5LnN0eWxlKGVsZW0sIHByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG4gICAgICBwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QocHJvcHMpO1xuICAgICAgaWYgKCFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3Qob3JpZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcbiAgICAgIGlmIChpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuICAgICAgICAvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcbiAgICAgICAgLy8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG4gICAgICAgIC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG4gICAgICAgIG9wdHMub3ZlcmZsb3cgPSBbc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZXTtcblxuICAgICAgICAvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcbiAgICAgICAgcmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuICAgICAgICBpZiAocmVzdG9yZURpc3BsYXkgPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KGVsZW0sIFwiZGlzcGxheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIik7XG4gICAgICAgIGlmIChkaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgICAgIGlmIChyZXN0b3JlRGlzcGxheSkge1xuICAgICAgICAgICAgZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcbiAgICAgICAgICAgIHNob3dIaWRlKFtlbGVtXSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcbiAgICAgICAgICAgIGRpc3BsYXkgPSBqUXVlcnkuY3NzKGVsZW0sIFwiZGlzcGxheVwiKTtcbiAgICAgICAgICAgIHNob3dIaWRlKFtlbGVtXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG4gICAgICAgIGlmIChkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChqUXVlcnkuY3NzKGVsZW0sIFwiZmxvYXRcIikgPT09IFwibm9uZVwiKSB7XG5cbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG4gICAgICAgICAgICBpZiAoIXByb3BUd2Vlbikge1xuICAgICAgICAgICAgICBhbmltLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChyZXN0b3JlRGlzcGxheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgcmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMub3ZlcmZsb3cpIHtcbiAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgICBhbmltLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WzBdO1xuICAgICAgICAgIHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbMV07XG4gICAgICAgICAgc3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1syXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuICAgICAgcHJvcFR3ZWVuID0gZmFsc2U7XG4gICAgICBmb3IgKHByb3AgaW4gb3JpZykge1xuXG4gICAgICAgIC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG4gICAgICAgIGlmICghcHJvcFR3ZWVuKSB7XG4gICAgICAgICAgaWYgKGRhdGFTaG93KSB7XG4gICAgICAgICAgICBpZiAoXCJoaWRkZW5cIiBpbiBkYXRhU2hvdykge1xuICAgICAgICAgICAgICBoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG4gICAgICAgICAgaWYgKHRvZ2dsZSkge1xuICAgICAgICAgICAgZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuICAgICAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgICAgIHNob3dIaWRlKFtlbGVtXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cbiAgICAgICAgICBhbmltLmRvbmUoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG4gICAgICAgICAgICAvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaGlkZGVuKSB7XG4gICAgICAgICAgICAgIHNob3dIaWRlKFtlbGVtXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZWxlbSwgXCJmeHNob3dcIik7XG4gICAgICAgICAgICBmb3IgKHByb3AgaW4gb3JpZykge1xuICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCwgb3JpZ1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQZXItcHJvcGVydHkgc2V0dXBcbiAgICAgICAgcHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oaGlkZGVuID8gZGF0YVNob3dbcHJvcF0gOiAwLCBwcm9wLCBhbmltKTtcbiAgICAgICAgaWYgKCEocHJvcCBpbiBkYXRhU2hvdykpIHtcbiAgICAgICAgICBkYXRhU2hvd1twcm9wXSA9IHByb3BUd2Vlbi5zdGFydDtcbiAgICAgICAgICBpZiAoaGlkZGVuKSB7XG4gICAgICAgICAgICBwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuICAgICAgICAgICAgcHJvcFR3ZWVuLnN0YXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9wRmlsdGVyKHByb3BzLCBzcGVjaWFsRWFzaW5nKSB7XG4gICAgICB2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG4gICAgICAvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3NcbiAgICAgIGZvciAoaW5kZXggaW4gcHJvcHMpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsQ2FzZShpbmRleCk7XG4gICAgICAgIGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbbmFtZV07XG4gICAgICAgIHZhbHVlID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBlYXNpbmcgPSB2YWx1ZVsxXTtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BzW2luZGV4XSA9IHZhbHVlWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSBuYW1lKSB7XG4gICAgICAgICAgcHJvcHNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICBkZWxldGUgcHJvcHNbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbbmFtZV07XG4gICAgICAgIGlmIChob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzKSB7XG4gICAgICAgICAgdmFsdWUgPSBob29rcy5leHBhbmQodmFsdWUpO1xuICAgICAgICAgIGRlbGV0ZSBwcm9wc1tuYW1lXTtcblxuICAgICAgICAgIC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cbiAgICAgICAgICAvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG4gICAgICAgICAgZm9yIChpbmRleCBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCEoaW5kZXggaW4gcHJvcHMpKSB7XG4gICAgICAgICAgICAgIHByb3BzW2luZGV4XSA9IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZ1tpbmRleF0gPSBlYXNpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwZWNpYWxFYXNpbmdbbmFtZV0gPSBlYXNpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBBbmltYXRpb24oZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgc3RvcHBlZCxcbiAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICBsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG4gICAgICAgIGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgIC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuICAgICAgICAgIGRlbGV0ZSB0aWNrLmVsZW07XG4gICAgICAgIH0pLFxuICAgICAgICB0aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChzdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG4gICAgICAgICAgICByZW1haW5pbmcgPSBNYXRoLm1heCgwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUpLFxuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG4gICAgICAgICAgICAvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICh0cmFjLTEyNDk3KVxuICAgICAgICAgICAgdGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuICAgICAgICAgICAgcGVyY2VudCA9IDEgLSB0ZW1wLFxuICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbi50d2VlbnNbaW5kZXhdLnJ1bihwZXJjZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoKGVsZW0sIFthbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZ10pO1xuXG4gICAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuICAgICAgICAgIGlmIChwZXJjZW50IDwgMSAmJiBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgMSwgMF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoZWxlbSwgW2FuaW1hdGlvbl0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgYW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XG4gICAgICAgICAgZWxlbTogZWxlbSxcbiAgICAgICAgICBwcm9wczogalF1ZXJ5LmV4dGVuZCh7fSwgcHJvcGVydGllcyksXG4gICAgICAgICAgb3B0czogalF1ZXJ5LmV4dGVuZCh0cnVlLCB7XG4gICAgICAgICAgICBzcGVjaWFsRWFzaW5nOiB7fSxcbiAgICAgICAgICAgIGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuICAgICAgICAgIH0sIG9wdGlvbnMpLFxuICAgICAgICAgIG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgICBvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgc3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgIHR3ZWVuczogW10sXG4gICAgICAgICAgY3JlYXRlVHdlZW46IGZ1bmN0aW9uIChwcm9wLCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbihlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuICAgICAgICAgICAgICBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nW3Byb3BdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyk7XG4gICAgICAgICAgICBhbmltYXRpb24udHdlZW5zLnB1c2godHdlZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHR3ZWVuO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RvcDogZnVuY3Rpb24gKGdvdG9FbmQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDAsXG5cbiAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG4gICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuICAgICAgICAgICAgICBsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICBhbmltYXRpb24udHdlZW5zW2luZGV4XS5ydW4oMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG4gICAgICAgICAgICBpZiAoZ290b0VuZCkge1xuICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoKGVsZW0sIFthbmltYXRpb24sIDEsIDBdKTtcbiAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgZ290b0VuZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0V2l0aChlbGVtLCBbYW5pbWF0aW9uLCBnb3RvRW5kXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuICAgICAgcHJvcEZpbHRlcihwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyk7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1tpbmRleF0uY2FsbChhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXN1bHQuc3RvcCkpIHtcbiAgICAgICAgICAgIGpRdWVyeS5fcXVldWVIb29rcyhhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUpLnN0b3AgPVxuICAgICAgICAgICAgICByZXN1bHQuc3RvcC5iaW5kKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgalF1ZXJ5Lm1hcChwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbik7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGFuaW1hdGlvbi5vcHRzLnN0YXJ0KSkge1xuICAgICAgICBhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKGVsZW0sIGFuaW1hdGlvbik7XG4gICAgICB9XG5cbiAgICAgIC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG4gICAgICBhbmltYXRpb25cbiAgICAgICAgLnByb2dyZXNzKGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzKVxuICAgICAgICAuZG9uZShhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSlcbiAgICAgICAgLmZhaWwoYW5pbWF0aW9uLm9wdHMuZmFpbClcbiAgICAgICAgLmFsd2F5cyhhbmltYXRpb24ub3B0cy5hbHdheXMpO1xuXG4gICAgICBqUXVlcnkuZngudGltZXIoXG4gICAgICAgIGpRdWVyeS5leHRlbmQodGljaywge1xuICAgICAgICAgIGVsZW06IGVsZW0sXG4gICAgICAgICAgYW5pbTogYW5pbWF0aW9uLFxuICAgICAgICAgIHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGFuaW1hdGlvbjtcbiAgICB9XG5cbiAgICBqUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZChBbmltYXRpb24sIHtcblxuICAgICAgdHdlZW5lcnM6IHtcbiAgICAgICAgXCIqXCI6IFtmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKHByb3AsIHZhbHVlKTtcbiAgICAgICAgICBhZGp1c3RDU1ModHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKHZhbHVlKSwgdHdlZW4pO1xuICAgICAgICAgIHJldHVybiB0d2VlbjtcbiAgICAgICAgfV1cbiAgICAgIH0sXG5cbiAgICAgIHR3ZWVuZXI6IGZ1bmN0aW9uIChwcm9wcywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcHMpKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBwcm9wcztcbiAgICAgICAgICBwcm9wcyA9IFtcIipcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHMgPSBwcm9wcy5tYXRjaChybm90aHRtbHdoaXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgcHJvcCA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICBBbmltYXRpb24udHdlZW5lcnNbcHJvcF0gPSBBbmltYXRpb24udHdlZW5lcnNbcHJvcF0gfHwgW107XG4gICAgICAgICAgQW5pbWF0aW9uLnR3ZWVuZXJzW3Byb3BdLnVuc2hpZnQoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBwcmVmaWx0ZXJzOiBbZGVmYXVsdFByZWZpbHRlcl0sXG5cbiAgICAgIHByZWZpbHRlcjogZnVuY3Rpb24gKGNhbGxiYWNrLCBwcmVwZW5kKSB7XG4gICAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgICAgQW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdChjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uIChzcGVlZCwgZWFzaW5nLCBmbikge1xuICAgICAgdmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoe30sIHNwZWVkKSA6IHtcbiAgICAgICAgY29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcbiAgICAgICAgICBpc0Z1bmN0aW9uKHNwZWVkKSAmJiBzcGVlZCxcbiAgICAgICAgZHVyYXRpb246IHNwZWVkLFxuICAgICAgICBlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oZWFzaW5nKSAmJiBlYXNpbmdcbiAgICAgIH07XG5cbiAgICAgIC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuICAgICAgaWYgKGpRdWVyeS5meC5vZmYpIHtcbiAgICAgICAgb3B0LmR1cmF0aW9uID0gMDtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBpZiAob3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMpIHtcbiAgICAgICAgICAgIG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbb3B0LmR1cmF0aW9uXTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcbiAgICAgIGlmIChvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUpIHtcbiAgICAgICAgb3B0LnF1ZXVlID0gXCJmeFwiO1xuICAgICAgfVxuXG4gICAgICAvLyBRdWV1ZWluZ1xuICAgICAgb3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuICAgICAgb3B0LmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvcHQub2xkKSkge1xuICAgICAgICAgIG9wdC5vbGQuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHQucXVldWUpIHtcbiAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCBvcHQucXVldWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gb3B0O1xuICAgIH07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgIGZhZGVUbzogZnVuY3Rpb24gKHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjaykge1xuXG4gICAgICAgIC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaXNIaWRkZW5XaXRoaW5UcmVlKS5jc3MoXCJvcGFjaXR5XCIsIDApLnNob3coKVxuXG4gICAgICAgICAgLy8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG4gICAgICAgICAgLmVuZCgpLmFuaW1hdGUoeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICB9LFxuICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KHByb3ApLFxuICAgICAgICAgIG9wdGFsbCA9IGpRdWVyeS5zcGVlZChzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayksXG4gICAgICAgICAgZG9BbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG4gICAgICAgICAgICB2YXIgYW5pbSA9IEFuaW1hdGlvbih0aGlzLCBqUXVlcnkuZXh0ZW5kKHt9LCBwcm9wKSwgb3B0YWxsKTtcblxuICAgICAgICAgICAgLy8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoZW1wdHkgfHwgZGF0YVByaXYuZ2V0KHRoaXMsIFwiZmluaXNoXCIpKSB7XG4gICAgICAgICAgICAgIGFuaW0uc3RvcCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgIGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG4gICAgICAgIHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cbiAgICAgICAgICB0aGlzLmVhY2goZG9BbmltYXRpb24pIDpcbiAgICAgICAgICB0aGlzLnF1ZXVlKG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24pO1xuICAgICAgfSxcbiAgICAgIHN0b3A6IGZ1bmN0aW9uICh0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kKSB7XG4gICAgICAgIHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiAoaG9va3MpIHtcbiAgICAgICAgICB2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG4gICAgICAgICAgZGVsZXRlIGhvb2tzLnN0b3A7XG4gICAgICAgICAgc3RvcChnb3RvRW5kKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBnb3RvRW5kID0gY2xlYXJRdWV1ZTtcbiAgICAgICAgICBjbGVhclF1ZXVlID0gdHlwZTtcbiAgICAgICAgICB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGVhclF1ZXVlKSB7XG4gICAgICAgICAgdGhpcy5xdWV1ZSh0eXBlIHx8IFwiZnhcIiwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGRlcXVldWUgPSB0cnVlLFxuICAgICAgICAgICAgaW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuICAgICAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycyxcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhUHJpdi5nZXQodGhpcyk7XG5cbiAgICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChkYXRhW2luZGV4XSAmJiBkYXRhW2luZGV4XS5zdG9wKSB7XG4gICAgICAgICAgICAgIHN0b3BRdWV1ZShkYXRhW2luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaW5kZXggaW4gZGF0YSkge1xuICAgICAgICAgICAgICBpZiAoZGF0YVtpbmRleF0gJiYgZGF0YVtpbmRleF0uc3RvcCAmJiBycnVuLnRlc3QoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgc3RvcFF1ZXVlKGRhdGFbaW5kZXhdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOykge1xuICAgICAgICAgICAgaWYgKHRpbWVyc1tpbmRleF0uZWxlbSA9PT0gdGhpcyAmJlxuICAgICAgICAgICAgICAodHlwZSA9PSBudWxsIHx8IHRpbWVyc1tpbmRleF0ucXVldWUgPT09IHR5cGUpKSB7XG5cbiAgICAgICAgICAgICAgdGltZXJzW2luZGV4XS5hbmltLnN0b3AoZ290b0VuZCk7XG4gICAgICAgICAgICAgIGRlcXVldWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGltZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cbiAgICAgICAgICAvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG4gICAgICAgICAgLy8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuICAgICAgICAgIGlmIChkZXF1ZXVlIHx8ICFnb3RvRW5kKSB7XG4gICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZpbmlzaDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhUHJpdi5nZXQodGhpcyksXG4gICAgICAgICAgICBxdWV1ZSA9IGRhdGFbdHlwZSArIFwicXVldWVcIl0sXG4gICAgICAgICAgICBob29rcyA9IGRhdGFbdHlwZSArIFwicXVldWVIb29rc1wiXSxcbiAgICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG4gICAgICAgICAgICBsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgICAvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG4gICAgICAgICAgZGF0YS5maW5pc2ggPSB0cnVlO1xuXG4gICAgICAgICAgLy8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG4gICAgICAgICAgalF1ZXJ5LnF1ZXVlKHRoaXMsIHR5cGUsIFtdKTtcblxuICAgICAgICAgIGlmIChob29rcyAmJiBob29rcy5zdG9wKSB7XG4gICAgICAgICAgICBob29rcy5zdG9wLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cbiAgICAgICAgICBmb3IgKGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTspIHtcbiAgICAgICAgICAgIGlmICh0aW1lcnNbaW5kZXhdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzW2luZGV4XS5xdWV1ZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICB0aW1lcnNbaW5kZXhdLmFuaW0uc3RvcCh0cnVlKTtcbiAgICAgICAgICAgICAgdGltZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cbiAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChxdWV1ZVtpbmRleF0gJiYgcXVldWVbaW5kZXhdLmZpbmlzaCkge1xuICAgICAgICAgICAgICBxdWV1ZVtpbmRleF0uZmluaXNoLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcbiAgICAgICAgICBkZWxldGUgZGF0YS5maW5pc2g7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmVhY2goW1widG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIl0sIGZ1bmN0aW9uIChfaSwgbmFtZSkge1xuICAgICAgdmFyIGNzc0ZuID0galF1ZXJ5LmZuW25hbWVdO1xuICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuICAgICAgICAgIGNzc0ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOlxuICAgICAgICAgIHRoaXMuYW5pbWF0ZShnZW5GeChuYW1lLCB0cnVlKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICBzbGlkZURvd246IGdlbkZ4KFwic2hvd1wiKSxcbiAgICAgIHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcbiAgICAgIHNsaWRlVG9nZ2xlOiBnZW5GeChcInRvZ2dsZVwiKSxcbiAgICAgIGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuICAgICAgZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuICAgICAgZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbiAgICB9LCBmdW5jdGlvbiAobmFtZSwgcHJvcHMpIHtcbiAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uIChzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LnRpbWVycyA9IFtdO1xuICAgIGpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRpbWVyLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuICAgICAgZnhOb3cgPSBEYXRlLm5vdygpO1xuXG4gICAgICBmb3IgKDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aW1lciA9IHRpbWVyc1tpXTtcblxuICAgICAgICAvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG4gICAgICAgIGlmICghdGltZXIoKSAmJiB0aW1lcnNbaV0gPT09IHRpbWVyKSB7XG4gICAgICAgICAgdGltZXJzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGltZXJzLmxlbmd0aCkge1xuICAgICAgICBqUXVlcnkuZnguc3RvcCgpO1xuICAgICAgfVxuICAgICAgZnhOb3cgPSB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIGpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgalF1ZXJ5LnRpbWVycy5wdXNoKHRpbWVyKTtcbiAgICAgIGpRdWVyeS5meC5zdGFydCgpO1xuICAgIH07XG5cbiAgICBqUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbiAgICBqUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgc2NoZWR1bGUoKTtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpblByb2dyZXNzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZ4LnNwZWVkcyA9IHtcbiAgICAgIHNsb3c6IDYwMCxcbiAgICAgIGZhc3Q6IDIwMCxcblxuICAgICAgLy8gRGVmYXVsdCBzcGVlZFxuICAgICAgX2RlZmF1bHQ6IDQwMFxuICAgIH07XG5cblxuICAgIC8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbiAgICBqUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiAodGltZSwgdHlwZSkge1xuICAgICAgdGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbdGltZV0gfHwgdGltZSA6IHRpbWU7XG4gICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cbiAgICAgIHJldHVybiB0aGlzLnF1ZXVlKHR5cGUsIGZ1bmN0aW9uIChuZXh0LCBob29rcykge1xuICAgICAgICB2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KG5leHQsIHRpbWUpO1xuICAgICAgICBob29rcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuXG5cbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLFxuICAgICAgICBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLFxuICAgICAgICBvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSk7XG5cbiAgICAgIGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuICAgICAgLy8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG4gICAgICBzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgICAvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuICAgICAgc3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgICAvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBpbnB1dC52YWx1ZSA9IFwidFwiO1xuICAgICAgaW5wdXQudHlwZSA9IFwicmFkaW9cIjtcbiAgICAgIHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbiAgICB9KSgpO1xuXG5cbiAgICB2YXIgYm9vbEhvb2ssXG4gICAgICBhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgYXR0cjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSk7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmVBdHRyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0cih0aGlzLCBuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgIGF0dHI6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcmV0LCBob29rcyxcbiAgICAgICAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cbiAgICAgICAgLy8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuICAgICAgICBpZiAoblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuICAgICAgICBpZiAodHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGpRdWVyeS5wcm9wKGVsZW0sIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICAgICAgLy8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuICAgICAgICBpZiAoblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSkge1xuICAgICAgICAgIGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1tuYW1lLnRvTG93ZXJDYXNlKCldIHx8XG4gICAgICAgICAgICAoalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KG5hbWUpID8gYm9vbEhvb2sgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKGVsZW0sIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgICAocmV0ID0gaG9va3Muc2V0KGVsZW0sIHZhbHVlLCBuYW1lKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSArIFwiXCIpO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoZWxlbSwgbmFtZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IGpRdWVyeS5maW5kLmF0dHIoZWxlbSwgbmFtZSk7XG5cbiAgICAgICAgLy8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuICAgICAgfSxcblxuICAgICAgYXR0ckhvb2tzOiB7XG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuICAgICAgICAgICAgICBub2RlTmFtZShlbGVtLCBcImlucHV0XCIpKSB7XG4gICAgICAgICAgICAgIHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgZWxlbS52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICByZW1vdmVBdHRyOiBmdW5jdGlvbiAoZWxlbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG5hbWUsXG4gICAgICAgICAgaSA9IDAsXG5cbiAgICAgICAgICAvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG4gICAgICAgICAgYXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSk7XG5cbiAgICAgICAgaWYgKGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgd2hpbGUgKChuYW1lID0gYXR0ck5hbWVzW2krK10pKSB7XG4gICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbiAgICBib29sSG9vayA9IHtcbiAgICAgIHNldDogZnVuY3Rpb24gKGVsZW0sIHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgIC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2VcbiAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0cihlbGVtLCBuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShuYW1lLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgalF1ZXJ5LmVhY2goalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcdysvZyksIGZ1bmN0aW9uIChfaSwgbmFtZSkge1xuICAgICAgdmFyIGdldHRlciA9IGF0dHJIYW5kbGVbbmFtZV0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuICAgICAgYXR0ckhhbmRsZVtuYW1lXSA9IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBpc1hNTCkge1xuICAgICAgICB2YXIgcmV0LCBoYW5kbGUsXG4gICAgICAgICAgbG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoIWlzWE1MKSB7XG5cbiAgICAgICAgICAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG4gICAgICAgICAgaGFuZGxlID0gYXR0ckhhbmRsZVtsb3dlcmNhc2VOYW1lXTtcbiAgICAgICAgICBhdHRySGFuZGxlW2xvd2VyY2FzZU5hbWVdID0gcmV0O1xuICAgICAgICAgIHJldCA9IGdldHRlcihlbGVtLCBuYW1lLCBpc1hNTCkgIT0gbnVsbCA/XG4gICAgICAgICAgICBsb3dlcmNhc2VOYW1lIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgYXR0ckhhbmRsZVtsb3dlcmNhc2VOYW1lXSA9IGhhbmRsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICB9KTtcblxuXG5cblxuICAgIHZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcbiAgICAgIHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgIHByb3A6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlUHJvcDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXNbalF1ZXJ5LnByb3BGaXhbbmFtZV0gfHwgbmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICBwcm9wOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHJldCwgaG9va3MsXG4gICAgICAgICAgblR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG4gICAgICAgIC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcbiAgICAgICAgaWYgKG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoZWxlbSkpIHtcblxuICAgICAgICAgIC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3NcbiAgICAgICAgICBuYW1lID0galF1ZXJ5LnByb3BGaXhbbmFtZV0gfHwgbmFtZTtcbiAgICAgICAgICBob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgICAocmV0ID0gaG9va3Muc2V0KGVsZW0sIHZhbHVlLCBuYW1lKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKGVsZW1bbmFtZV0gPSB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIG5hbWUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbVtuYW1lXTtcbiAgICAgIH0sXG5cbiAgICAgIHByb3BIb29rczoge1xuICAgICAgICB0YWJJbmRleDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0pIHtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgICAgICAgICAgLy8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG4gICAgICAgICAgICAvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcbiAgICAgICAgICAgIC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCAodHJhYy0xMjA3MilcbiAgICAgICAgICAgIHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoZWxlbSwgXCJ0YWJpbmRleFwiKTtcblxuICAgICAgICAgICAgaWYgKHRhYmluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0YWJpbmRleCwgMTApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHJmb2N1c2FibGUudGVzdChlbGVtLm5vZGVOYW1lKSB8fFxuICAgICAgICAgICAgICByY2xpY2thYmxlLnRlc3QoZWxlbS5ub2RlTmFtZSkgJiZcbiAgICAgICAgICAgICAgZWxlbS5ocmVmXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHByb3BGaXg6IHtcbiAgICAgICAgXCJmb3JcIjogXCJodG1sRm9yXCIsXG4gICAgICAgIFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4gICAgLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuICAgIC8vIG9uIHRoZSBvcHRpb25cbiAgICAvLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuICAgIC8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbiAgICAvLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbiAgICAvLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbiAgICBpZiAoIXN1cHBvcnQub3B0U2VsZWN0ZWQpIHtcbiAgICAgIGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0pIHtcblxuICAgICAgICAgIC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGVsZW0pIHtcblxuICAgICAgICAgIC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZWFjaChbXG4gICAgICBcInRhYkluZGV4XCIsXG4gICAgICBcInJlYWRPbmx5XCIsXG4gICAgICBcIm1heExlbmd0aFwiLFxuICAgICAgXCJjZWxsU3BhY2luZ1wiLFxuICAgICAgXCJjZWxsUGFkZGluZ1wiLFxuICAgICAgXCJyb3dTcGFuXCIsXG4gICAgICBcImNvbFNwYW5cIixcbiAgICAgIFwidXNlTWFwXCIsXG4gICAgICBcImZyYW1lQm9yZGVyXCIsXG4gICAgICBcImNvbnRlbnRFZGl0YWJsZVwiXG4gICAgXSwgZnVuY3Rpb24gKCkge1xuICAgICAgalF1ZXJ5LnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXSA9IHRoaXM7XG4gICAgfSk7XG5cblxuXG5cbiAgICAvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG4gICAgLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG4gICAgZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSh2YWx1ZSkge1xuICAgICAgdmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFtdO1xuICAgICAgcmV0dXJuIHRva2Vucy5qb2luKFwiIFwiKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldENsYXNzKGVsZW0pIHtcbiAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkodmFsdWUpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMsIGN1ciwgY3VyVmFsdWUsIGNsYXNzTmFtZSwgaSwgZmluYWxWYWx1ZTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChqKSB7XG4gICAgICAgICAgICBqUXVlcnkodGhpcykuYWRkQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBqLCBnZXRDbGFzcyh0aGlzKSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KHZhbHVlKTtcblxuICAgICAgICBpZiAoY2xhc3NOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGN1clZhbHVlID0gZ2V0Q2xhc3ModGhpcyk7XG4gICAgICAgICAgICBjdXIgPSB0aGlzLm5vZGVUeXBlID09PSAxICYmIChcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoY3VyVmFsdWUpICsgXCIgXCIpO1xuXG4gICAgICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLmluZGV4T2YoXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIikgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBjdXIgKz0gY2xhc3NOYW1lICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cbiAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoY3VyKTtcbiAgICAgICAgICAgICAgaWYgKGN1clZhbHVlICE9PSBmaW5hbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBmaW5hbFZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWVzLCBjdXIsIGN1clZhbHVlLCBjbGFzc05hbWUsIGksIGZpbmFsVmFsdWU7XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaikge1xuICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnJlbW92ZUNsYXNzKHZhbHVlLmNhbGwodGhpcywgaiwgZ2V0Q2xhc3ModGhpcykpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoXCJjbGFzc1wiLCBcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGNsYXNzTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjdXJWYWx1ZSA9IGdldENsYXNzKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuICAgICAgICAgICAgY3VyID0gdGhpcy5ub2RlVHlwZSA9PT0gMSAmJiAoXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKGN1clZhbHVlKSArIFwiIFwiKTtcblxuICAgICAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbaV07XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ci5pbmRleE9mKFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIsIFwiIFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZShjdXIpO1xuICAgICAgICAgICAgICBpZiAoY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGZpbmFsVmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiAodmFsdWUsIHN0YXRlVmFsKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWVzLCBjbGFzc05hbWUsIGksIHNlbGYsXG4gICAgICAgICAgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcbiAgICAgICAgICBpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGpRdWVyeSh0aGlzKS50b2dnbGVDbGFzcyhcbiAgICAgICAgICAgICAgdmFsdWUuY2FsbCh0aGlzLCBpLCBnZXRDbGFzcyh0aGlzKSwgc3RhdGVWYWwpLFxuICAgICAgICAgICAgICBzdGF0ZVZhbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3ModmFsdWUpIDogdGhpcy5yZW1vdmVDbGFzcyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkVmFsdWUpIHtcblxuICAgICAgICAgICAgLy8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcbiAgICAgICAgICAgIHNlbGYgPSBqUXVlcnkodGhpcyk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbaV07XG5cbiAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG4gICAgICAgICAgICAgIGlmIChzZWxmLmhhc0NsYXNzKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hZGRDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcyh0aGlzKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcblxuICAgICAgICAgICAgICAvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG4gICAgICAgICAgICAgIGRhdGFQcml2LnNldCh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcbiAgICAgICAgICAgIC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuICAgICAgICAgICAgLy8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICAgIFwiXCIgOlxuICAgICAgICAgICAgICAgICAgZGF0YVByaXYuZ2V0KHRoaXMsIFwiX19jbGFzc05hbWVfX1wiKSB8fCBcIlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIGhhc0NsYXNzOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSwgZWxlbSxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgICBjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG4gICAgICAgIHdoaWxlICgoZWxlbSA9IHRoaXNbaSsrXSkpIHtcbiAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgKFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZShnZXRDbGFzcyhlbGVtKSkgKyBcIiBcIikuaW5kZXhPZihjbGFzc05hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIHZhciBycmV0dXJuID0gL1xcci9nO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICB2YWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuICAgICAgICAgIGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS52YWxIb29rc1tlbGVtLnR5cGVdIHx8XG4gICAgICAgICAgICAgIGpRdWVyeS52YWxIb29rc1tlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgICAgICBpZiAoaG9va3MgJiZcbiAgICAgICAgICAgICAgXCJnZXRcIiBpbiBob29rcyAmJlxuICAgICAgICAgICAgICAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIFwidmFsdWVcIikpICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXQgPSBlbGVtLnZhbHVlO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICByZXR1cm4gcmV0LnJlcGxhY2UocnJldHVybiwgXCJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuICAgICAgICAgICAgcmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgdmFyIHZhbDtcblxuICAgICAgICAgIGlmICh0aGlzLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlSXNGdW5jdGlvbikge1xuICAgICAgICAgICAgdmFsID0gdmFsdWUuY2FsbCh0aGlzLCBpLCBqUXVlcnkodGhpcykudmFsKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG4gICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWwgPSBcIlwiO1xuXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB2YWwgKz0gXCJcIjtcblxuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICB2YWwgPSBqUXVlcnkubWFwKHZhbCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzW3RoaXMudHlwZV0gfHwgalF1ZXJ5LnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgICAvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuICAgICAgICAgIGlmICghaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCBob29rcy5zZXQodGhpcywgdmFsLCBcInZhbHVlXCIpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgdmFsSG9va3M6IHtcbiAgICAgICAgb3B0aW9uOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxlbSkge1xuXG4gICAgICAgICAgICB2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0cihlbGVtLCBcInZhbHVlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsID9cbiAgICAgICAgICAgICAgdmFsIDpcblxuICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuICAgICAgICAgICAgICAvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAodHJhYy0xNDY4NiwgdHJhYy0xNDg1OClcbiAgICAgICAgICAgICAgLy8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgc3RyaXBBbmRDb2xsYXBzZShqUXVlcnkudGV4dChlbGVtKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUsIG9wdGlvbiwgaSxcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcbiAgICAgICAgICAgICAgaW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICAgIG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcbiAgICAgICAgICAgICAgbWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgaSA9IG1heDtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaSA9IG9uZSA/IGluZGV4IDogMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuICAgICAgICAgICAgZm9yICg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAgICAgICAgIC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKHRyYWMtMjU1MSlcbiAgICAgICAgICAgICAgaWYgKChvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXgpICYmXG5cbiAgICAgICAgICAgICAgICAvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG4gICAgICAgICAgICAgICAgIW9wdGlvbi5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgICghb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcbiAgICAgICAgICAgICAgICAgICFub2RlTmFtZShvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiKSkpIHtcblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeShvcHRpb24pLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcbiAgICAgICAgICAgICAgICBpZiAob25lKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAoZWxlbSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25TZXQsIG9wdGlvbixcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcbiAgICAgICAgICAgICAgdmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSh2YWx1ZSksXG4gICAgICAgICAgICAgIGkgPSBvcHRpb25zLmxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cbiAgICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCA9XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmluQXJyYXkoalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQob3B0aW9uKSwgdmFsdWVzKSA+IC0xXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvblNldCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG4gICAgICAgICAgICBpZiAoIW9wdGlvblNldCkge1xuICAgICAgICAgICAgICBlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxuICAgIGpRdWVyeS5lYWNoKFtcInJhZGlvXCIsIFwiY2hlY2tib3hcIl0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGpRdWVyeS52YWxIb29rc1t0aGlzXSA9IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZWxlbSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoalF1ZXJ5KGVsZW0pLnZhbCgpLCB2YWx1ZSkgPiAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKCFzdXBwb3J0LmNoZWNrT24pIHtcbiAgICAgICAgalF1ZXJ5LnZhbEhvb2tzW3RoaXNdLmdldCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4gICAgLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuICAgIHZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxuICAgIHZhciBub25jZSA9IHsgZ3VpZDogRGF0ZS5ub3coKSB9O1xuXG4gICAgdmFyIHJxdWVyeSA9ICgvXFw/Lyk7XG5cblxuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xuICAgIGpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgeG1sLCBwYXJzZXJFcnJvckVsZW07XG4gICAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG4gICAgICAvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cbiAgICAgIHRyeSB7XG4gICAgICAgIHhtbCA9IChuZXcgd2luZG93LkRPTVBhcnNlcigpKS5wYXJzZUZyb21TdHJpbmcoZGF0YSwgXCJ0ZXh0L3htbFwiKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgICBwYXJzZXJFcnJvckVsZW0gPSB4bWwgJiYgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIilbMF07XG4gICAgICBpZiAoIXhtbCB8fCBwYXJzZXJFcnJvckVsZW0pIHtcbiAgICAgICAgalF1ZXJ5LmVycm9yKFwiSW52YWxpZCBYTUw6IFwiICsgKFxuICAgICAgICAgIHBhcnNlckVycm9yRWxlbSA/XG4gICAgICAgICAgICBqUXVlcnkubWFwKHBhcnNlckVycm9yRWxlbS5jaGlsZE5vZGVzLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfSkuam9pbihcIlxcblwiKSA6XG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHhtbDtcbiAgICB9O1xuXG5cbiAgICB2YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG4gICAgICBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9O1xuXG4gICAgalF1ZXJ5LmV4dGVuZChqUXVlcnkuZXZlbnQsIHtcblxuICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMpIHtcblxuICAgICAgICB2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcbiAgICAgICAgICBldmVudFBhdGggPSBbZWxlbSB8fCBkb2N1bWVudF0sXG4gICAgICAgICAgdHlwZSA9IGhhc093bi5jYWxsKGV2ZW50LCBcInR5cGVcIikgPyBldmVudC50eXBlIDogZXZlbnQsXG4gICAgICAgICAgbmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKGV2ZW50LCBcIm5hbWVzcGFjZVwiKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcblxuICAgICAgICBjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG4gICAgICAgIC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcbiAgICAgICAgaWYgKHJmb2N1c01vcnBoLnRlc3QodHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUuaW5kZXhPZihcIi5cIikgPiAtMSkge1xuXG4gICAgICAgICAgLy8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuICAgICAgICAgIG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICB0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuICAgICAgICAgIG5hbWVzcGFjZXMuc29ydCgpO1xuICAgICAgICB9XG4gICAgICAgIG9udHlwZSA9IHR5cGUuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIHR5cGU7XG5cbiAgICAgICAgLy8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG4gICAgICAgIGV2ZW50ID0gZXZlbnRbalF1ZXJ5LmV4cGFuZG9dID9cbiAgICAgICAgICBldmVudCA6XG4gICAgICAgICAgbmV3IGpRdWVyeS5FdmVudCh0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQpO1xuXG4gICAgICAgIC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcbiAgICAgICAgZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG4gICAgICAgIGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbihcIi5cIik7XG4gICAgICAgIGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuICAgICAgICAgIG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIikgOlxuICAgICAgICAgIG51bGw7XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG4gICAgICAgIGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFldmVudC50YXJnZXQpIHtcbiAgICAgICAgICBldmVudC50YXJnZXQgPSBlbGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuICAgICAgICBkYXRhID0gZGF0YSA9PSBudWxsID9cbiAgICAgICAgICBbZXZlbnRdIDpcbiAgICAgICAgICBqUXVlcnkubWFrZUFycmF5KGRhdGEsIFtldmVudF0pO1xuXG4gICAgICAgIC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcbiAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW3R5cGVdIHx8IHt9O1xuICAgICAgICBpZiAoIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KGVsZW0sIGRhdGEpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKHRyYWMtOTk1MSlcbiAgICAgICAgLy8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICh0cmFjLTk3MjQpXG4gICAgICAgIGlmICghb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyhlbGVtKSkge1xuXG4gICAgICAgICAgYnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG4gICAgICAgICAgaWYgKCFyZm9jdXNNb3JwaC50ZXN0KGJ1YmJsZVR5cGUgKyB0eXBlKSkge1xuICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBldmVudFBhdGgucHVzaChjdXIpO1xuICAgICAgICAgICAgdG1wID0gY3VyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuICAgICAgICAgIGlmICh0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpKSB7XG4gICAgICAgICAgICBldmVudFBhdGgucHVzaCh0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlICgoY3VyID0gZXZlbnRQYXRoW2krK10pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgbGFzdEVsZW1lbnQgPSBjdXI7XG4gICAgICAgICAgZXZlbnQudHlwZSA9IGkgPiAxID9cbiAgICAgICAgICAgIGJ1YmJsZVR5cGUgOlxuICAgICAgICAgICAgc3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG4gICAgICAgICAgLy8galF1ZXJ5IGhhbmRsZXJcbiAgICAgICAgICBoYW5kbGUgPSAoZGF0YVByaXYuZ2V0KGN1ciwgXCJldmVudHNcIikgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSlbZXZlbnQudHlwZV0gJiZcbiAgICAgICAgICAgIGRhdGFQcml2LmdldChjdXIsIFwiaGFuZGxlXCIpO1xuICAgICAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgICAgIGhhbmRsZS5hcHBseShjdXIsIGRhdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE5hdGl2ZSBoYW5kbGVyXG4gICAgICAgICAgaGFuZGxlID0gb250eXBlICYmIGN1cltvbnR5cGVdO1xuICAgICAgICAgIGlmIChoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoY3VyKSkge1xuICAgICAgICAgICAgZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KGN1ciwgZGF0YSk7XG4gICAgICAgICAgICBpZiAoZXZlbnQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBldmVudC50eXBlID0gdHlwZTtcblxuICAgICAgICAvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG4gICAgICAgIGlmICghb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuXG4gICAgICAgICAgaWYgKCghc3BlY2lhbC5fZGVmYXVsdCB8fFxuICAgICAgICAgICAgc3BlY2lhbC5fZGVmYXVsdC5hcHBseShldmVudFBhdGgucG9wKCksIGRhdGEpID09PSBmYWxzZSkgJiZcbiAgICAgICAgICAgIGFjY2VwdERhdGEoZWxlbSkpIHtcblxuICAgICAgICAgICAgLy8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cbiAgICAgICAgICAgIC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICh0cmFjLTYxNzApXG4gICAgICAgICAgICBpZiAob250eXBlICYmIGlzRnVuY3Rpb24oZWxlbVt0eXBlXSkgJiYgIWlzV2luZG93KGVsZW0pKSB7XG5cbiAgICAgICAgICAgICAgLy8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuICAgICAgICAgICAgICB0bXAgPSBlbGVtW29udHlwZV07XG5cbiAgICAgICAgICAgICAgaWYgKHRtcCkge1xuICAgICAgICAgICAgICAgIGVsZW1bb250eXBlXSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuICAgICAgICAgICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWxlbVt0eXBlXSgpO1xuXG4gICAgICAgICAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICAgICAgbGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIGlmICh0bXApIHtcbiAgICAgICAgICAgICAgICBlbGVtW29udHlwZV0gPSB0bXA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xuICAgICAgfSxcblxuICAgICAgLy8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG4gICAgICAvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuICAgICAgc2ltdWxhdGU6IGZ1bmN0aW9uICh0eXBlLCBlbGVtLCBldmVudCkge1xuICAgICAgICB2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG4gICAgICAgICAgbmV3IGpRdWVyeS5FdmVudCgpLFxuICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBpc1NpbXVsYXRlZDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihlLCBudWxsLCBlbGVtKTtcbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG5cbiAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKHR5cGUsIGRhdGEsIHRoaXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdO1xuICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgIHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlcih0eXBlLCBkYXRhLCBlbGVtLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICB2YXJcbiAgICAgIHJicmFja2V0ID0gL1xcW1xcXSQvLFxuICAgICAgckNSTEYgPSAvXFxyP1xcbi9nLFxuICAgICAgcnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuICAgICAgcnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG4gICAgZnVuY3Rpb24gYnVpbGRQYXJhbXMocHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQpIHtcbiAgICAgIHZhciBuYW1lO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG5cbiAgICAgICAgLy8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG4gICAgICAgIGpRdWVyeS5lYWNoKG9iaiwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgICBpZiAodHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdChwcmVmaXgpKSB7XG5cbiAgICAgICAgICAgIC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cbiAgICAgICAgICAgIGFkZChwcmVmaXgsIHYpO1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG4gICAgICAgICAgICBidWlsZFBhcmFtcyhcbiAgICAgICAgICAgICAgcHJlZml4ICsgXCJbXCIgKyAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIpICsgXCJdXCIsXG4gICAgICAgICAgICAgIHYsXG4gICAgICAgICAgICAgIHRyYWRpdGlvbmFsLFxuICAgICAgICAgICAgICBhZGRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgfSBlbHNlIGlmICghdHJhZGl0aW9uYWwgJiYgdG9UeXBlKG9iaikgPT09IFwib2JqZWN0XCIpIHtcblxuICAgICAgICAvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG4gICAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcbiAgICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqW25hbWVdLCB0cmFkaXRpb25hbCwgYWRkKTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cbiAgICAgICAgYWRkKHByZWZpeCwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuICAgIC8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xuICAgIGpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uIChhLCB0cmFkaXRpb25hbCkge1xuICAgICAgdmFyIHByZWZpeCxcbiAgICAgICAgcyA9IFtdLFxuICAgICAgICBhZGQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZU9yRnVuY3Rpb24pIHtcblxuICAgICAgICAgIC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKHZhbHVlT3JGdW5jdGlvbikgP1xuICAgICAgICAgICAgdmFsdWVPckZ1bmN0aW9uKCkgOlxuICAgICAgICAgICAgdmFsdWVPckZ1bmN0aW9uO1xuXG4gICAgICAgICAgc1tzLmxlbmd0aF0gPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArIFwiPVwiICtcbiAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpIHx8IChhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoYSkpKSB7XG5cbiAgICAgICAgLy8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG4gICAgICAgIGpRdWVyeS5lYWNoKGEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhZGQodGhpcy5uYW1lLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcbiAgICAgICAgLy8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG4gICAgICAgIGZvciAocHJlZml4IGluIGEpIHtcbiAgICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXgsIGFbcHJlZml4XSwgdHJhZGl0aW9uYWwsIGFkZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuICAgICAgcmV0dXJuIHMuam9pbihcIiZcIik7XG4gICAgfTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKTtcbiAgICAgIH0sXG4gICAgICBzZXJpYWxpemVBcnJheTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgLy8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKHRoaXMsIFwiZWxlbWVudHNcIik7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheShlbGVtZW50cykgOiB0aGlzO1xuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICAgICAgLy8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG4gICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KHRoaXMpLmlzKFwiOmRpc2FibGVkXCIpICYmXG4gICAgICAgICAgICByc3VibWl0dGFibGUudGVzdCh0aGlzLm5vZGVOYW1lKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QodHlwZSkgJiZcbiAgICAgICAgICAgICh0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QodHlwZSkpO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKF9pLCBlbGVtKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGpRdWVyeSh0aGlzKS52YWwoKTtcblxuICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5tYXAodmFsLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKHJDUkxGLCBcIlxcclxcblwiKSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UockNSTEYsIFwiXFxyXFxuXCIpIH07XG4gICAgICAgIH0pLmdldCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICB2YXJcbiAgICAgIHIyMCA9IC8lMjAvZyxcbiAgICAgIHJoYXNoID0gLyMuKiQvLFxuICAgICAgcmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcbiAgICAgIHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuICAgICAgLy8gdHJhYy03NjUzLCB0cmFjLTgxMjUsIHRyYWMtODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG4gICAgICBybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuICAgICAgcm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG4gICAgICBycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cbiAgICAgIC8qIFByZWZpbHRlcnNcbiAgICAgICAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG4gICAgICAgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuICAgICAgICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuICAgICAgICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuICAgICAgICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuICAgICAgICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuICAgICAgICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcbiAgICAgICAqL1xuICAgICAgcHJlZmlsdGVycyA9IHt9LFxuXG4gICAgICAvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG4gICAgICAgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG4gICAgICAgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG4gICAgICAgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcbiAgICAgICAqL1xuICAgICAgdHJhbnNwb3J0cyA9IHt9LFxuXG4gICAgICAvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICh0cmFjLTEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG4gICAgICBhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoXCIqXCIpLFxuXG4gICAgICAvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cbiAgICAgIG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXG4gICAgb3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4gICAgLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuICAgIGZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyhzdHJ1Y3R1cmUpIHtcblxuICAgICAgLy8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMpIHtcblxuICAgICAgICBpZiAodHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG4gICAgICAgICAgZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YVR5cGUsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW107XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZnVuYykpIHtcblxuICAgICAgICAgIC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cbiAgICAgICAgICB3aGlsZSAoKGRhdGFUeXBlID0gZGF0YVR5cGVzW2krK10pKSB7XG5cbiAgICAgICAgICAgIC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICBpZiAoZGF0YVR5cGVbMF0gPT09IFwiK1wiKSB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoMSkgfHwgXCIqXCI7XG4gICAgICAgICAgICAgIChzdHJ1Y3R1cmVbZGF0YVR5cGVdID0gc3RydWN0dXJlW2RhdGFUeXBlXSB8fCBbXSkudW5zaGlmdChmdW5jKTtcblxuICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYXBwZW5kXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAoc3RydWN0dXJlW2RhdGFUeXBlXSA9IHN0cnVjdHVyZVtkYXRhVHlwZV0gfHwgW10pLnB1c2goZnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuICAgIGZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUikge1xuXG4gICAgICB2YXIgaW5zcGVjdGVkID0ge30sXG4gICAgICAgIHNlZWtpbmdUcmFuc3BvcnQgPSAoc3RydWN0dXJlID09PSB0cmFuc3BvcnRzKTtcblxuICAgICAgZnVuY3Rpb24gaW5zcGVjdChkYXRhVHlwZSkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQ7XG4gICAgICAgIGluc3BlY3RlZFtkYXRhVHlwZV0gPSB0cnVlO1xuICAgICAgICBqUXVlcnkuZWFjaChzdHJ1Y3R1cmVbZGF0YVR5cGVdIHx8IFtdLCBmdW5jdGlvbiAoXywgcHJlZmlsdGVyT3JGYWN0b3J5KSB7XG4gICAgICAgICAgdmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3Rvcnkob3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUik7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkW2RhdGFUeXBlT3JUcmFuc3BvcnRdKSB7XG5cbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoZGF0YVR5cGVPclRyYW5zcG9ydCk7XG4gICAgICAgICAgICBpbnNwZWN0KGRhdGFUeXBlT3JUcmFuc3BvcnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2Vla2luZ1RyYW5zcG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuICEoc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnNwZWN0KG9wdGlvbnMuZGF0YVR5cGVzWzBdKSB8fCAhaW5zcGVjdGVkW1wiKlwiXSAmJiBpbnNwZWN0KFwiKlwiKTtcbiAgICB9XG5cbiAgICAvLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbiAgICAvLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuICAgIC8vIEZpeGVzIHRyYWMtOTg4N1xuICAgIGZ1bmN0aW9uIGFqYXhFeHRlbmQodGFyZ2V0LCBzcmMpIHtcbiAgICAgIHZhciBrZXksIGRlZXAsXG4gICAgICAgIGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuICAgICAgZm9yIChrZXkgaW4gc3JjKSB7XG4gICAgICAgIGlmIChzcmNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgKGZsYXRPcHRpb25zW2tleV0gPyB0YXJnZXQgOiAoZGVlcCB8fCAoZGVlcCA9IHt9KSkpW2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCB0YXJnZXQsIGRlZXApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAgICAgKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICAgICAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMocywganFYSFIsIHJlc3BvbnNlcykge1xuXG4gICAgICB2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG4gICAgICAgIGNvbnRlbnRzID0gcy5jb250ZW50cyxcbiAgICAgICAgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cbiAgICAgIC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG4gICAgICB3aGlsZSAoZGF0YVR5cGVzWzBdID09PSBcIipcIikge1xuICAgICAgICBkYXRhVHlwZXMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG4gICAgICBpZiAoY3QpIHtcbiAgICAgICAgZm9yICh0eXBlIGluIGNvbnRlbnRzKSB7XG4gICAgICAgICAgaWYgKGNvbnRlbnRzW3R5cGVdICYmIGNvbnRlbnRzW3R5cGVdLnRlc3QoY3QpKSB7XG4gICAgICAgICAgICBkYXRhVHlwZXMudW5zaGlmdCh0eXBlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcbiAgICAgIGlmIChkYXRhVHlwZXNbMF0gaW4gcmVzcG9uc2VzKSB7XG4gICAgICAgIGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbMF07XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcbiAgICAgICAgZm9yICh0eXBlIGluIHJlc3BvbnNlcykge1xuICAgICAgICAgIGlmICghZGF0YVR5cGVzWzBdIHx8IHMuY29udmVydGVyc1t0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbMF1dKSB7XG4gICAgICAgICAgICBmaW5hbERhdGFUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZpcnN0RGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuICAgICAgICBmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG4gICAgICAvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuICAgICAgLy8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICAgICAgaWYgKGZpbmFsRGF0YVR5cGUpIHtcbiAgICAgICAgaWYgKGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1swXSkge1xuICAgICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KGZpbmFsRGF0YVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZXNbZmluYWxEYXRhVHlwZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICAgICAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFqYXhDb252ZXJ0KHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzKSB7XG4gICAgICB2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcbiAgICAgICAgY29udmVydGVycyA9IHt9LFxuXG4gICAgICAgIC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cbiAgICAgICAgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuICAgICAgLy8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG4gICAgICBpZiAoZGF0YVR5cGVzWzFdKSB7XG4gICAgICAgIGZvciAoY29udiBpbiBzLmNvbnZlcnRlcnMpIHtcbiAgICAgICAgICBjb252ZXJ0ZXJzW2NvbnYudG9Mb3dlckNhc2UoKV0gPSBzLmNvbnZlcnRlcnNbY29udl07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG4gICAgICAvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcblxuICAgICAgICBpZiAocy5yZXNwb25zZUZpZWxkc1tjdXJyZW50XSkge1xuICAgICAgICAgIGpxWEhSW3MucmVzcG9uc2VGaWVsZHNbY3VycmVudF1dID0gcmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuICAgICAgICBpZiAoIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlcikge1xuICAgICAgICAgIHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKHJlc3BvbnNlLCBzLmRhdGFUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXYgPSBjdXJyZW50O1xuICAgICAgICBjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcblxuICAgICAgICAgIC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gXCIqXCIpIHtcblxuICAgICAgICAgICAgY3VycmVudCA9IHByZXY7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQpIHtcblxuICAgICAgICAgICAgLy8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcbiAgICAgICAgICAgIGNvbnYgPSBjb252ZXJ0ZXJzW3ByZXYgKyBcIiBcIiArIGN1cnJlbnRdIHx8IGNvbnZlcnRlcnNbXCIqIFwiICsgY3VycmVudF07XG5cbiAgICAgICAgICAgIC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG4gICAgICAgICAgICBpZiAoIWNvbnYpIHtcbiAgICAgICAgICAgICAgZm9yIChjb252MiBpbiBjb252ZXJ0ZXJzKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcbiAgICAgICAgICAgICAgICB0bXAgPSBjb252Mi5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgaWYgKHRtcFsxXSA9PT0gY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcbiAgICAgICAgICAgICAgICAgIGNvbnYgPSBjb252ZXJ0ZXJzW3ByZXYgKyBcIiBcIiArIHRtcFswXV0gfHxcbiAgICAgICAgICAgICAgICAgICAgY29udmVydGVyc1tcIiogXCIgKyB0bXBbMF1dO1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbnYpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb252ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbY29udjJdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnZlcnRlcnNbY29udjJdICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRtcFswXTtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZXMudW5zaGlmdCh0bXBbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcbiAgICAgICAgICAgIGlmIChjb252ICE9PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgLy8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuICAgICAgICAgICAgICBpZiAoY29udiAmJiBzLnRocm93cykge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gY29udihyZXNwb25zZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gY29udihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwicGFyc2VyZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG4gICAgfVxuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG5cbiAgICAgIC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuICAgICAgYWN0aXZlOiAwLFxuXG4gICAgICAvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG4gICAgICBsYXN0TW9kaWZpZWQ6IHt9LFxuICAgICAgZXRhZzoge30sXG5cbiAgICAgIGFqYXhTZXR0aW5nczoge1xuICAgICAgICB1cmw6IGxvY2F0aW9uLmhyZWYsXG4gICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgIGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QobG9jYXRpb24ucHJvdG9jb2wpLFxuICAgICAgICBnbG9iYWw6IHRydWUsXG4gICAgICAgIHByb2Nlc3NEYXRhOiB0cnVlLFxuICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cbiAgICAgICAgLypcbiAgICAgICAgdGltZW91dDogMCxcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZGF0YVR5cGU6IG51bGwsXG4gICAgICAgIHVzZXJuYW1lOiBudWxsLFxuICAgICAgICBwYXNzd29yZDogbnVsbCxcbiAgICAgICAgY2FjaGU6IG51bGwsXG4gICAgICAgIHRocm93czogZmFsc2UsXG4gICAgICAgIHRyYWRpdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICovXG5cbiAgICAgICAgYWNjZXB0czoge1xuICAgICAgICAgIFwiKlwiOiBhbGxUeXBlcyxcbiAgICAgICAgICB0ZXh0OiBcInRleHQvcGxhaW5cIixcbiAgICAgICAgICBodG1sOiBcInRleHQvaHRtbFwiLFxuICAgICAgICAgIHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG4gICAgICAgICAganNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRlbnRzOiB7XG4gICAgICAgICAgeG1sOiAvXFxieG1sXFxiLyxcbiAgICAgICAgICBodG1sOiAvXFxiaHRtbC8sXG4gICAgICAgICAganNvbjogL1xcYmpzb25cXGIvXG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzcG9uc2VGaWVsZHM6IHtcbiAgICAgICAgICB4bWw6IFwicmVzcG9uc2VYTUxcIixcbiAgICAgICAgICB0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuICAgICAgICAgIGpzb246IFwicmVzcG9uc2VKU09OXCJcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEYXRhIGNvbnZlcnRlcnNcbiAgICAgICAgLy8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICBjb252ZXJ0ZXJzOiB7XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcbiAgICAgICAgICBcIiogdGV4dFwiOiBTdHJpbmcsXG5cbiAgICAgICAgICAvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcbiAgICAgICAgICBcInRleHQgaHRtbFwiOiB0cnVlLFxuXG4gICAgICAgICAgLy8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuICAgICAgICAgIFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cbiAgICAgICAgICAvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuICAgICAgICAgIFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcbiAgICAgICAgLy8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuICAgICAgICAvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuICAgICAgICAvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcbiAgICAgICAgZmxhdE9wdGlvbnM6IHtcbiAgICAgICAgICB1cmw6IHRydWUsXG4gICAgICAgICAgY29udGV4dDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuICAgICAgLy8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuICAgICAgLy8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cbiAgICAgIGFqYXhTZXR1cDogZnVuY3Rpb24gKHRhcmdldCwgc2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIHNldHRpbmdzID9cblxuICAgICAgICAgIC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAgYWpheEV4dGVuZChhamF4RXh0ZW5kKHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyksIHNldHRpbmdzKSA6XG5cbiAgICAgICAgICAvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG4gICAgICAgICAgYWpheEV4dGVuZChqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQpO1xuICAgICAgfSxcblxuICAgICAgYWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHByZWZpbHRlcnMpLFxuICAgICAgYWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHRyYW5zcG9ydHMpLFxuXG4gICAgICAvLyBNYWluIG1ldGhvZFxuICAgICAgYWpheDogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuXG4gICAgICAgIC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHVybDtcbiAgICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgdHJhbnNwb3J0LFxuXG4gICAgICAgICAgLy8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuICAgICAgICAgIGNhY2hlVVJMLFxuXG4gICAgICAgICAgLy8gUmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG5cbiAgICAgICAgICAvLyB0aW1lb3V0IGhhbmRsZVxuICAgICAgICAgIHRpbWVvdXRUaW1lcixcblxuICAgICAgICAgIC8vIFVybCBjbGVhbnVwIHZhclxuICAgICAgICAgIHVybEFuY2hvcixcblxuICAgICAgICAgIC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcbiAgICAgICAgICBjb21wbGV0ZWQsXG5cbiAgICAgICAgICAvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcbiAgICAgICAgICBmaXJlR2xvYmFscyxcblxuICAgICAgICAgIC8vIExvb3AgdmFyaWFibGVcbiAgICAgICAgICBpLFxuXG4gICAgICAgICAgLy8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG4gICAgICAgICAgdW5jYWNoZWQsXG5cbiAgICAgICAgICAvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAgcyA9IGpRdWVyeS5hamF4U2V0dXAoe30sIG9wdGlvbnMpLFxuXG4gICAgICAgICAgLy8gQ2FsbGJhY2tzIGNvbnRleHRcbiAgICAgICAgICBjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuICAgICAgICAgIC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cbiAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcbiAgICAgICAgICAgIChjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSkgP1xuICAgICAgICAgICAgalF1ZXJ5KGNhbGxiYWNrQ29udGV4dCkgOlxuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LFxuXG4gICAgICAgICAgLy8gRGVmZXJyZWRzXG4gICAgICAgICAgZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcbiAgICAgICAgICBjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFxuXG4gICAgICAgICAgLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcbiAgICAgICAgICBzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG4gICAgICAgICAgLy8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcbiAgICAgICAgICByZXF1ZXN0SGVhZGVycyA9IHt9LFxuICAgICAgICAgIHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuICAgICAgICAgIC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuICAgICAgICAgIHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG4gICAgICAgICAgLy8gRmFrZSB4aHJcbiAgICAgICAgICBqcVhIUiA9IHtcbiAgICAgICAgICAgIHJlYWR5U3RhdGU6IDAsXG5cbiAgICAgICAgICAgIC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcbiAgICAgICAgICAgIGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSByaGVhZGVycy5leGVjKHJlc3BvbnNlSGVhZGVyc1N0cmluZykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyc1ttYXRjaFsxXS50b0xvd2VyQ2FzZSgpICsgXCIgXCJdID1cbiAgICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2VIZWFkZXJzW21hdGNoWzFdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIl0gfHwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG1hdGNoWzJdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSByZXNwb25zZUhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCkgKyBcIiBcIl07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gUmF3IHN0cmluZ1xuICAgICAgICAgICAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gQ2FjaGVzIHRoZSBoZWFkZXJcbiAgICAgICAgICAgIHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1tuYW1lLnRvTG93ZXJDYXNlKCldID1cbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzTmFtZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuICAgICAgICAgICAgb3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcy5taW1lVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcblxuICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICBqcVhIUi5hbHdheXMobWFwW2pxWEhSLnN0YXR1c10pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgIC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG4gICAgICAgICAgICAgICAgICBmb3IgKGNvZGUgaW4gbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGVbY29kZV0gPSBbc3RhdHVzQ29kZVtjb2RlXSwgbWFwW2NvZGVdXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBDYW5jZWwgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoc3RhdHVzVGV4dCkge1xuICAgICAgICAgICAgICB2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcbiAgICAgICAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5hYm9ydChmaW5hbFRleHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvbmUoMCwgZmluYWxUZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAvLyBBdHRhY2ggZGVmZXJyZWRzXG4gICAgICAgIGRlZmVycmVkLnByb21pc2UoanFYSFIpO1xuXG4gICAgICAgIC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuICAgICAgICAvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKHRyYWMtMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcbiAgICAgICAgLy8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG4gICAgICAgIHMudXJsID0gKCh1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZikgKyBcIlwiKVxuICAgICAgICAgIC5yZXBsYWNlKHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIpO1xuXG4gICAgICAgIC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0IHRyYWMtMTIwMDRcbiAgICAgICAgcy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuICAgICAgICAvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG4gICAgICAgIHMuZGF0YVR5cGVzID0gKHMuZGF0YVR5cGUgfHwgXCIqXCIpLnRvTG93ZXJDYXNlKCkubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW1wiXCJdO1xuXG4gICAgICAgIC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuICAgICAgICBpZiAocy5jcm9zc0RvbWFpbiA9PSBudWxsKSB7XG4gICAgICAgICAgdXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cbiAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG4gICAgICAgICAgLy8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcbiAgICAgICAgICAvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcbiAgICAgICAgICAgIC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG4gICAgICAgICAgICB1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuICAgICAgICAgICAgcy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuICAgICAgICAgICAgICB1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuICAgICAgICAgICAgLy8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuICAgICAgICAgICAgcy5jcm9zc0RvbWFpbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG4gICAgICAgIGlmIChzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcy5kYXRhID0galF1ZXJ5LnBhcmFtKHMuZGF0YSwgcy50cmFkaXRpb25hbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSBwcmVmaWx0ZXJzXG4gICAgICAgIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSKTtcblxuICAgICAgICAvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cbiAgICAgICAgLy8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKHRyYWMtMTUxMTgpXG4gICAgICAgIGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG4gICAgICAgIC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcbiAgICAgICAgaWYgKGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCkge1xuICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBwZXJjYXNlIHRoZSB0eXBlXG4gICAgICAgIHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG4gICAgICAgIHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3Qocy50eXBlKTtcblxuICAgICAgICAvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2VcbiAgICAgICAgLy8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG4gICAgICAgIC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cbiAgICAgICAgY2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKHJoYXNoLCBcIlwiKTtcblxuICAgICAgICAvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuICAgICAgICBpZiAoIXMuaGFzQ29udGVudCkge1xuXG4gICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG4gICAgICAgICAgdW5jYWNoZWQgPSBzLnVybC5zbGljZShjYWNoZVVSTC5sZW5ndGgpO1xuXG4gICAgICAgICAgLy8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuICAgICAgICAgIGlmIChzLmRhdGEgJiYgKHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIGNhY2hlVVJMICs9IChycXVlcnkudGVzdChjYWNoZVVSTCkgPyBcIiZcIiA6IFwiP1wiKSArIHMuZGF0YTtcblxuICAgICAgICAgICAgLy8gdHJhYy05NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcbiAgICAgICAgICAgIGRlbGV0ZSBzLmRhdGE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuICAgICAgICAgIGlmIChzLmNhY2hlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKHJhbnRpQ2FjaGUsIFwiJDFcIik7XG4gICAgICAgICAgICB1bmNhY2hlZCA9IChycXVlcnkudGVzdChjYWNoZVVSTCkgPyBcIiZcIiA6IFwiP1wiKSArIFwiXz1cIiArIChub25jZS5ndWlkKyspICtcbiAgICAgICAgICAgICAgdW5jYWNoZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuICAgICAgICAgIHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuICAgICAgICAgIC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuICAgICAgICB9IGVsc2UgaWYgKHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG4gICAgICAgICAgKHMuY29udGVudFR5cGUgfHwgXCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSA9PT0gMCkge1xuICAgICAgICAgIHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKHIyMCwgXCIrXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cbiAgICAgICAgaWYgKHMuaWZNb2RpZmllZCkge1xuICAgICAgICAgIGlmIChqUXVlcnkubGFzdE1vZGlmaWVkW2NhY2hlVVJMXSkge1xuICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGpRdWVyeS5ldGFnW2NhY2hlVVJMXSkge1xuICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbY2FjaGVVUkxdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcbiAgICAgICAgaWYgKHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSkge1xuICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG4gICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG4gICAgICAgICAgXCJBY2NlcHRcIixcbiAgICAgICAgICBzLmRhdGFUeXBlc1swXSAmJiBzLmFjY2VwdHNbcy5kYXRhVHlwZXNbMF1dID9cbiAgICAgICAgICAgIHMuYWNjZXB0c1tzLmRhdGFUeXBlc1swXV0gK1xuICAgICAgICAgICAgKHMuZGF0YVR5cGVzWzBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIikgOlxuICAgICAgICAgICAgcy5hY2NlcHRzW1wiKlwiXVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuICAgICAgICBmb3IgKGkgaW4gcy5oZWFkZXJzKSB7XG4gICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihpLCBzLmhlYWRlcnNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuICAgICAgICBpZiAocy5iZWZvcmVTZW5kICYmXG4gICAgICAgICAgKHMuYmVmb3JlU2VuZC5jYWxsKGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMpID09PSBmYWxzZSB8fCBjb21wbGV0ZWQpKSB7XG5cbiAgICAgICAgICAvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cbiAgICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuICAgICAgICBzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuICAgICAgICAvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcbiAgICAgICAgY29tcGxldGVEZWZlcnJlZC5hZGQocy5jb21wbGV0ZSk7XG4gICAgICAgIGpxWEhSLmRvbmUocy5zdWNjZXNzKTtcbiAgICAgICAganFYSFIuZmFpbChzLmVycm9yKTtcblxuICAgICAgICAvLyBHZXQgdHJhbnNwb3J0XG4gICAgICAgIHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSKTtcblxuICAgICAgICAvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgICAgICBkb25lKC0xLCBcIk5vIFRyYW5zcG9ydFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuICAgICAgICAgIC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG4gICAgICAgICAgaWYgKGZpcmVHbG9iYWxzKSB7XG4gICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlcihcImFqYXhTZW5kXCIsIFtqcVhIUiwgc10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG4gICAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRpbWVvdXRcbiAgICAgICAgICBpZiAocy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGpxWEhSLmFib3J0KFwidGltZW91dFwiKTtcbiAgICAgICAgICAgIH0sIHMudGltZW91dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnNlbmQocmVxdWVzdEhlYWRlcnMsIGRvbmUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgLy8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcbiAgICAgICAgICAgIGRvbmUoLTEsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuICAgICAgICBmdW5jdGlvbiBkb25lKHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzKSB7XG4gICAgICAgICAgdmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG4gICAgICAgICAgLy8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcbiAgICAgICAgICBpZiAodGltZW91dFRpbWVyKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICAgICAgICAvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuICAgICAgICAgIHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cbiAgICAgICAgICAvLyBTZXQgcmVhZHlTdGF0ZVxuICAgICAgICAgIGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cbiAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuICAgICAgICAgIGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG4gICAgICAgICAgLy8gR2V0IHJlc3BvbnNlIGRhdGFcbiAgICAgICAgICBpZiAocmVzcG9uc2VzKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMocywganFYSFIsIHJlc3BvbnNlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlIGEgbm9vcCBjb252ZXJ0ZXIgZm9yIG1pc3Npbmcgc2NyaXB0IGJ1dCBub3QgaWYganNvbnBcbiAgICAgICAgICBpZiAoIWlzU3VjY2VzcyAmJlxuICAgICAgICAgICAgalF1ZXJ5LmluQXJyYXkoXCJzY3JpcHRcIiwgcy5kYXRhVHlwZXMpID4gLTEgJiZcbiAgICAgICAgICAgIGpRdWVyeS5pbkFycmF5KFwianNvblwiLCBzLmRhdGFUeXBlcykgPCAwKSB7XG4gICAgICAgICAgICBzLmNvbnZlcnRlcnNbXCJ0ZXh0IHNjcmlwdFwiXSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG4gICAgICAgICAgcmVzcG9uc2UgPSBhamF4Q29udmVydChzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2Vzcyk7XG5cbiAgICAgICAgICAvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuICAgICAgICAgIGlmIChpc1N1Y2Nlc3MpIHtcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cbiAgICAgICAgICAgIGlmIChzLmlmTW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgbW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIik7XG4gICAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdID0gbW9kaWZpZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIik7XG4gICAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldGFnW2NhY2hlVVJMXSA9IG1vZGlmaWVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIG5vIGNvbnRlbnRcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG4gICAgICAgICAgICAgIC8vIGlmIG5vdCBtb2RpZmllZFxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDMwNCkge1xuICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG4gICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuICAgICAgICAgICAgICBzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgICAgZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcbiAgICAgICAgICAgICAgaXNTdWNjZXNzID0gIWVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcbiAgICAgICAgICAgIGVycm9yID0gc3RhdHVzVGV4dDtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgfHwgIXN0YXR1c1RleHQpIHtcbiAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgaWYgKHN0YXR1cyA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3RcbiAgICAgICAgICBqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAganFYSFIuc3RhdHVzVGV4dCA9IChuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQpICsgXCJcIjtcblxuICAgICAgICAgIC8vIFN1Y2Nlc3MvRXJyb3JcbiAgICAgICAgICBpZiAoaXNTdWNjZXNzKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aChjYWxsYmFja0NvbnRleHQsIFtzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKGNhbGxiYWNrQ29udGV4dCwgW2pxWEhSLCBzdGF0dXNUZXh0LCBlcnJvcl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG4gICAgICAgICAganFYSFIuc3RhdHVzQ29kZShzdGF0dXNDb2RlKTtcbiAgICAgICAgICBzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGZpcmVHbG9iYWxzKSB7XG4gICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlcihpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuICAgICAgICAgICAgICBbanFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvcl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvbXBsZXRlXG4gICAgICAgICAgY29tcGxldGVEZWZlcnJlZC5maXJlV2l0aChjYWxsYmFja0NvbnRleHQsIFtqcVhIUiwgc3RhdHVzVGV4dF0pO1xuXG4gICAgICAgICAgaWYgKGZpcmVHbG9iYWxzKSB7XG4gICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlcihcImFqYXhDb21wbGV0ZVwiLCBbanFYSFIsIHNdKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG4gICAgICAgICAgICBpZiAoISgtLWpRdWVyeS5hY3RpdmUpKSB7XG4gICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgfSxcblxuICAgICAgZ2V0SlNPTjogZnVuY3Rpb24gKHVybCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5nZXQodXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIpO1xuICAgICAgfSxcblxuICAgICAgZ2V0U2NyaXB0OiBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4galF1ZXJ5LmdldCh1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmVhY2goW1wiZ2V0XCIsIFwicG9zdFwiXSwgZnVuY3Rpb24gKF9pLCBtZXRob2QpIHtcbiAgICAgIGpRdWVyeVttZXRob2RdID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUpIHtcblxuICAgICAgICAvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuICAgICAgICBpZiAoaXNGdW5jdGlvbihkYXRhKSkge1xuICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuICAgICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG4gICAgICAgIHJldHVybiBqUXVlcnkuYWpheChqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICB0eXBlOiBtZXRob2QsXG4gICAgICAgICAgZGF0YVR5cGU6IHR5cGUsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBzdWNjZXNzOiBjYWxsYmFja1xuICAgICAgICB9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCh1cmwpICYmIHVybCkpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIGpRdWVyeS5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSBpbiBzLmhlYWRlcnMpIHtcbiAgICAgICAgaWYgKGkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIikge1xuICAgICAgICAgIHMuY29udGVudFR5cGUgPSBzLmhlYWRlcnNbaV0gfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBqUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zLCBkb2MpIHtcbiAgICAgIHJldHVybiBqUXVlcnkuYWpheCh7XG4gICAgICAgIHVybDogdXJsLFxuXG4gICAgICAgIC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAodHJhYy0xMTI2NClcbiAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgZGF0YVR5cGU6IFwic2NyaXB0XCIsXG4gICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgIGdsb2JhbDogZmFsc2UsXG5cbiAgICAgICAgLy8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcbiAgICAgICAgLy8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcbiAgICAgICAgLy8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXG4gICAgICAgIGNvbnZlcnRlcnM6IHtcbiAgICAgICAgICBcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uICgpIHsgfVxuICAgICAgICB9LFxuICAgICAgICBkYXRhRmlsdGVyOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICBqUXVlcnkuZ2xvYmFsRXZhbChyZXNwb25zZSwgb3B0aW9ucywgZG9jKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICB3cmFwQWxsOiBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICB2YXIgd3JhcDtcblxuICAgICAgICBpZiAodGhpc1swXSkge1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGh0bWwpKSB7XG4gICAgICAgICAgICBodG1sID0gaHRtbC5jYWxsKHRoaXNbMF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG4gICAgICAgICAgd3JhcCA9IGpRdWVyeShodG1sLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKHRydWUpO1xuXG4gICAgICAgICAgaWYgKHRoaXNbMF0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgd3JhcC5pbnNlcnRCZWZvcmUodGhpc1swXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd3JhcC5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzO1xuXG4gICAgICAgICAgICB3aGlsZSAoZWxlbS5maXJzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICAgICAgICBlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgICAgfSkuYXBwZW5kKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICB3cmFwSW5uZXI6IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGh0bWwpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLndyYXBJbm5lcihodG1sLmNhbGwodGhpcywgaSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkodGhpcyksXG4gICAgICAgICAgICBjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuICAgICAgICAgIGlmIChjb250ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRlbnRzLndyYXBBbGwoaHRtbCk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5hcHBlbmQoaHRtbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIHdyYXA6IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgIHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oaHRtbCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIGpRdWVyeSh0aGlzKS53cmFwQWxsKGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKHRoaXMsIGkpIDogaHRtbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgdW53cmFwOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQoc2VsZWN0b3IpLm5vdChcImJvZHlcIikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgalF1ZXJ5KHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgalF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgcmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoZWxlbSk7XG4gICAgfTtcbiAgICBqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgcmV0dXJuICEhKGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG4gICAgfTtcblxuXG5cblxuICAgIGpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgIH07XG5cbiAgICB2YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuICAgICAgLy8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcbiAgICAgIDA6IDIwMCxcblxuICAgICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgICAgIC8vIHRyYWMtMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcbiAgICAgIDEyMjM6IDIwNFxuICAgIH0sXG4gICAgICB4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG4gICAgc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkKTtcbiAgICBzdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxuICAgIGpRdWVyeS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cbiAgICAgIC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3RcbiAgICAgIGlmIChzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2VuZDogZnVuY3Rpb24gKGhlYWRlcnMsIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgeGhyID0gb3B0aW9ucy54aHIoKTtcblxuICAgICAgICAgICAgeGhyLm9wZW4oXG4gICAgICAgICAgICAgIG9wdGlvbnMudHlwZSxcbiAgICAgICAgICAgICAgb3B0aW9ucy51cmwsXG4gICAgICAgICAgICAgIG9wdGlvbnMuYXN5bmMsXG4gICAgICAgICAgICAgIG9wdGlvbnMudXNlcm5hbWUsXG4gICAgICAgICAgICAgIG9wdGlvbnMucGFzc3dvcmRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnhockZpZWxkcykge1xuICAgICAgICAgICAgICBmb3IgKGkgaW4gb3B0aW9ucy54aHJGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICB4aHJbaV0gPSBvcHRpb25zLnhockZpZWxkc1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSkge1xuICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShvcHRpb25zLm1pbWVUeXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcbiAgICAgICAgICAgIC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcbiAgICAgICAgICAgIC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG4gICAgICAgICAgICAvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcbiAgICAgICAgICAgIC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSkge1xuICAgICAgICAgICAgICBoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IGhlYWRlcnNcbiAgICAgICAgICAgIGZvciAoaSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIGhlYWRlcnNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxsYmFja1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG4gICAgICAgICAgICAgICAgICAgIHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cbiAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFib3J0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZXJyb3JcIikge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuICAgICAgICAgICAgICAgICAgICAvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKDAsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSB0cmFjLTg2MDUsIHRyYWMtMTQyMDdcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKFxuICAgICAgICAgICAgICAgICAgICAgIHhoclN1Y2Nlc3NTdGF0dXNbeGhyLnN0YXR1c10gfHwgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzVGV4dCxcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG4gICAgICAgICAgICAgICAgICAgICAgKHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIpICE9PSBcInRleHRcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIExpc3RlbiB0byBldmVudHNcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKFwiZXJyb3JcIik7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgb25seVxuICAgICAgICAgICAgLy8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcbiAgICAgICAgICAgIC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcbiAgICAgICAgICAgIGlmICh4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblxuICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG4gICAgICAgICAgICAgICAgICAvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcbiAgICAgICAgICAgICAgICAgIC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcbiAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soXCJhYm9ydFwiKTtcblxuICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG4gICAgICAgICAgICAgIHhoci5zZW5kKG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgICAgLy8gdHJhYy0xNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIC8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG4gICAgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICAgIGlmIChzLmNyb3NzRG9tYWluKSB7XG4gICAgICAgIHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxuICAgIGpRdWVyeS5hamF4U2V0dXAoe1xuICAgICAgYWNjZXB0czoge1xuICAgICAgICBzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG4gICAgICAgICAgXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuICAgICAgfSxcbiAgICAgIGNvbnRlbnRzOiB7XG4gICAgICAgIHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG4gICAgICB9LFxuICAgICAgY29udmVydGVyczoge1xuICAgICAgICBcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgalF1ZXJ5Lmdsb2JhbEV2YWwodGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbiAgICBqUXVlcnkuYWpheFByZWZpbHRlcihcInNjcmlwdFwiLCBmdW5jdGlvbiAocykge1xuICAgICAgaWYgKHMuY2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzLmNhY2hlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocy5jcm9zc0RvbWFpbikge1xuICAgICAgICBzLnR5cGUgPSBcIkdFVFwiO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG4gICAgalF1ZXJ5LmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIiwgZnVuY3Rpb24gKHMpIHtcblxuICAgICAgLy8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcbiAgICAgIGlmIChzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMpIHtcbiAgICAgICAgdmFyIHNjcmlwdCwgY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2VuZDogZnVuY3Rpb24gKF8sIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICBzY3JpcHQgPSBqUXVlcnkoXCI8c2NyaXB0PlwiKVxuICAgICAgICAgICAgICAuYXR0cihzLnNjcmlwdEF0dHJzIHx8IHt9KVxuICAgICAgICAgICAgICAucHJvcCh7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9KVxuICAgICAgICAgICAgICAub24oXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIHNjcmlwdC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGV2dCkge1xuICAgICAgICAgICAgICAgICAgY29tcGxldGUoZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHRbMF0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIHZhciBvbGRDYWxsYmFja3MgPSBbXSxcbiAgICAgIHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbiAgICAvLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG4gICAgalF1ZXJ5LmFqYXhTZXR1cCh7XG4gICAgICBqc29ucDogXCJjYWxsYmFja1wiLFxuICAgICAganNvbnBDYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAobm9uY2UuZ3VpZCsrKSk7XG4gICAgICAgIHRoaXNbY2FsbGJhY2tdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG4gICAgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIoXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uIChzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUikge1xuXG4gICAgICB2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG4gICAgICAgIGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKHJqc29ucC50ZXN0KHMudXJsKSA/XG4gICAgICAgICAgXCJ1cmxcIiA6XG4gICAgICAgICAgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgIChzLmNvbnRlbnRUeXBlIHx8IFwiXCIpXG4gICAgICAgICAgICAuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSA9PT0gMCAmJlxuICAgICAgICAgIHJqc29ucC50ZXN0KHMuZGF0YSkgJiYgXCJkYXRhXCJcbiAgICAgICAgKTtcblxuICAgICAgLy8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuICAgICAgaWYgKGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWzBdID09PSBcImpzb25wXCIpIHtcblxuICAgICAgICAvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG4gICAgICAgIGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24ocy5qc29ucENhbGxiYWNrKSA/XG4gICAgICAgICAgcy5qc29ucENhbGxiYWNrKCkgOlxuICAgICAgICAgIHMuanNvbnBDYWxsYmFjaztcblxuICAgICAgICAvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG4gICAgICAgIGlmIChqc29uUHJvcCkge1xuICAgICAgICAgIHNbanNvblByb3BdID0gc1tqc29uUHJvcF0ucmVwbGFjZShyanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocy5qc29ucCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBzLnVybCArPSAocnF1ZXJ5LnRlc3Qocy51cmwpID8gXCImXCIgOiBcIj9cIikgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG4gICAgICAgIHMuY29udmVydGVyc1tcInNjcmlwdCBqc29uXCJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghcmVzcG9uc2VDb250YWluZXIpIHtcbiAgICAgICAgICAgIGpRdWVyeS5lcnJvcihjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWzBdO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcbiAgICAgICAgcy5kYXRhVHlwZXNbMF0gPSBcImpzb25cIjtcblxuICAgICAgICAvLyBJbnN0YWxsIGNhbGxiYWNrXG4gICAgICAgIG92ZXJ3cml0dGVuID0gd2luZG93W2NhbGxiYWNrTmFtZV07XG4gICAgICAgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuICAgICAgICBqcVhIUi5hbHdheXMoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgLy8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG4gICAgICAgICAgaWYgKG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGpRdWVyeSh3aW5kb3cpLnJlbW92ZVByb3AoY2FsbGJhY2tOYW1lKTtcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBvdmVyd3JpdHRlbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTYXZlIGJhY2sgYXMgZnJlZVxuICAgICAgICAgIGlmIChzW2NhbGxiYWNrTmFtZV0pIHtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG4gICAgICAgICAgICBzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2VcbiAgICAgICAgICAgIG9sZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrTmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG4gICAgICAgICAgaWYgKHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24ob3ZlcndyaXR0ZW4pKSB7XG4gICAgICAgICAgICBvdmVyd3JpdHRlbihyZXNwb25zZUNvbnRhaW5lclswXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRGVsZWdhdGUgdG8gc2NyaXB0XG4gICAgICAgIHJldHVybiBcInNjcmlwdFwiO1xuICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4gICAgLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuICAgIC8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbiAgICAvLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbiAgICAvLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4gICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuICAgIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpLmJvZHk7XG4gICAgICBib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcbiAgICAgIHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xuICAgIH0pKCk7XG5cblxuICAgIC8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuICAgIC8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbiAgICAvLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuICAgIC8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbiAgICBqUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24gKGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnRleHQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuICAgICAgaWYgKCFjb250ZXh0KSB7XG5cbiAgICAgICAgLy8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG4gICAgICAgIC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmIChzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCkge1xuICAgICAgICAgIGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIik7XG5cbiAgICAgICAgICAvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcbiAgICAgICAgICAvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuICAgICAgICAgIC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG4gICAgICAgICAgYmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImJhc2VcIik7XG4gICAgICAgICAgYmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcbiAgICAgICAgICBjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoYmFzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dCA9IGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyhkYXRhKTtcbiAgICAgIHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cbiAgICAgIC8vIFNpbmdsZSB0YWdcbiAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgcmV0dXJuIFtjb250ZXh0LmNyZWF0ZUVsZW1lbnQocGFyc2VkWzFdKV07XG4gICAgICB9XG5cbiAgICAgIHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoW2RhdGFdLCBjb250ZXh0LCBzY3JpcHRzKTtcblxuICAgICAgaWYgKHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAgICAgalF1ZXJ5KHNjcmlwdHMpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKFtdLCBwYXJzZWQuY2hpbGROb2Rlcyk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICAgICAqL1xuICAgIGpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24gKHVybCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIG9mZiA9IHVybC5pbmRleE9mKFwiIFwiKTtcblxuICAgICAgaWYgKG9mZiA+IC0xKSB7XG4gICAgICAgIHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSh1cmwuc2xpY2Uob2ZmKSk7XG4gICAgICAgIHVybCA9IHVybC5zbGljZSgwLCBvZmYpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCdzIGEgZnVuY3Rpb25cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHBhcmFtcykpIHtcblxuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgcGFyYW1zID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdHlwZSA9IFwiUE9TVFwiO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuICAgICAgaWYgKHNlbGYubGVuZ3RoID4gMCkge1xuICAgICAgICBqUXVlcnkuYWpheCh7XG4gICAgICAgICAgdXJsOiB1cmwsXG5cbiAgICAgICAgICAvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgIC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuICAgICAgICAgIC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuICAgICAgICAgIHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcbiAgICAgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXG4gICAgICAgICAgZGF0YTogcGFyYW1zXG4gICAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKHJlc3BvbnNlVGV4dCkge1xuXG4gICAgICAgICAgLy8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG4gICAgICAgICAgcmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgICBzZWxmLmh0bWwoc2VsZWN0b3IgP1xuXG4gICAgICAgICAgICAvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcbiAgICAgICAgICAgIC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuICAgICAgICAgICAgalF1ZXJ5KFwiPGRpdj5cIikuYXBwZW5kKGpRdWVyeS5wYXJzZUhUTUwocmVzcG9uc2VUZXh0KSkuZmluZChzZWxlY3RvcikgOlxuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuICAgICAgICAgICAgcmVzcG9uc2VUZXh0KTtcblxuICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuICAgICAgICAgIC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cbiAgICAgICAgICAvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG4gICAgICAgIH0pLmFsd2F5cyhjYWxsYmFjayAmJiBmdW5jdGlvbiAoanFYSFIsIHN0YXR1cykge1xuICAgICAgICAgIHNlbGYuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCByZXNwb25zZSB8fCBbanFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5cblxuXG4gICAgalF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICByZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuICAgICAgfSkubGVuZ3RoO1xuICAgIH07XG5cblxuXG5cbiAgICBqUXVlcnkub2Zmc2V0ID0ge1xuICAgICAgc2V0T2Zmc2V0OiBmdW5jdGlvbiAoZWxlbSwgb3B0aW9ucywgaSkge1xuICAgICAgICB2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuICAgICAgICAgIHBvc2l0aW9uID0galF1ZXJ5LmNzcyhlbGVtLCBcInBvc2l0aW9uXCIpLFxuICAgICAgICAgIGN1ckVsZW0gPSBqUXVlcnkoZWxlbSksXG4gICAgICAgICAgcHJvcHMgPSB7fTtcblxuICAgICAgICAvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuICAgICAgICBjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKGVsZW0sIFwidG9wXCIpO1xuICAgICAgICBjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyhlbGVtLCBcImxlZnRcIik7XG4gICAgICAgIGNhbGN1bGF0ZVBvc2l0aW9uID0gKHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIikgJiZcbiAgICAgICAgICAoY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCkuaW5kZXhPZihcImF1dG9cIikgPiAtMTtcblxuICAgICAgICAvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuICAgICAgICAvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcbiAgICAgICAgaWYgKGNhbGN1bGF0ZVBvc2l0aW9uKSB7XG4gICAgICAgICAgY3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG4gICAgICAgICAgY3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuICAgICAgICAgIGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyVG9wID0gcGFyc2VGbG9hdChjdXJDU1NUb3ApIHx8IDA7XG4gICAgICAgICAgY3VyTGVmdCA9IHBhcnNlRmxvYXQoY3VyQ1NTTGVmdCkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG5cbiAgICAgICAgICAvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcbiAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jYWxsKGVsZW0sIGksIGpRdWVyeS5leHRlbmQoe30sIGN1ck9mZnNldCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudG9wICE9IG51bGwpIHtcbiAgICAgICAgICBwcm9wcy50b3AgPSAob3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wKSArIGN1clRvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICBwcm9wcy5sZWZ0ID0gKG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0KSArIGN1ckxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXCJ1c2luZ1wiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBvcHRpb25zLnVzaW5nLmNhbGwoZWxlbSwgcHJvcHMpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyRWxlbS5jc3MocHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuXG4gICAgICAvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cbiAgICAgIG9mZnNldDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0aGlzIDpcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICBqUXVlcnkub2Zmc2V0LnNldE9mZnNldCh0aGlzLCBvcHRpb25zLCBpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3QsIHdpbixcbiAgICAgICAgICBlbGVtID0gdGhpc1swXTtcblxuICAgICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gICAgICAgIC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcbiAgICAgICAgLy8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG4gICAgICAgIGlmICghZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuICAgICAgICByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgd2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG4gICAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuICAgICAgLy8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICBwb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXNbMF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcbiAgICAgICAgICBlbGVtID0gdGhpc1swXSxcbiAgICAgICAgICBwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG4gICAgICAgIC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG4gICAgICAgIGlmIChqUXVlcnkuY3NzKGVsZW0sIFwicG9zaXRpb25cIikgPT09IFwiZml4ZWRcIikge1xuXG4gICAgICAgICAgLy8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAgICAgIG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG4gICAgICAgICAgLy8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcbiAgICAgICAgICAvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuICAgICAgICAgIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgIHdoaWxlIChvZmZzZXRQYXJlbnQgJiZcbiAgICAgICAgICAgIChvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCkgJiZcbiAgICAgICAgICAgIGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIpID09PSBcInN0YXRpY1wiKSB7XG5cbiAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEpIHtcblxuICAgICAgICAgICAgLy8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSBqUXVlcnkob2Zmc2V0UGFyZW50KS5vZmZzZXQoKTtcbiAgICAgICAgICAgIHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUpLFxuICAgICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlKVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgLy8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG4gICAgICAvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcbiAgICAgIC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcbiAgICAgIC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcbiAgICAgIC8vXG4gICAgICAvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcbiAgICAgIC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG4gICAgICBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cbiAgICAgICAgICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIpID09PSBcInN0YXRpY1wiKSB7XG4gICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xuICAgIGpRdWVyeS5lYWNoKHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiAobWV0aG9kLCBwcm9wKSB7XG4gICAgICB2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG4gICAgICBqUXVlcnkuZm5bbWV0aG9kXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAoZWxlbSwgbWV0aG9kLCB2YWwpIHtcblxuICAgICAgICAgIC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuICAgICAgICAgIHZhciB3aW47XG4gICAgICAgICAgaWYgKGlzV2luZG93KGVsZW0pKSB7XG4gICAgICAgICAgICB3aW4gPSBlbGVtO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgd2luID0gZWxlbS5kZWZhdWx0VmlldztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW4gPyB3aW5bcHJvcF0gOiBlbGVtW21ldGhvZF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdpbikge1xuICAgICAgICAgICAgd2luLnNjcm9sbFRvKFxuICAgICAgICAgICAgICAhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICB0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbVttZXRob2RdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbiAgICAvLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuICAgIC8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuICAgIC8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4gICAgLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbiAgICAvLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxuICAgIGpRdWVyeS5lYWNoKFtcInRvcFwiLCBcImxlZnRcIl0sIGZ1bmN0aW9uIChfaSwgcHJvcCkge1xuICAgICAgalF1ZXJ5LmNzc0hvb2tzW3Byb3BdID0gYWRkR2V0SG9va0lmKHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcbiAgICAgICAgZnVuY3Rpb24gKGVsZW0sIGNvbXB1dGVkKSB7XG4gICAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBjb21wdXRlZCA9IGN1ckNTUyhlbGVtLCBwcm9wKTtcblxuICAgICAgICAgICAgLy8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG4gICAgICAgICAgICByZXR1cm4gcm51bW5vbnB4LnRlc3QoY29tcHV0ZWQpID9cbiAgICAgICAgICAgICAgalF1ZXJ5KGVsZW0pLnBvc2l0aW9uKClbcHJvcF0gKyBcInB4XCIgOlxuICAgICAgICAgICAgICBjb21wdXRlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG5cblxuICAgIC8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xuICAgIGpRdWVyeS5lYWNoKHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uIChuYW1lLCB0eXBlKSB7XG4gICAgICBqUXVlcnkuZWFjaCh7XG4gICAgICAgIHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsXG4gICAgICAgIGNvbnRlbnQ6IHR5cGUsXG4gICAgICAgIFwiXCI6IFwib3V0ZXJcIiArIG5hbWVcbiAgICAgIH0sIGZ1bmN0aW9uIChkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lKSB7XG5cbiAgICAgICAgLy8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG4gICAgICAgIGpRdWVyeS5mbltmdW5jTmFtZV0gPSBmdW5jdGlvbiAobWFyZ2luLCB2YWx1ZSkge1xuICAgICAgICAgIHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmIChkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIpLFxuICAgICAgICAgICAgZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiKTtcblxuICAgICAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24gKGVsZW0sIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZG9jO1xuXG4gICAgICAgICAgICBpZiAoaXNXaW5kb3coZWxlbSkpIHtcblxuICAgICAgICAgICAgICAvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuICAgICAgICAgICAgICByZXR1cm4gZnVuY05hbWUuaW5kZXhPZihcIm91dGVyXCIpID09PSAwID9cbiAgICAgICAgICAgICAgICBlbGVtW1wiaW5uZXJcIiArIG5hbWVdIDpcbiAgICAgICAgICAgICAgICBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiICsgbmFtZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcbiAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgICAgIGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgICAgICAgIC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcbiAgICAgICAgICAgICAgLy8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBlbGVtLmJvZHlbXCJzY3JvbGxcIiArIG5hbWVdLCBkb2NbXCJzY3JvbGxcIiArIG5hbWVdLFxuICAgICAgICAgICAgICAgIGVsZW0uYm9keVtcIm9mZnNldFwiICsgbmFtZV0sIGRvY1tcIm9mZnNldFwiICsgbmFtZV0sXG4gICAgICAgICAgICAgICAgZG9jW1wiY2xpZW50XCIgKyBuYW1lXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cbiAgICAgICAgICAgICAgLy8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuICAgICAgICAgICAgICBqUXVlcnkuY3NzKGVsZW0sIHR5cGUsIGV4dHJhKSA6XG5cbiAgICAgICAgICAgICAgLy8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhKTtcbiAgICAgICAgICB9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KTtcblxuXG4gICAgalF1ZXJ5LmVhY2goW1xuICAgICAgXCJhamF4U3RhcnRcIixcbiAgICAgIFwiYWpheFN0b3BcIixcbiAgICAgIFwiYWpheENvbXBsZXRlXCIsXG4gICAgICBcImFqYXhFcnJvclwiLFxuICAgICAgXCJhamF4U3VjY2Vzc1wiLFxuICAgICAgXCJhamF4U2VuZFwiXG4gICAgXSwgZnVuY3Rpb24gKF9pLCB0eXBlKSB7XG4gICAgICBqUXVlcnkuZm5bdHlwZV0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub24odHlwZSwgZm4pO1xuICAgICAgfTtcbiAgICB9KTtcblxuXG5cblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuXG4gICAgICBiaW5kOiBmdW5jdGlvbiAodHlwZXMsIGRhdGEsIGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKHR5cGVzLCBudWxsLCBkYXRhLCBmbik7XG4gICAgICB9LFxuICAgICAgdW5iaW5kOiBmdW5jdGlvbiAodHlwZXMsIGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZih0eXBlcywgbnVsbCwgZm4pO1xuICAgICAgfSxcblxuICAgICAgZGVsZWdhdGU6IGZ1bmN0aW9uIChzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pO1xuICAgICAgfSxcbiAgICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uIChzZWxlY3RvciwgdHlwZXMsIGZuKSB7XG5cbiAgICAgICAgLy8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgdGhpcy5vZmYoc2VsZWN0b3IsIFwiKipcIikgOlxuICAgICAgICAgIHRoaXMub2ZmKHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuKTtcbiAgICAgIH0sXG5cbiAgICAgIGhvdmVyOiBmdW5jdGlvbiAoZm5PdmVyLCBmbk91dCkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgIC5vbihcIm1vdXNlZW50ZXJcIiwgZm5PdmVyKVxuICAgICAgICAgIC5vbihcIm1vdXNlbGVhdmVcIiwgZm5PdXQgfHwgZm5PdmVyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5lYWNoKFxuICAgICAgKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuICAgICAgICBcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcbiAgICAgICAgXCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIpLnNwbGl0KFwiIFwiKSxcbiAgICAgIGZ1bmN0aW9uIChfaSwgbmFtZSkge1xuXG4gICAgICAgIC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG4gICAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICB0aGlzLm9uKG5hbWUsIG51bGwsIGRhdGEsIGZuKSA6XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmFtZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgKTtcblxuXG5cblxuICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuICAgIC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuICAgIC8vIFJlcXVpcmUgdGhhdCB0aGUgXCJ3aGl0ZXNwYWNlIHJ1blwiIHN0YXJ0cyBmcm9tIGEgbm9uLXdoaXRlc3BhY2VcbiAgICAvLyB0byBhdm9pZCBPKE5eMikgYmVoYXZpb3Igd2hlbiB0aGUgZW5naW5lIHdvdWxkIHRyeSBtYXRjaGluZyBcIlxccyskXCIgYXQgZWFjaCBzcGFjZSBwb3NpdGlvbi5cbiAgICB2YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3woW15cXHNcXHVGRUZGXFx4QTBdKVtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuICAgIC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuICAgIC8vIGFyZ3VtZW50cy5cbiAgICAvLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4gICAgLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG4gICAgalF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24gKGZuLCBjb250ZXh0KSB7XG4gICAgICB2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRtcCA9IGZuW2NvbnRleHRdO1xuICAgICAgICBjb250ZXh0ID0gZm47XG4gICAgICAgIGZuID0gdG1wO1xuICAgICAgfVxuXG4gICAgICAvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuICAgICAgLy8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gU2ltdWxhdGVkIGJpbmRcbiAgICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICBwcm94eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcbiAgICAgIHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG4gICAgICByZXR1cm4gcHJveHk7XG4gICAgfTtcblxuICAgIGpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiAoaG9sZCkge1xuICAgICAgaWYgKGhvbGQpIHtcbiAgICAgICAgalF1ZXJ5LnJlYWR5V2FpdCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgalF1ZXJ5LnJlYWR5KHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgalF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgIGpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xuICAgIGpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xuICAgIGpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBqUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbiAgICBqUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgIGpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG4gICAgalF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG4gICAgalF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgICAgLy8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cbiAgICAgIC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcbiAgICAgIC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG4gICAgICB2YXIgdHlwZSA9IGpRdWVyeS50eXBlKG9iaik7XG4gICAgICByZXR1cm4gKHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIikgJiZcblxuICAgICAgICAvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcbiAgICAgICAgLy8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuICAgICAgICAvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cbiAgICAgICAgIWlzTmFOKG9iaiAtIHBhcnNlRmxvYXQob2JqKSk7XG4gICAgfTtcblxuICAgIGpRdWVyeS50cmltID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0ID09IG51bGwgP1xuICAgICAgICBcIlwiIDpcbiAgICAgICAgKHRleHQgKyBcIlwiKS5yZXBsYWNlKHJ0cmltLCBcIiQxXCIpO1xuICAgIH07XG5cblxuXG4gICAgLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4gICAgLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuICAgIC8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuICAgIC8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbiAgICAvLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2VcbiAgICAvLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbiAgICAvLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbiAgICAvLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuICAgIC8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbiAgICAvLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgZGVmaW5lKFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnk7XG4gICAgICB9KTtcbiAgICB9XG5cblxuXG5cbiAgICB2YXJcblxuICAgICAgLy8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgICBfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuICAgICAgLy8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICAgIF8kID0gd2luZG93LiQ7XG5cbiAgICBqUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uIChkZWVwKSB7XG4gICAgICBpZiAod2luZG93LiQgPT09IGpRdWVyeSkge1xuICAgICAgICB3aW5kb3cuJCA9IF8kO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkpIHtcbiAgICAgICAgd2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqUXVlcnk7XG4gICAgfTtcblxuICAgIC8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4gICAgLy8gKHRyYWMtNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1NylcbiAgICAvLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICh0cmFjLTEzNTY2KVxuICAgIGlmICh0eXBlb2Ygbm9HbG9iYWwgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbiAgICB9XG5cblxuXG5cbiAgICByZXR1cm4galF1ZXJ5O1xuICB9KTtcbn0pKCk7XG4iLCIvKiFcbiAqIGZhbmN5Qm94IC0galF1ZXJ5IFBsdWdpblxuICogdmVyc2lvbjogMi4xLjUgKEZyaSwgMTQgSnVuIDIwMTMpXG4gKiByZXF1aXJlcyBqUXVlcnkgdjEuNiBvciBsYXRlclxuICpcbiAqIEV4YW1wbGVzIGF0IGh0dHA6Ly9mYW5jeWFwcHMuY29tL2ZhbmN5Ym94L1xuICogTGljZW5zZTogd3d3LmZhbmN5YXBwcy5jb20vZmFuY3lib3gvI2xpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMiBKYW5pcyBTa2FybmVsaXMgLSBqYW5pc0BmYW5jeWFwcHMuY29tXG4gKlxuICovXG4oZnVuY3Rpb24gKCkge1xuICAoZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsICQsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIEggPSAkKFwiaHRtbFwiKSxcbiAgICAgIFcgPSAkKHdpbmRvdyksXG4gICAgICBEID0gJChkb2N1bWVudCksXG4gICAgICBGID0gJC5mYW5jeWJveCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgRi5vcGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9LFxuICAgICAgSUUgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9tc2llL2kpLFxuICAgICAgZGlkVXBkYXRlID0gbnVsbCxcbiAgICAgIGlzVG91Y2ggPSBkb2N1bWVudC5jcmVhdGVUb3VjaCAhPT0gdW5kZWZpbmVkLFxuXG4gICAgICBpc1F1ZXJ5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eSAmJiBvYmogaW5zdGFuY2VvZiAkO1xuICAgICAgfSxcbiAgICAgIGlzU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyICYmICQudHlwZShzdHIpID09PSBcInN0cmluZ1wiO1xuICAgICAgfSxcbiAgICAgIGlzUGVyY2VudGFnZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHN0cikgJiYgc3RyLmluZGV4T2YoJyUnKSA+IDA7XG4gICAgICB9LFxuICAgICAgaXNTY3JvbGxhYmxlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiAoZWwgJiYgIShlbC5zdHlsZS5vdmVyZmxvdyAmJiBlbC5zdHlsZS5vdmVyZmxvdyA9PT0gJ2hpZGRlbicpICYmICgoZWwuY2xpZW50V2lkdGggJiYgZWwuc2Nyb2xsV2lkdGggPiBlbC5jbGllbnRXaWR0aCkgfHwgKGVsLmNsaWVudEhlaWdodCAmJiBlbC5zY3JvbGxIZWlnaHQgPiBlbC5jbGllbnRIZWlnaHQpKSk7XG4gICAgICB9LFxuICAgICAgZ2V0U2NhbGFyID0gZnVuY3Rpb24gKG9yaWcsIGRpbSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludChvcmlnLCAxMCkgfHwgMDtcblxuICAgICAgICBpZiAoZGltICYmIGlzUGVyY2VudGFnZShvcmlnKSkge1xuICAgICAgICAgIHZhbHVlID0gRi5nZXRWaWV3cG9ydCgpW2RpbV0gLyAxMDAgKiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwodmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGdldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBkaW0pIHtcbiAgICAgICAgcmV0dXJuIGdldFNjYWxhcih2YWx1ZSwgZGltKSArICdweCc7XG4gICAgICB9O1xuXG4gICAgJC5leHRlbmQoRiwge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBmYW5jeUJveFxuICAgICAgdmVyc2lvbjogJzIuMS41JyxcblxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgcGFkZGluZzogMTUsXG4gICAgICAgIG1hcmdpbjogMjAsXG5cbiAgICAgICAgd2lkdGg6IDgwMCxcbiAgICAgICAgaGVpZ2h0OiA2MDAsXG4gICAgICAgIG1pbldpZHRoOiAxMDAsXG4gICAgICAgIG1pbkhlaWdodDogMTAwLFxuICAgICAgICBtYXhXaWR0aDogOTk5OSxcbiAgICAgICAgbWF4SGVpZ2h0OiA5OTk5LFxuICAgICAgICBwaXhlbFJhdGlvOiAxLCAvLyBTZXQgdG8gMiBmb3IgcmV0aW5hIGRpc3BsYXkgc3VwcG9ydFxuXG4gICAgICAgIGF1dG9TaXplOiB0cnVlLFxuICAgICAgICBhdXRvSGVpZ2h0OiBmYWxzZSxcbiAgICAgICAgYXV0b1dpZHRoOiBmYWxzZSxcblxuICAgICAgICBhdXRvUmVzaXplOiB0cnVlLFxuICAgICAgICBhdXRvQ2VudGVyOiAhaXNUb3VjaCxcbiAgICAgICAgZml0VG9WaWV3OiB0cnVlLFxuICAgICAgICBhc3BlY3RSYXRpbzogZmFsc2UsXG4gICAgICAgIHRvcFJhdGlvOiAwLjUsXG4gICAgICAgIGxlZnRSYXRpbzogMC41LFxuXG4gICAgICAgIHNjcm9sbGluZzogJ2F1dG8nLCAvLyAnYXV0bycsICd5ZXMnIG9yICdubydcbiAgICAgICAgd3JhcENTUzogJycsXG5cbiAgICAgICAgYXJyb3dzOiB0cnVlLFxuICAgICAgICBjbG9zZUJ0bjogdHJ1ZSxcbiAgICAgICAgY2xvc2VDbGljazogZmFsc2UsXG4gICAgICAgIG5leHRDbGljazogZmFsc2UsXG4gICAgICAgIG1vdXNlV2hlZWw6IHRydWUsXG4gICAgICAgIGF1dG9QbGF5OiBmYWxzZSxcbiAgICAgICAgcGxheVNwZWVkOiAzMDAwLFxuICAgICAgICBwcmVsb2FkOiAzLFxuICAgICAgICBtb2RhbDogZmFsc2UsXG4gICAgICAgIGxvb3A6IHRydWUsXG5cbiAgICAgICAgYWpheDoge1xuICAgICAgICAgIGRhdGFUeXBlOiAnaHRtbCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnWC1mYW5jeUJveCc6IHRydWUgfVxuICAgICAgICB9LFxuICAgICAgICBpZnJhbWU6IHtcbiAgICAgICAgICBzY3JvbGxpbmc6ICdhdXRvJyxcbiAgICAgICAgICBwcmVsb2FkOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHN3Zjoge1xuICAgICAgICAgIHdtb2RlOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgIGFsbG93ZnVsbHNjcmVlbjogJ3RydWUnLFxuICAgICAgICAgIGFsbG93c2NyaXB0YWNjZXNzOiAnYWx3YXlzJ1xuICAgICAgICB9LFxuXG4gICAgICAgIGtleXM6IHtcbiAgICAgICAgICBuZXh0OiB7XG4gICAgICAgICAgICAxMzogJ2xlZnQnLCAvLyBlbnRlclxuICAgICAgICAgICAgMzQ6ICd1cCcsICAgLy8gcGFnZSBkb3duXG4gICAgICAgICAgICAzOTogJ2xlZnQnLCAvLyByaWdodCBhcnJvd1xuICAgICAgICAgICAgNDA6ICd1cCcgICAgLy8gZG93biBhcnJvd1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJldjoge1xuICAgICAgICAgICAgODogJ3JpZ2h0JywgIC8vIGJhY2tzcGFjZVxuICAgICAgICAgICAgMzM6ICdkb3duJywgICAvLyBwYWdlIHVwXG4gICAgICAgICAgICAzNzogJ3JpZ2h0JywgIC8vIGxlZnQgYXJyb3dcbiAgICAgICAgICAgIDM4OiAnZG93bicgICAgLy8gdXAgYXJyb3dcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsb3NlOiBbMjddLCAvLyBlc2NhcGUga2V5XG4gICAgICAgICAgcGxheTogWzMyXSwgLy8gc3BhY2UgLSBzdGFydC9zdG9wIHNsaWRlc2hvd1xuICAgICAgICAgIHRvZ2dsZTogWzcwXSAgLy8gbGV0dGVyIFwiZlwiIC0gdG9nZ2xlIGZ1bGxzY3JlZW5cbiAgICAgICAgfSxcblxuICAgICAgICBkaXJlY3Rpb246IHtcbiAgICAgICAgICBuZXh0OiAnbGVmdCcsXG4gICAgICAgICAgcHJldjogJ3JpZ2h0J1xuICAgICAgICB9LFxuXG4gICAgICAgIHNjcm9sbE91dHNpZGU6IHRydWUsXG5cbiAgICAgICAgLy8gT3ZlcnJpZGUgc29tZSBwcm9wZXJ0aWVzXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICBocmVmOiBudWxsLFxuICAgICAgICBjb250ZW50OiBudWxsLFxuICAgICAgICB0aXRsZTogbnVsbCxcblxuICAgICAgICAvLyBIVE1MIHRlbXBsYXRlc1xuICAgICAgICB0cGw6IHtcbiAgICAgICAgICB3cmFwOiAnPGRpdiBjbGFzcz1cImZhbmN5Ym94LXdyYXBcIiB0YWJJbmRleD1cIi0xXCI+PGRpdiBjbGFzcz1cImZhbmN5Ym94LXNraW5cIj48ZGl2IGNsYXNzPVwiZmFuY3lib3gtb3V0ZXJcIj48ZGl2IGNsYXNzPVwiZmFuY3lib3gtaW5uZXJcIj48L2Rpdj48L2Rpdj48L2Rpdj48L2Rpdj4nLFxuICAgICAgICAgIGltYWdlOiAnPGltZyBjbGFzcz1cImZhbmN5Ym94LWltYWdlXCIgc3JjPVwie2hyZWZ9XCIgYWx0PVwiXCIgLz4nLFxuICAgICAgICAgIGlmcmFtZTogJzxpZnJhbWUgaWQ9XCJmYW5jeWJveC1mcmFtZXtybmR9XCIgbmFtZT1cImZhbmN5Ym94LWZyYW1le3JuZH1cIiBjbGFzcz1cImZhbmN5Ym94LWlmcmFtZVwiIGZyYW1lYm9yZGVyPVwiMFwiIHZzcGFjZT1cIjBcIiBoc3BhY2U9XCIwXCIgd2Via2l0QWxsb3dGdWxsU2NyZWVuIG1vemFsbG93ZnVsbHNjcmVlbiBhbGxvd0Z1bGxTY3JlZW4nICsgKElFID8gJyBhbGxvd3RyYW5zcGFyZW5jeT1cInRydWVcIicgOiAnJykgKyAnPjwvaWZyYW1lPicsXG4gICAgICAgICAgZXJyb3I6ICc8cCBjbGFzcz1cImZhbmN5Ym94LWVycm9yXCI+VGhlIHJlcXVlc3RlZCBjb250ZW50IGNhbm5vdCBiZSBsb2FkZWQuPGJyLz5QbGVhc2UgdHJ5IGFnYWluIGxhdGVyLjwvcD4nLFxuICAgICAgICAgIGNsb3NlQnRuOiAnPGEgdGl0bGU9XCJDbG9zZVwiIGNsYXNzPVwiZmFuY3lib3gtaXRlbSBmYW5jeWJveC1jbG9zZVwiIGhyZWY9XCJqYXZhc2NyaXB0OjtcIj48L2E+JyxcbiAgICAgICAgICBuZXh0OiAnPGEgdGl0bGU9XCJOZXh0XCIgY2xhc3M9XCJmYW5jeWJveC1uYXYgZmFuY3lib3gtbmV4dFwiIGhyZWY9XCJqYXZhc2NyaXB0OjtcIj48c3Bhbj48L3NwYW4+PC9hPicsXG4gICAgICAgICAgcHJldjogJzxhIHRpdGxlPVwiUHJldmlvdXNcIiBjbGFzcz1cImZhbmN5Ym94LW5hdiBmYW5jeWJveC1wcmV2XCIgaHJlZj1cImphdmFzY3JpcHQ6O1wiPjxzcGFuPjwvc3Bhbj48L2E+JyxcbiAgICAgICAgICBsb2FkaW5nOiAnPGRpdiBpZD1cImZhbmN5Ym94LWxvYWRpbmdcIj48ZGl2PjwvZGl2PjwvZGl2PidcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBQcm9wZXJ0aWVzIGZvciBlYWNoIGFuaW1hdGlvbiB0eXBlXG4gICAgICAgIC8vIE9wZW5pbmcgZmFuY3lCb3hcbiAgICAgICAgb3BlbkVmZmVjdDogJ2ZhZGUnLCAvLyAnZWxhc3RpYycsICdmYWRlJyBvciAnbm9uZSdcbiAgICAgICAgb3BlblNwZWVkOiAyNTAsXG4gICAgICAgIG9wZW5FYXNpbmc6ICdzd2luZycsXG4gICAgICAgIG9wZW5PcGFjaXR5OiB0cnVlLFxuICAgICAgICBvcGVuTWV0aG9kOiAnem9vbUluJyxcblxuICAgICAgICAvLyBDbG9zaW5nIGZhbmN5Qm94XG4gICAgICAgIGNsb3NlRWZmZWN0OiAnZmFkZScsIC8vICdlbGFzdGljJywgJ2ZhZGUnIG9yICdub25lJ1xuICAgICAgICBjbG9zZVNwZWVkOiAyNTAsXG4gICAgICAgIGNsb3NlRWFzaW5nOiAnc3dpbmcnLFxuICAgICAgICBjbG9zZU9wYWNpdHk6IHRydWUsXG4gICAgICAgIGNsb3NlTWV0aG9kOiAnem9vbU91dCcsXG5cbiAgICAgICAgLy8gQ2hhbmdpbmcgbmV4dCBnYWxsZXJ5IGl0ZW1cbiAgICAgICAgbmV4dEVmZmVjdDogJ2VsYXN0aWMnLCAvLyAnZWxhc3RpYycsICdmYWRlJyBvciAnbm9uZSdcbiAgICAgICAgbmV4dFNwZWVkOiAyNTAsXG4gICAgICAgIG5leHRFYXNpbmc6ICdzd2luZycsXG4gICAgICAgIG5leHRNZXRob2Q6ICdjaGFuZ2VJbicsXG5cbiAgICAgICAgLy8gQ2hhbmdpbmcgcHJldmlvdXMgZ2FsbGVyeSBpdGVtXG4gICAgICAgIHByZXZFZmZlY3Q6ICdlbGFzdGljJywgLy8gJ2VsYXN0aWMnLCAnZmFkZScgb3IgJ25vbmUnXG4gICAgICAgIHByZXZTcGVlZDogMjUwLFxuICAgICAgICBwcmV2RWFzaW5nOiAnc3dpbmcnLFxuICAgICAgICBwcmV2TWV0aG9kOiAnY2hhbmdlT3V0JyxcblxuICAgICAgICAvLyBFbmFibGUgZGVmYXVsdCBoZWxwZXJzXG4gICAgICAgIGhlbHBlcnM6IHtcbiAgICAgICAgICBvdmVybGF5OiB0cnVlLFxuICAgICAgICAgIHRpdGxlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2FsbGJhY2tzXG4gICAgICAgIG9uQ2FuY2VsOiAkLm5vb3AsIC8vIElmIGNhbmNlbGluZ1xuICAgICAgICBiZWZvcmVMb2FkOiAkLm5vb3AsIC8vIEJlZm9yZSBsb2FkaW5nXG4gICAgICAgIGFmdGVyTG9hZDogJC5ub29wLCAvLyBBZnRlciBsb2FkaW5nXG4gICAgICAgIGJlZm9yZVNob3c6ICQubm9vcCwgLy8gQmVmb3JlIGNoYW5naW5nIGluIGN1cnJlbnQgaXRlbVxuICAgICAgICBhZnRlclNob3c6ICQubm9vcCwgLy8gQWZ0ZXIgb3BlbmluZ1xuICAgICAgICBiZWZvcmVDaGFuZ2U6ICQubm9vcCwgLy8gQmVmb3JlIGNoYW5naW5nIGdhbGxlcnkgaXRlbVxuICAgICAgICBiZWZvcmVDbG9zZTogJC5ub29wLCAvLyBCZWZvcmUgY2xvc2luZ1xuICAgICAgICBhZnRlckNsb3NlOiAkLm5vb3AgIC8vIEFmdGVyIGNsb3NpbmdcbiAgICAgIH0sXG5cbiAgICAgIC8vQ3VycmVudCBzdGF0ZVxuICAgICAgZ3JvdXA6IHt9LCAvLyBTZWxlY3RlZCBncm91cFxuICAgICAgb3B0czoge30sIC8vIEdyb3VwIG9wdGlvbnNcbiAgICAgIHByZXZpb3VzOiBudWxsLCAgLy8gUHJldmlvdXMgZWxlbWVudFxuICAgICAgY29taW5nOiBudWxsLCAgLy8gRWxlbWVudCBiZWluZyBsb2FkZWRcbiAgICAgIGN1cnJlbnQ6IG51bGwsICAvLyBDdXJyZW50bHkgbG9hZGVkIGVsZW1lbnRcbiAgICAgIGlzQWN0aXZlOiBmYWxzZSwgLy8gSXMgYWN0aXZhdGVkXG4gICAgICBpc09wZW46IGZhbHNlLCAvLyBJcyBjdXJyZW50bHkgb3BlblxuICAgICAgaXNPcGVuZWQ6IGZhbHNlLCAvLyBIYXZlIGJlZW4gZnVsbHkgb3BlbmVkIGF0IGxlYXN0IG9uY2VcblxuICAgICAgd3JhcDogbnVsbCxcbiAgICAgIHNraW46IG51bGwsXG4gICAgICBvdXRlcjogbnVsbCxcbiAgICAgIGlubmVyOiBudWxsLFxuXG4gICAgICBwbGF5ZXI6IHtcbiAgICAgICAgdGltZXI6IG51bGwsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgLy8gTG9hZGVyc1xuICAgICAgYWpheExvYWQ6IG51bGwsXG4gICAgICBpbWdQcmVsb2FkOiBudWxsLFxuXG4gICAgICAvLyBTb21lIGNvbGxlY3Rpb25zXG4gICAgICB0cmFuc2l0aW9uczoge30sXG4gICAgICBoZWxwZXJzOiB7fSxcblxuICAgICAgLypcbiAgICAgICAqXHRTdGF0aWMgbWV0aG9kc1xuICAgICAgICovXG5cbiAgICAgIG9wZW46IGZ1bmN0aW9uIChncm91cCwgb3B0cykge1xuICAgICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEkLmlzUGxhaW5PYmplY3Qob3B0cykpIHtcbiAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbG9zZSBpZiBhbHJlYWR5IGFjdGl2ZVxuICAgICAgICBpZiAoZmFsc2UgPT09IEYuY2xvc2UodHJ1ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3JtYWxpemUgZ3JvdXBcbiAgICAgICAgaWYgKCEkLmlzQXJyYXkoZ3JvdXApKSB7XG4gICAgICAgICAgZ3JvdXAgPSBpc1F1ZXJ5KGdyb3VwKSA/ICQoZ3JvdXApLmdldCgpIDogW2dyb3VwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY2hlY2sgaWYgdGhlIHR5cGUgb2YgZWFjaCBlbGVtZW50IGlzIGBvYmplY3RgIGFuZCBzZXQgY29udGVudCB0eXBlIChpbWFnZSwgYWpheCwgZXRjKVxuICAgICAgICAkLmVhY2goZ3JvdXAsIGZ1bmN0aW9uIChpLCBlbGVtZW50KSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHt9LFxuICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICByZXosXG4gICAgICAgICAgICBocmVmUGFydHMsXG4gICAgICAgICAgICBzZWxlY3RvcjtcblxuICAgICAgICAgIGlmICgkLnR5cGUoZWxlbWVudCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGlzIERPTSBlbGVtZW50XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICBlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzUXVlcnkoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgb2JqID0ge1xuICAgICAgICAgICAgICAgIGhyZWY6IGVsZW1lbnQuZGF0YSgnZmFuY3lib3gtaHJlZicpIHx8IGVsZW1lbnQuYXR0cignaHJlZicpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAkKCc8ZGl2Lz4nKS50ZXh0KGVsZW1lbnQuZGF0YSgnZmFuY3lib3gtdGl0bGUnKSB8fCBlbGVtZW50LmF0dHIoJ3RpdGxlJykgfHwgJycpLmh0bWwoKSxcbiAgICAgICAgICAgICAgICBpc0RvbTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKCQubWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvYmosIGVsZW1lbnQubWV0YWRhdGEoKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2JqID0gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBocmVmID0gb3B0cy5ocmVmIHx8IG9iai5ocmVmIHx8IChpc1N0cmluZyhlbGVtZW50KSA/IGVsZW1lbnQgOiBudWxsKTtcbiAgICAgICAgICB0aXRsZSA9IG9wdHMudGl0bGUgIT09IHVuZGVmaW5lZCA/IG9wdHMudGl0bGUgOiBvYmoudGl0bGUgfHwgJyc7XG5cbiAgICAgICAgICBjb250ZW50ID0gb3B0cy5jb250ZW50IHx8IG9iai5jb250ZW50O1xuICAgICAgICAgIHR5cGUgPSBjb250ZW50ID8gJ2h0bWwnIDogKG9wdHMudHlwZSB8fCBvYmoudHlwZSk7XG5cbiAgICAgICAgICBpZiAoIXR5cGUgJiYgb2JqLmlzRG9tKSB7XG4gICAgICAgICAgICB0eXBlID0gZWxlbWVudC5kYXRhKCdmYW5jeWJveC10eXBlJyk7XG5cbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICByZXogPSBlbGVtZW50LnByb3AoJ2NsYXNzJykubWF0Y2goL2ZhbmN5Ym94XFwuKFxcdyspLyk7XG4gICAgICAgICAgICAgIHR5cGUgPSByZXogPyByZXpbMV0gOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1N0cmluZyhocmVmKSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGd1ZXNzIHRoZSBjb250ZW50IHR5cGVcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICBpZiAoRi5pc0ltYWdlKGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdpbWFnZSc7XG5cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChGLmlzU1dGKGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdzd2YnO1xuXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaHJlZi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnaW5saW5lJztcblxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdodG1sJztcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTcGxpdCB1cmwgaW50byB0d28gcGllY2VzIHdpdGggc291cmNlIHVybCBhbmQgY29udGVudCBzZWxlY3RvciwgZS5nLFxuICAgICAgICAgICAgLy8gXCIvbXlwYWdlLmh0bWwgI215X2lkXCIgd2lsbCBsb2FkIFwiL215cGFnZS5odG1sXCIgYW5kIGRpc3BsYXkgZWxlbWVudCBoYXZpbmcgaWQgXCJteV9pZFwiXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2FqYXgnKSB7XG4gICAgICAgICAgICAgIGhyZWZQYXJ0cyA9IGhyZWYuc3BsaXQoL1xccysvLCAyKTtcbiAgICAgICAgICAgICAgaHJlZiA9IGhyZWZQYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgICBzZWxlY3RvciA9IGhyZWZQYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9ICQoaXNTdHJpbmcoaHJlZikgPyBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSA6IGhyZWYpOyAvL3N0cmlwIGZvciBpZTdcblxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9iai5pc0RvbSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2h0bWwnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBocmVmO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0eXBlICYmICFocmVmICYmIG9iai5pc0RvbSkge1xuICAgICAgICAgICAgICB0eXBlID0gJ2lubGluZSc7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgICQuZXh0ZW5kKG9iaiwge1xuICAgICAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBncm91cFtpXSA9IG9iajtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBkZWZhdWx0c1xuICAgICAgICBGLm9wdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgRi5kZWZhdWx0cywgb3B0cyk7XG5cbiAgICAgICAgLy8gQWxsIG9wdGlvbnMgYXJlIG1lcmdlZCByZWN1cnNpdmUgZXhjZXB0IGtleXNcbiAgICAgICAgaWYgKG9wdHMua2V5cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgRi5vcHRzLmtleXMgPSBvcHRzLmtleXMgPyAkLmV4dGVuZCh7fSwgRi5kZWZhdWx0cy5rZXlzLCBvcHRzLmtleXMpIDogZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBGLmdyb3VwID0gZ3JvdXA7XG5cbiAgICAgICAgcmV0dXJuIEYuX3N0YXJ0KEYub3B0cy5pbmRleCk7XG4gICAgICB9LFxuXG4gICAgICAvLyBDYW5jZWwgaW1hZ2UgbG9hZGluZyBvciBhYm9ydCBhamF4IHJlcXVlc3RcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29taW5nID0gRi5jb21pbmc7XG5cbiAgICAgICAgaWYgKGNvbWluZyAmJiBmYWxzZSA9PT0gRi50cmlnZ2VyKCdvbkNhbmNlbCcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgRi5oaWRlTG9hZGluZygpO1xuXG4gICAgICAgIGlmICghY29taW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEYuYWpheExvYWQpIHtcbiAgICAgICAgICBGLmFqYXhMb2FkLmFib3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBGLmFqYXhMb2FkID0gbnVsbDtcblxuICAgICAgICBpZiAoRi5pbWdQcmVsb2FkKSB7XG4gICAgICAgICAgRi5pbWdQcmVsb2FkLm9ubG9hZCA9IEYuaW1nUHJlbG9hZC5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21pbmcud3JhcCkge1xuICAgICAgICAgIGNvbWluZy53cmFwLnN0b3AodHJ1ZSwgdHJ1ZSkudHJpZ2dlcignb25SZXNldCcpLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgRi5jb21pbmcgPSBudWxsO1xuXG4gICAgICAgIC8vIElmIHRoZSBmaXJzdCBpdGVtIGhhcyBiZWVuIGNhbmNlbGVkLCB0aGVuIGNsZWFyIGV2ZXJ5dGhpbmdcbiAgICAgICAgaWYgKCFGLmN1cnJlbnQpIHtcbiAgICAgICAgICBGLl9hZnRlclpvb21PdXQoY29taW5nKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gU3RhcnQgY2xvc2luZyBhbmltYXRpb24gaWYgaXMgb3BlbjsgcmVtb3ZlIGltbWVkaWF0ZWx5IGlmIG9wZW5pbmcvY2xvc2luZ1xuICAgICAgY2xvc2U6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBGLmNhbmNlbCgpO1xuXG4gICAgICAgIGlmIChmYWxzZSA9PT0gRi50cmlnZ2VyKCdiZWZvcmVDbG9zZScpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgRi51bmJpbmRFdmVudHMoKTtcblxuICAgICAgICBpZiAoIUYuaXNBY3RpdmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUYuaXNPcGVuIHx8IGV2ZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgJCgnLmZhbmN5Ym94LXdyYXAnKS5zdG9wKHRydWUpLnRyaWdnZXIoJ29uUmVzZXQnKS5yZW1vdmUoKTtcblxuICAgICAgICAgIEYuX2FmdGVyWm9vbU91dCgpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRi5pc09wZW4gPSBGLmlzT3BlbmVkID0gZmFsc2U7XG4gICAgICAgICAgRi5pc0Nsb3NpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgJCgnLmZhbmN5Ym94LWl0ZW0sIC5mYW5jeWJveC1uYXYnKS5yZW1vdmUoKTtcblxuICAgICAgICAgIEYud3JhcC5zdG9wKHRydWUsIHRydWUpLnJlbW92ZUNsYXNzKCdmYW5jeWJveC1vcGVuZWQnKTtcblxuICAgICAgICAgIEYudHJhbnNpdGlvbnNbRi5jdXJyZW50LmNsb3NlTWV0aG9kXSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBNYW5hZ2Ugc2xpZGVzaG93OlxuICAgICAgLy8gICAkLmZhbmN5Ym94LnBsYXkoKTsgLSB0b2dnbGUgc2xpZGVzaG93XG4gICAgICAvLyAgICQuZmFuY3lib3gucGxheSggdHJ1ZSApOyAtIHN0YXJ0XG4gICAgICAvLyAgICQuZmFuY3lib3gucGxheSggZmFsc2UgKTsgLSBzdG9wXG4gICAgICBwbGF5OiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBjbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoRi5wbGF5ZXIudGltZXIpO1xuICAgICAgICB9LFxuICAgICAgICAgIHNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyKCk7XG5cbiAgICAgICAgICAgIGlmIChGLmN1cnJlbnQgJiYgRi5wbGF5ZXIuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgRi5wbGF5ZXIudGltZXIgPSBzZXRUaW1lb3V0KEYubmV4dCwgRi5jdXJyZW50LnBsYXlTcGVlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXIoKTtcblxuICAgICAgICAgICAgRC51bmJpbmQoJy5wbGF5ZXInKTtcblxuICAgICAgICAgICAgRi5wbGF5ZXIuaXNBY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgRi50cmlnZ2VyKCdvblBsYXlFbmQnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKEYuY3VycmVudCAmJiAoRi5jdXJyZW50Lmxvb3AgfHwgRi5jdXJyZW50LmluZGV4IDwgRi5ncm91cC5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICBGLnBsYXllci5pc0FjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgRC5iaW5kKHtcbiAgICAgICAgICAgICAgICAnb25DYW5jZWwucGxheWVyIGJlZm9yZUNsb3NlLnBsYXllcic6IHN0b3AsXG4gICAgICAgICAgICAgICAgJ29uVXBkYXRlLnBsYXllcic6IHNldCxcbiAgICAgICAgICAgICAgICAnYmVmb3JlTG9hZC5wbGF5ZXInOiBjbGVhclxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBzZXQoKTtcblxuICAgICAgICAgICAgICBGLnRyaWdnZXIoJ29uUGxheVN0YXJ0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICBpZiAoYWN0aW9uID09PSB0cnVlIHx8ICghRi5wbGF5ZXIuaXNBY3RpdmUgJiYgYWN0aW9uICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICBzdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gTmF2aWdhdGUgdG8gbmV4dCBnYWxsZXJ5IGl0ZW1cbiAgICAgIG5leHQ6IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBGLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICBpZiAoIWlzU3RyaW5nKGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGN1cnJlbnQuZGlyZWN0aW9uLm5leHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRi5qdW1wdG8oY3VycmVudC5pbmRleCArIDEsIGRpcmVjdGlvbiwgJ25leHQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gTmF2aWdhdGUgdG8gcHJldmlvdXMgZ2FsbGVyeSBpdGVtXG4gICAgICBwcmV2OiBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gRi5jdXJyZW50O1xuXG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgaWYgKCFpc1N0cmluZyhkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBjdXJyZW50LmRpcmVjdGlvbi5wcmV2O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEYuanVtcHRvKGN1cnJlbnQuaW5kZXggLSAxLCBkaXJlY3Rpb24sICdwcmV2Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIE5hdmlnYXRlIHRvIGdhbGxlcnkgaXRlbSBieSBpbmRleFxuICAgICAganVtcHRvOiBmdW5jdGlvbiAoaW5kZXgsIGRpcmVjdGlvbiwgcm91dGVyKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gRi5jdXJyZW50O1xuXG4gICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gZ2V0U2NhbGFyKGluZGV4KTtcblxuICAgICAgICBGLmRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCBjdXJyZW50LmRpcmVjdGlvblsoaW5kZXggPj0gY3VycmVudC5pbmRleCA/ICduZXh0JyA6ICdwcmV2JyldO1xuICAgICAgICBGLnJvdXRlciA9IHJvdXRlciB8fCAnanVtcHRvJztcblxuICAgICAgICBpZiAoY3VycmVudC5sb29wKSB7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggPSBjdXJyZW50Lmdyb3VwLmxlbmd0aCArIChpbmRleCAlIGN1cnJlbnQuZ3JvdXAubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmRleCA9IGluZGV4ICUgY3VycmVudC5ncm91cC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudC5ncm91cFtpbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIEYuY2FuY2VsKCk7XG5cbiAgICAgICAgICBGLl9zdGFydChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIENlbnRlciBpbnNpZGUgdmlld3BvcnQgYW5kIHRvZ2dsZSBwb3NpdGlvbiB0eXBlIHRvIGZpeGVkIG9yIGFic29sdXRlIGlmIG5lZWRlZFxuICAgICAgcmVwb3NpdGlvbjogZnVuY3Rpb24gKGUsIG9ubHlBYnNvbHV0ZSkge1xuICAgICAgICB2YXIgY3VycmVudCA9IEYuY3VycmVudCxcbiAgICAgICAgICB3cmFwID0gY3VycmVudCA/IGN1cnJlbnQud3JhcCA6IG51bGwsXG4gICAgICAgICAgcG9zO1xuXG4gICAgICAgIGlmICh3cmFwKSB7XG4gICAgICAgICAgcG9zID0gRi5fZ2V0UG9zaXRpb24ob25seUFic29sdXRlKTtcblxuICAgICAgICAgIGlmIChlICYmIGUudHlwZSA9PT0gJ3Njcm9sbCcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwb3MucG9zaXRpb247XG5cbiAgICAgICAgICAgIHdyYXAuc3RvcCh0cnVlLCB0cnVlKS5hbmltYXRlKHBvcywgMjAwKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwLmNzcyhwb3MpO1xuXG4gICAgICAgICAgICBjdXJyZW50LnBvcyA9ICQuZXh0ZW5kKHt9LCBjdXJyZW50LmRpbSwgcG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSAoZSAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LnR5cGUpLFxuICAgICAgICAgIGFueXdheSA9ICF0eXBlIHx8IHR5cGUgPT09ICdvcmllbnRhdGlvbmNoYW5nZSc7XG5cbiAgICAgICAgaWYgKGFueXdheSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChkaWRVcGRhdGUpO1xuXG4gICAgICAgICAgZGlkVXBkYXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghRi5pc09wZW4gfHwgZGlkVXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlkVXBkYXRlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBGLmN1cnJlbnQ7XG5cbiAgICAgICAgICBpZiAoIWN1cnJlbnQgfHwgRi5pc0Nsb3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBGLndyYXAucmVtb3ZlQ2xhc3MoJ2ZhbmN5Ym94LXRtcCcpO1xuXG4gICAgICAgICAgaWYgKGFueXdheSB8fCB0eXBlID09PSAnbG9hZCcgfHwgKHR5cGUgPT09ICdyZXNpemUnICYmIGN1cnJlbnQuYXV0b1Jlc2l6ZSkpIHtcbiAgICAgICAgICAgIEYuX3NldERpbWVuc2lvbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghKHR5cGUgPT09ICdzY3JvbGwnICYmIGN1cnJlbnQuY2FuU2hyaW5rKSkge1xuICAgICAgICAgICAgRi5yZXBvc2l0aW9uKGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEYudHJpZ2dlcignb25VcGRhdGUnKTtcblxuICAgICAgICAgIGRpZFVwZGF0ZSA9IG51bGw7XG5cbiAgICAgICAgfSwgKGFueXdheSAmJiAhaXNUb3VjaCA/IDAgOiAzMDApKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIFNocmluayBjb250ZW50IHRvIGZpdCBpbnNpZGUgdmlld3BvcnQgb3IgcmVzdG9yZSBpZiByZXNpemVkXG4gICAgICB0b2dnbGU6IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKEYuaXNPcGVuKSB7XG4gICAgICAgICAgRi5jdXJyZW50LmZpdFRvVmlldyA9ICQudHlwZShhY3Rpb24pID09PSBcImJvb2xlYW5cIiA/IGFjdGlvbiA6ICFGLmN1cnJlbnQuZml0VG9WaWV3O1xuXG4gICAgICAgICAgLy8gSGVscCBicm93c2VyIHRvIHJlc3RvcmUgZG9jdW1lbnQgZGltZW5zaW9uc1xuICAgICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICBGLndyYXAucmVtb3ZlQXR0cignc3R5bGUnKS5hZGRDbGFzcygnZmFuY3lib3gtdG1wJyk7XG5cbiAgICAgICAgICAgIEYudHJpZ2dlcignb25VcGRhdGUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBGLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBoaWRlTG9hZGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICBELnVuYmluZCgnLmxvYWRpbmcnKTtcblxuICAgICAgICAkKCcjZmFuY3lib3gtbG9hZGluZycpLnJlbW92ZSgpO1xuICAgICAgfSxcblxuICAgICAgc2hvd0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsLCB2aWV3cG9ydDtcblxuICAgICAgICBGLmhpZGVMb2FkaW5nKCk7XG5cbiAgICAgICAgZWwgPSAkKEYub3B0cy50cGwubG9hZGluZykuY2xpY2soRi5jYW5jZWwpLmFwcGVuZFRvKCdib2R5Jyk7XG5cbiAgICAgICAgLy8gSWYgdXNlciB3aWxsIHByZXNzIHRoZSBlc2NhcGUtYnV0dG9uLCB0aGUgcmVxdWVzdCB3aWxsIGJlIGNhbmNlbGVkXG4gICAgICAgIEQuYmluZCgna2V5ZG93bi5sb2FkaW5nJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoKGUud2hpY2ggfHwgZS5rZXlDb2RlKSA9PT0gMjcpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgRi5jYW5jZWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghRi5kZWZhdWx0cy5maXhlZCkge1xuICAgICAgICAgIHZpZXdwb3J0ID0gRi5nZXRWaWV3cG9ydCgpO1xuXG4gICAgICAgICAgZWwuY3NzKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOiAodmlld3BvcnQuaCAqIDAuNSkgKyB2aWV3cG9ydC55LFxuICAgICAgICAgICAgbGVmdDogKHZpZXdwb3J0LncgKiAwLjUpICsgdmlld3BvcnQueFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgRi50cmlnZ2VyKCdvbkxvYWRpbmcnKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldFZpZXdwb3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2NrZWQgPSAoRi5jdXJyZW50ICYmIEYuY3VycmVudC5sb2NrZWQpIHx8IGZhbHNlLFxuICAgICAgICAgIHJleiA9IHtcbiAgICAgICAgICAgIHg6IFcuc2Nyb2xsTGVmdCgpLFxuICAgICAgICAgICAgeTogVy5zY3JvbGxUb3AoKVxuICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKGxvY2tlZCAmJiBsb2NrZWQubGVuZ3RoKSB7XG4gICAgICAgICAgcmV6LncgPSBsb2NrZWRbMF0uY2xpZW50V2lkdGg7XG4gICAgICAgICAgcmV6LmggPSBsb2NrZWRbMF0uY2xpZW50SGVpZ2h0O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzY3MjRcbiAgICAgICAgICByZXoudyA9IGlzVG91Y2ggJiYgd2luZG93LmlubmVyV2lkdGggPyB3aW5kb3cuaW5uZXJXaWR0aCA6IFcud2lkdGgoKTtcbiAgICAgICAgICByZXouaCA9IGlzVG91Y2ggJiYgd2luZG93LmlubmVySGVpZ2h0ID8gd2luZG93LmlubmVySGVpZ2h0IDogVy5oZWlnaHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXo7XG4gICAgICB9LFxuXG4gICAgICAvLyBVbmJpbmQgdGhlIGtleWJvYXJkIC8gY2xpY2tpbmcgYWN0aW9uc1xuICAgICAgdW5iaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChGLndyYXAgJiYgaXNRdWVyeShGLndyYXApKSB7XG4gICAgICAgICAgRi53cmFwLnVuYmluZCgnLmZiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBELnVuYmluZCgnLmZiJyk7XG4gICAgICAgIFcudW5iaW5kKCcuZmInKTtcbiAgICAgIH0sXG5cbiAgICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBGLmN1cnJlbnQsXG4gICAgICAgICAga2V5cztcblxuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGFuZ2luZyBkb2N1bWVudCBoZWlnaHQgb24gaU9TIGRldmljZXMgdHJpZ2dlcnMgYSAncmVzaXplJyBldmVudCxcbiAgICAgICAgLy8gdGhhdCBjYW4gY2hhbmdlIGRvY3VtZW50IGhlaWdodC4uLiByZXBlYXRpbmcgaW5maW5pdGVseVxuICAgICAgICBXLmJpbmQoJ29yaWVudGF0aW9uY2hhbmdlLmZiJyArIChpc1RvdWNoID8gJycgOiAnIHJlc2l6ZS5mYicpICsgKGN1cnJlbnQuYXV0b0NlbnRlciAmJiAhY3VycmVudC5sb2NrZWQgPyAnIHNjcm9sbC5mYicgOiAnJyksIEYudXBkYXRlKTtcblxuICAgICAgICBrZXlzID0gY3VycmVudC5rZXlzO1xuXG4gICAgICAgIGlmIChrZXlzKSB7XG4gICAgICAgICAgRC5iaW5kKCdrZXlkb3duLmZiJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZS53aGljaCB8fCBlLmtleUNvZGUsXG4gICAgICAgICAgICAgIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblxuICAgICAgICAgICAgLy8gU2tpcCBlc2Mga2V5IGlmIGxvYWRpbmcsIGJlY2F1c2Ugc2hvd0xvYWRpbmcgd2lsbCBjYW5jZWwgcHJlbG9hZGluZ1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDI3ICYmIEYuY29taW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWdub3JlIGtleSBjb21iaW5hdGlvbnMgYW5kIGtleSBldmVudHMgd2l0aGluIGZvcm0gZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghZS5jdHJsS2V5ICYmICFlLmFsdEtleSAmJiAhZS5zaGlmdEtleSAmJiAhZS5tZXRhS2V5ICYmICEodGFyZ2V0ICYmICh0YXJnZXQudHlwZSB8fCAkKHRhcmdldCkuaXMoJ1tjb250ZW50ZWRpdGFibGVdJykpKSkge1xuICAgICAgICAgICAgICAkLmVhY2goa2V5cywgZnVuY3Rpb24gKGksIHZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Lmdyb3VwLmxlbmd0aCA+IDEgJiYgdmFsW2NvZGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIEZbaV0odmFsW2NvZGVdKTtcblxuICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkoY29kZSwgdmFsKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICBGW2ldKCk7XG5cbiAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCQuZm4ubW91c2V3aGVlbCAmJiBjdXJyZW50Lm1vdXNlV2hlZWwpIHtcbiAgICAgICAgICBGLndyYXAuYmluZCgnbW91c2V3aGVlbC5mYicsIGZ1bmN0aW9uIChlLCBkZWx0YSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBudWxsLFxuICAgICAgICAgICAgICBwYXJlbnQgPSAkKHRhcmdldCksXG4gICAgICAgICAgICAgIGNhblNjcm9sbCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB3aGlsZSAocGFyZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoY2FuU2Nyb2xsIHx8IHBhcmVudC5pcygnLmZhbmN5Ym94LXNraW4nKSB8fCBwYXJlbnQuaXMoJy5mYW5jeWJveC13cmFwJykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhblNjcm9sbCA9IGlzU2Nyb2xsYWJsZShwYXJlbnRbMF0pO1xuICAgICAgICAgICAgICBwYXJlbnQgPSAkKHBhcmVudCkucGFyZW50KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZWx0YSAhPT0gMCAmJiAhY2FuU2Nyb2xsKSB7XG4gICAgICAgICAgICAgIGlmIChGLmdyb3VwLmxlbmd0aCA+IDEgJiYgIWN1cnJlbnQuY2FuU2hyaW5rKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhWSA+IDAgfHwgZGVsdGFYID4gMCkge1xuICAgICAgICAgICAgICAgICAgRi5wcmV2KGRlbHRhWSA+IDAgPyAnZG93bicgOiAnbGVmdCcpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZWx0YVkgPCAwIHx8IGRlbHRhWCA8IDApIHtcbiAgICAgICAgICAgICAgICAgIEYubmV4dChkZWx0YVkgPCAwID8gJ3VwJyA6ICdyaWdodCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnQsIG8pIHtcbiAgICAgICAgdmFyIHJldCwgb2JqID0gbyB8fCBGLmNvbWluZyB8fCBGLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24ob2JqW2V2ZW50XSkpIHtcbiAgICAgICAgICAgIHJldCA9IG9ialtldmVudF0uYXBwbHkob2JqLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvYmouaGVscGVycykge1xuICAgICAgICAgICAgJC5lYWNoKG9iai5oZWxwZXJzLCBmdW5jdGlvbiAoaGVscGVyLCBvcHRzKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRzICYmIEYuaGVscGVyc1toZWxwZXJdICYmICQuaXNGdW5jdGlvbihGLmhlbHBlcnNbaGVscGVyXVtldmVudF0pKSB7XG4gICAgICAgICAgICAgICAgRi5oZWxwZXJzW2hlbHBlcl1bZXZlbnRdKCQuZXh0ZW5kKHRydWUsIHt9LCBGLmhlbHBlcnNbaGVscGVyXS5kZWZhdWx0cywgb3B0cyksIG9iaik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEQudHJpZ2dlcihldmVudCk7XG4gICAgICB9LFxuXG4gICAgICBpc0ltYWdlOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyhzdHIpICYmIHN0ci5tYXRjaCgvKF5kYXRhOmltYWdlXFwvLiosKXwoXFwuKGpwKGV8Z3xlZyl8Z2lmfHBuZ3xibXB8d2VicHxzdmcpKChcXD98IykuKik/JCkvaSk7XG4gICAgICB9LFxuXG4gICAgICBpc1NXRjogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcoc3RyKSAmJiBzdHIubWF0Y2goL1xcLihzd2YpKChcXD98IykuKik/JC9pKTtcbiAgICAgIH0sXG5cbiAgICAgIF9zdGFydDogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBjb21pbmcgPSB7fSxcbiAgICAgICAgICBvYmosXG4gICAgICAgICAgaHJlZixcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIG1hcmdpbixcbiAgICAgICAgICBwYWRkaW5nO1xuXG4gICAgICAgIGluZGV4ID0gZ2V0U2NhbGFyKGluZGV4KTtcbiAgICAgICAgb2JqID0gRi5ncm91cFtpbmRleF0gfHwgbnVsbDtcblxuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbWluZyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBGLm9wdHMsIG9iaik7XG5cbiAgICAgICAgLy8gQ29udmVydCBtYXJnaW4gYW5kIHBhZGRpbmcgcHJvcGVydGllcyB0byBhcnJheSAtIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFxuICAgICAgICBtYXJnaW4gPSBjb21pbmcubWFyZ2luO1xuICAgICAgICBwYWRkaW5nID0gY29taW5nLnBhZGRpbmc7XG5cbiAgICAgICAgaWYgKCQudHlwZShtYXJnaW4pID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGNvbWluZy5tYXJnaW4gPSBbbWFyZ2luLCBtYXJnaW4sIG1hcmdpbiwgbWFyZ2luXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkLnR5cGUocGFkZGluZykgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29taW5nLnBhZGRpbmcgPSBbcGFkZGluZywgcGFkZGluZywgcGFkZGluZywgcGFkZGluZ107XG4gICAgICAgIH1cblxuICAgICAgICAvLyAnbW9kYWwnIHByb3BlcnkgaXMganVzdCBhIHNob3J0Y3V0XG4gICAgICAgIGlmIChjb21pbmcubW9kYWwpIHtcbiAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBjb21pbmcsIHtcbiAgICAgICAgICAgIGNsb3NlQnRuOiBmYWxzZSxcbiAgICAgICAgICAgIGNsb3NlQ2xpY2s6IGZhbHNlLFxuICAgICAgICAgICAgbmV4dENsaWNrOiBmYWxzZSxcbiAgICAgICAgICAgIGFycm93czogZmFsc2UsXG4gICAgICAgICAgICBtb3VzZVdoZWVsOiBmYWxzZSxcbiAgICAgICAgICAgIGtleXM6IG51bGwsXG4gICAgICAgICAgICBoZWxwZXJzOiB7XG4gICAgICAgICAgICAgIG92ZXJsYXk6IHtcbiAgICAgICAgICAgICAgICBjbG9zZUNsaWNrOiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAnYXV0b1NpemUnIHByb3BlcnR5IGlzIGEgc2hvcnRjdXQsIHRvb1xuICAgICAgICBpZiAoY29taW5nLmF1dG9TaXplKSB7XG4gICAgICAgICAgY29taW5nLmF1dG9XaWR0aCA9IGNvbWluZy5hdXRvSGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21pbmcud2lkdGggPT09ICdhdXRvJykge1xuICAgICAgICAgIGNvbWluZy5hdXRvV2lkdGggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbWluZy5oZWlnaHQgPT09ICdhdXRvJykge1xuICAgICAgICAgIGNvbWluZy5hdXRvSGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEFkZCByZWZlcmVuY2UgdG8gdGhlIGdyb3VwLCBzbyBpdGBzIHBvc3NpYmxlIHRvIGFjY2VzcyBmcm9tIGNhbGxiYWNrcywgZXhhbXBsZTpcbiAgICAgICAgICogYWZ0ZXJMb2FkIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAqICAgICB0aGlzLnRpdGxlID0gJ0ltYWdlICcgKyAodGhpcy5pbmRleCArIDEpICsgJyBvZiAnICsgdGhpcy5ncm91cC5sZW5ndGggKyAodGhpcy50aXRsZSA/ICcgLSAnICsgdGhpcy50aXRsZSA6ICcnKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKi9cblxuICAgICAgICBjb21pbmcuZ3JvdXAgPSBGLmdyb3VwO1xuICAgICAgICBjb21pbmcuaW5kZXggPSBpbmRleDtcblxuICAgICAgICAvLyBHaXZlIGEgY2hhbmNlIGZvciBjYWxsYmFjayBvciBoZWxwZXJzIHRvIHVwZGF0ZSBjb21pbmcgaXRlbSAodHlwZSwgdGl0bGUsIGV0YylcbiAgICAgICAgRi5jb21pbmcgPSBjb21pbmc7XG5cbiAgICAgICAgaWYgKGZhbHNlID09PSBGLnRyaWdnZXIoJ2JlZm9yZUxvYWQnKSkge1xuICAgICAgICAgIEYuY29taW5nID0gbnVsbDtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHR5cGUgPSBjb21pbmcudHlwZTtcbiAgICAgICAgaHJlZiA9IGNvbWluZy5ocmVmO1xuXG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIEYuY29taW5nID0gbnVsbDtcblxuICAgICAgICAgIC8vSWYgd2UgY2FuIG5vdCBkZXRlcm1pbmUgY29udGVudCB0eXBlIHRoZW4gZHJvcCBzaWxlbnRseSBvciBkaXNwbGF5IG5leHQvcHJldiBpdGVtIGlmIGxvb3BpbmcgdGhyb3VnaCBnYWxsZXJ5XG4gICAgICAgICAgaWYgKEYuY3VycmVudCAmJiBGLnJvdXRlciAmJiBGLnJvdXRlciAhPT0gJ2p1bXB0bycpIHtcbiAgICAgICAgICAgIEYuY3VycmVudC5pbmRleCA9IGluZGV4O1xuXG4gICAgICAgICAgICByZXR1cm4gRltGLnJvdXRlcl0oRi5kaXJlY3Rpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIEYuaXNBY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnaW1hZ2UnIHx8IHR5cGUgPT09ICdzd2YnKSB7XG4gICAgICAgICAgY29taW5nLmF1dG9IZWlnaHQgPSBjb21pbmcuYXV0b1dpZHRoID0gZmFsc2U7XG4gICAgICAgICAgY29taW5nLnNjcm9sbGluZyA9ICd2aXNpYmxlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnaW1hZ2UnKSB7XG4gICAgICAgICAgY29taW5nLmFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnaWZyYW1lJyAmJiBpc1RvdWNoKSB7XG4gICAgICAgICAgY29taW5nLnNjcm9sbGluZyA9ICdzY3JvbGwnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgdGhlIG5lY2Nlc3NhcnkgbWFya3VwXG4gICAgICAgIGNvbWluZy53cmFwID0gJChjb21pbmcudHBsLndyYXApLmFkZENsYXNzKCdmYW5jeWJveC0nICsgKGlzVG91Y2ggPyAnbW9iaWxlJyA6ICdkZXNrdG9wJykgKyAnIGZhbmN5Ym94LXR5cGUtJyArIHR5cGUgKyAnIGZhbmN5Ym94LXRtcCAnICsgY29taW5nLndyYXBDU1MpLmFwcGVuZFRvKGNvbWluZy5wYXJlbnQgfHwgJ2JvZHknKTtcblxuICAgICAgICAkLmV4dGVuZChjb21pbmcsIHtcbiAgICAgICAgICBza2luOiAkKCcuZmFuY3lib3gtc2tpbicsIGNvbWluZy53cmFwKSxcbiAgICAgICAgICBvdXRlcjogJCgnLmZhbmN5Ym94LW91dGVyJywgY29taW5nLndyYXApLFxuICAgICAgICAgIGlubmVyOiAkKCcuZmFuY3lib3gtaW5uZXInLCBjb21pbmcud3JhcClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJC5lYWNoKFtcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiXSwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgICBjb21pbmcuc2tpbi5jc3MoJ3BhZGRpbmcnICsgdiwgZ2V0VmFsdWUoY29taW5nLnBhZGRpbmdbaV0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgRi50cmlnZ2VyKCdvblJlYWR5Jyk7XG5cbiAgICAgICAgLy8gQ2hlY2sgYmVmb3JlIHRyeSB0byBsb2FkOyAnaW5saW5lJyBhbmQgJ2h0bWwnIHR5cGVzIG5lZWQgY29udGVudCwgb3RoZXJzIC0gaHJlZlxuICAgICAgICBpZiAodHlwZSA9PT0gJ2lubGluZScgfHwgdHlwZSA9PT0gJ2h0bWwnKSB7XG4gICAgICAgICAgaWYgKCFjb21pbmcuY29udGVudCB8fCAhY29taW5nLmNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gRi5fZXJyb3IoJ2NvbnRlbnQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmICghaHJlZikge1xuICAgICAgICAgIHJldHVybiBGLl9lcnJvcignaHJlZicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgICAgICBGLl9sb2FkSW1hZ2UoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhamF4Jykge1xuICAgICAgICAgIEYuX2xvYWRBamF4KCk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaWZyYW1lJykge1xuICAgICAgICAgIEYuX2xvYWRJZnJhbWUoKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEYuX2FmdGVyTG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfZXJyb3I6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICQuZXh0ZW5kKEYuY29taW5nLCB7XG4gICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgIGF1dG9XaWR0aDogdHJ1ZSxcbiAgICAgICAgICBhdXRvSGVpZ2h0OiB0cnVlLFxuICAgICAgICAgIG1pbldpZHRoOiAwLFxuICAgICAgICAgIG1pbkhlaWdodDogMCxcbiAgICAgICAgICBzY3JvbGxpbmc6ICdubycsXG4gICAgICAgICAgaGFzRXJyb3I6IHR5cGUsXG4gICAgICAgICAgY29udGVudDogRi5jb21pbmcudHBsLmVycm9yXG4gICAgICAgIH0pO1xuXG4gICAgICAgIEYuX2FmdGVyTG9hZCgpO1xuICAgICAgfSxcblxuICAgICAgX2xvYWRJbWFnZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZXNldCBwcmVsb2FkIGltYWdlIHNvIGl0IGlzIGxhdGVyIHBvc3NpYmxlIHRvIGNoZWNrIFwiY29tcGxldGVcIiBwcm9wZXJ0eVxuICAgICAgICB2YXIgaW1nID0gRi5pbWdQcmVsb2FkID0gbmV3IEltYWdlKCk7XG5cbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLm9ubG9hZCA9IHRoaXMub25lcnJvciA9IG51bGw7XG5cbiAgICAgICAgICBGLmNvbWluZy53aWR0aCA9IHRoaXMud2lkdGggLyBGLm9wdHMucGl4ZWxSYXRpbztcbiAgICAgICAgICBGLmNvbWluZy5oZWlnaHQgPSB0aGlzLmhlaWdodCAvIEYub3B0cy5waXhlbFJhdGlvO1xuXG4gICAgICAgICAgRi5fYWZ0ZXJMb2FkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5vbmxvYWQgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuXG4gICAgICAgICAgRi5fZXJyb3IoJ2ltYWdlJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaW1nLnNyYyA9IEYuY29taW5nLmhyZWY7XG5cbiAgICAgICAgaWYgKGltZy5jb21wbGV0ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIEYuc2hvd0xvYWRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2xvYWRBamF4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21pbmcgPSBGLmNvbWluZztcblxuICAgICAgICBGLnNob3dMb2FkaW5nKCk7XG5cbiAgICAgICAgRi5hamF4TG9hZCA9ICQuYWpheCgkLmV4dGVuZCh7fSwgY29taW5nLmFqYXgsIHtcbiAgICAgICAgICB1cmw6IGNvbWluZy5ocmVmLFxuICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMpIHtcbiAgICAgICAgICAgIGlmIChGLmNvbWluZyAmJiB0ZXh0U3RhdHVzICE9PSAnYWJvcnQnKSB7XG4gICAgICAgICAgICAgIEYuX2Vycm9yKCdhamF4JywganFYSFIpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBGLmhpZGVMb2FkaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSwgdGV4dFN0YXR1cykge1xuICAgICAgICAgICAgaWYgKHRleHRTdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICBjb21pbmcuY29udGVudCA9IGRhdGE7XG5cbiAgICAgICAgICAgICAgRi5fYWZ0ZXJMb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9LFxuXG4gICAgICBfbG9hZElmcmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29taW5nID0gRi5jb21pbmcsXG4gICAgICAgICAgaWZyYW1lID0gJChjb21pbmcudHBsLmlmcmFtZS5yZXBsYWNlKC9cXHtybmRcXH0vZywgbmV3IERhdGUoKS5nZXRUaW1lKCkpKVxuICAgICAgICAgICAgLmF0dHIoJ3Njcm9sbGluZycsIGlzVG91Y2ggPyAnYXV0bycgOiBjb21pbmcuaWZyYW1lLnNjcm9sbGluZylcbiAgICAgICAgICAgIC5hdHRyKCdzcmMnLCBjb21pbmcuaHJlZik7XG5cbiAgICAgICAgLy8gVGhpcyBoZWxwcyBJRVxuICAgICAgICAkKGNvbWluZy53cmFwKS5iaW5kKCdvblJlc2V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAkKHRoaXMpLmZpbmQoJ2lmcmFtZScpLmhpZGUoKS5hdHRyKCdzcmMnLCAnLy9hYm91dDpibGFuaycpLmVuZCgpLmVtcHR5KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjb21pbmcuaWZyYW1lLnByZWxvYWQpIHtcbiAgICAgICAgICBGLnNob3dMb2FkaW5nKCk7XG5cbiAgICAgICAgICBpZnJhbWUub25lKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5kYXRhKCdyZWFkeScsIDEpO1xuXG4gICAgICAgICAgICAvLyBpT1Mgd2lsbCBsb3NlIHNjcm9sbGluZyBpZiB3ZSByZXNpemVcbiAgICAgICAgICAgIGlmICghaXNUb3VjaCkge1xuICAgICAgICAgICAgICAkKHRoaXMpLmJpbmQoJ2xvYWQuZmInLCBGLnVwZGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdpdGhvdXQgdGhpcyB0cmljazpcbiAgICAgICAgICAgIC8vICAgLSBpZnJhbWUgd29uJ3Qgc2Nyb2xsIG9uIGlPUyBkZXZpY2VzXG4gICAgICAgICAgICAvLyAgIC0gSUU3IHNvbWV0aW1lcyBkaXNwbGF5cyBlbXB0eSBpZnJhbWVcbiAgICAgICAgICAgICQodGhpcykucGFyZW50cygnLmZhbmN5Ym94LXdyYXAnKS53aWR0aCgnMTAwJScpLnJlbW92ZUNsYXNzKCdmYW5jeWJveC10bXAnKS5zaG93KCk7XG5cbiAgICAgICAgICAgIEYuX2FmdGVyTG9hZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29taW5nLmNvbnRlbnQgPSBpZnJhbWUuYXBwZW5kVG8oY29taW5nLmlubmVyKTtcblxuICAgICAgICBpZiAoIWNvbWluZy5pZnJhbWUucHJlbG9hZCkge1xuICAgICAgICAgIEYuX2FmdGVyTG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcHJlbG9hZEltYWdlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ3JvdXAgPSBGLmdyb3VwLFxuICAgICAgICAgIGN1cnJlbnQgPSBGLmN1cnJlbnQsXG4gICAgICAgICAgbGVuID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICAgIGNudCA9IGN1cnJlbnQucHJlbG9hZCA/IE1hdGgubWluKGN1cnJlbnQucHJlbG9hZCwgbGVuIC0gMSkgOiAwLFxuICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgaTtcblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGNudDsgaSArPSAxKSB7XG4gICAgICAgICAgaXRlbSA9IGdyb3VwWyhjdXJyZW50LmluZGV4ICsgaSkgJSBsZW5dO1xuXG4gICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2ltYWdlJyAmJiBpdGVtLmhyZWYpIHtcbiAgICAgICAgICAgIG5ldyBJbWFnZSgpLnNyYyA9IGl0ZW0uaHJlZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9hZnRlckxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbWluZyA9IEYuY29taW5nLFxuICAgICAgICAgIHByZXZpb3VzID0gRi5jdXJyZW50LFxuICAgICAgICAgIHBsYWNlaG9sZGVyID0gJ2ZhbmN5Ym94LXBsYWNlaG9sZGVyJyxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBzY3JvbGxpbmcsXG4gICAgICAgICAgaHJlZixcbiAgICAgICAgICBlbWJlZDtcblxuICAgICAgICBGLmhpZGVMb2FkaW5nKCk7XG5cbiAgICAgICAgaWYgKCFjb21pbmcgfHwgRi5pc0FjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmFsc2UgPT09IEYudHJpZ2dlcignYWZ0ZXJMb2FkJywgY29taW5nLCBwcmV2aW91cykpIHtcbiAgICAgICAgICBjb21pbmcud3JhcC5zdG9wKHRydWUpLnRyaWdnZXIoJ29uUmVzZXQnKS5yZW1vdmUoKTtcblxuICAgICAgICAgIEYuY29taW5nID0gbnVsbDtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICAgIEYudHJpZ2dlcignYmVmb3JlQ2hhbmdlJywgcHJldmlvdXMpO1xuXG4gICAgICAgICAgcHJldmlvdXMud3JhcC5zdG9wKHRydWUpLnJlbW92ZUNsYXNzKCdmYW5jeWJveC1vcGVuZWQnKVxuICAgICAgICAgICAgLmZpbmQoJy5mYW5jeWJveC1pdGVtLCAuZmFuY3lib3gtbmF2JylcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEYudW5iaW5kRXZlbnRzKCk7XG5cbiAgICAgICAgY3VycmVudCA9IGNvbWluZztcbiAgICAgICAgY29udGVudCA9IGNvbWluZy5jb250ZW50O1xuICAgICAgICB0eXBlID0gY29taW5nLnR5cGU7XG4gICAgICAgIHNjcm9sbGluZyA9IGNvbWluZy5zY3JvbGxpbmc7XG5cbiAgICAgICAgJC5leHRlbmQoRiwge1xuICAgICAgICAgIHdyYXA6IGN1cnJlbnQud3JhcCxcbiAgICAgICAgICBza2luOiBjdXJyZW50LnNraW4sXG4gICAgICAgICAgb3V0ZXI6IGN1cnJlbnQub3V0ZXIsXG4gICAgICAgICAgaW5uZXI6IGN1cnJlbnQuaW5uZXIsXG4gICAgICAgICAgY3VycmVudDogY3VycmVudCxcbiAgICAgICAgICBwcmV2aW91czogcHJldmlvdXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaHJlZiA9IGN1cnJlbnQuaHJlZjtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdpbmxpbmUnOlxuICAgICAgICAgIGNhc2UgJ2FqYXgnOlxuICAgICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgICAgaWYgKGN1cnJlbnQuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9ICQoJzxkaXY+JykuaHRtbChjb250ZW50KS5maW5kKGN1cnJlbnQuc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzUXVlcnkoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgaWYgKCFjb250ZW50LmRhdGEocGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5kYXRhKHBsYWNlaG9sZGVyLCAkKCc8ZGl2IGNsYXNzPVwiJyArIHBsYWNlaG9sZGVyICsgJ1wiPjwvZGl2PicpLmluc2VydEFmdGVyKGNvbnRlbnQpLmhpZGUoKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zaG93KCkuZGV0YWNoKCk7XG5cbiAgICAgICAgICAgICAgY3VycmVudC53cmFwLmJpbmQoJ29uUmVzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcykuZmluZChjb250ZW50KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQuaGlkZSgpLnJlcGxhY2VBbGwoY29udGVudC5kYXRhKHBsYWNlaG9sZGVyKSkuZGF0YShwbGFjZWhvbGRlciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjdXJyZW50LnRwbC5pbWFnZS5yZXBsYWNlKC9cXHtocmVmXFx9L2csIGhyZWYpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzd2YnOlxuICAgICAgICAgICAgY29udGVudCA9ICc8b2JqZWN0IGlkPVwiZmFuY3lib3gtc3dmXCIgY2xhc3NpZD1cImNsc2lkOkQyN0NEQjZFLUFFNkQtMTFjZi05NkI4LTQ0NDU1MzU0MDAwMFwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIj48cGFyYW0gbmFtZT1cIm1vdmllXCIgdmFsdWU9XCInICsgaHJlZiArICdcIj48L3BhcmFtPic7XG4gICAgICAgICAgICBlbWJlZCA9ICcnO1xuXG4gICAgICAgICAgICAkLmVhY2goY3VycmVudC5zd2YsIGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcbiAgICAgICAgICAgICAgY29udGVudCArPSAnPHBhcmFtIG5hbWU9XCInICsgbmFtZSArICdcIiB2YWx1ZT1cIicgKyB2YWwgKyAnXCI+PC9wYXJhbT4nO1xuICAgICAgICAgICAgICBlbWJlZCArPSAnICcgKyBuYW1lICsgJz1cIicgKyB2YWwgKyAnXCInO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgKz0gJzxlbWJlZCBzcmM9XCInICsgaHJlZiArICdcIiB0eXBlPVwiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2hcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCInICsgZW1iZWQgKyAnPjwvZW1iZWQ+PC9vYmplY3Q+JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoaXNRdWVyeShjb250ZW50KSAmJiBjb250ZW50LnBhcmVudCgpLmlzKGN1cnJlbnQuaW5uZXIpKSkge1xuICAgICAgICAgIGN1cnJlbnQuaW5uZXIuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2l2ZSBhIGNoYW5jZSBmb3IgaGVscGVycyBvciBjYWxsYmFja3MgdG8gdXBkYXRlIGVsZW1lbnRzXG4gICAgICAgIEYudHJpZ2dlcignYmVmb3JlU2hvdycpO1xuXG4gICAgICAgIC8vIFNldCBzY3JvbGxpbmcgYmVmb3JlIGNhbGN1bGF0aW5nIGRpbWVuc2lvbnNcbiAgICAgICAgY3VycmVudC5pbm5lci5jc3MoJ292ZXJmbG93Jywgc2Nyb2xsaW5nID09PSAneWVzJyA/ICdzY3JvbGwnIDogKHNjcm9sbGluZyA9PT0gJ25vJyA/ICdoaWRkZW4nIDogc2Nyb2xsaW5nKSk7XG5cbiAgICAgICAgLy8gU2V0IGluaXRpYWwgZGltZW5zaW9ucyBhbmQgc3RhcnQgcG9zaXRpb25cbiAgICAgICAgRi5fc2V0RGltZW5zaW9uKCk7XG5cbiAgICAgICAgRi5yZXBvc2l0aW9uKCk7XG5cbiAgICAgICAgRi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgRi5jb21pbmcgPSBudWxsO1xuXG4gICAgICAgIEYuYmluZEV2ZW50cygpO1xuXG4gICAgICAgIGlmICghRi5pc09wZW5lZCkge1xuICAgICAgICAgICQoJy5mYW5jeWJveC13cmFwJykubm90KGN1cnJlbnQud3JhcCkuc3RvcCh0cnVlKS50cmlnZ2VyKCdvblJlc2V0JykucmVtb3ZlKCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91cy5wcmV2TWV0aG9kKSB7XG4gICAgICAgICAgRi50cmFuc2l0aW9uc1twcmV2aW91cy5wcmV2TWV0aG9kXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgRi50cmFuc2l0aW9uc1tGLmlzT3BlbmVkID8gY3VycmVudC5uZXh0TWV0aG9kIDogY3VycmVudC5vcGVuTWV0aG9kXSgpO1xuXG4gICAgICAgIEYuX3ByZWxvYWRJbWFnZXMoKTtcbiAgICAgIH0sXG5cbiAgICAgIF9zZXREaW1lbnNpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gRi5nZXRWaWV3cG9ydCgpLFxuICAgICAgICAgIHN0ZXBzID0gMCxcbiAgICAgICAgICBjYW5TaHJpbmsgPSBmYWxzZSxcbiAgICAgICAgICBjYW5FeHBhbmQgPSBmYWxzZSxcbiAgICAgICAgICB3cmFwID0gRi53cmFwLFxuICAgICAgICAgIHNraW4gPSBGLnNraW4sXG4gICAgICAgICAgaW5uZXIgPSBGLmlubmVyLFxuICAgICAgICAgIGN1cnJlbnQgPSBGLmN1cnJlbnQsXG4gICAgICAgICAgd2lkdGggPSBjdXJyZW50LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGN1cnJlbnQuaGVpZ2h0LFxuICAgICAgICAgIG1pbldpZHRoID0gY3VycmVudC5taW5XaWR0aCxcbiAgICAgICAgICBtaW5IZWlnaHQgPSBjdXJyZW50Lm1pbkhlaWdodCxcbiAgICAgICAgICBtYXhXaWR0aCA9IGN1cnJlbnQubWF4V2lkdGgsXG4gICAgICAgICAgbWF4SGVpZ2h0ID0gY3VycmVudC5tYXhIZWlnaHQsXG4gICAgICAgICAgc2Nyb2xsaW5nID0gY3VycmVudC5zY3JvbGxpbmcsXG4gICAgICAgICAgc2Nyb2xsT3V0ID0gY3VycmVudC5zY3JvbGxPdXRzaWRlID8gY3VycmVudC5zY3JvbGxiYXJXaWR0aCA6IDAsXG4gICAgICAgICAgbWFyZ2luID0gY3VycmVudC5tYXJnaW4sXG4gICAgICAgICAgd01hcmdpbiA9IGdldFNjYWxhcihtYXJnaW5bMV0gKyBtYXJnaW5bM10pLFxuICAgICAgICAgIGhNYXJnaW4gPSBnZXRTY2FsYXIobWFyZ2luWzBdICsgbWFyZ2luWzJdKSxcbiAgICAgICAgICB3UGFkZGluZyxcbiAgICAgICAgICBoUGFkZGluZyxcbiAgICAgICAgICB3U3BhY2UsXG4gICAgICAgICAgaFNwYWNlLFxuICAgICAgICAgIG9yaWdXaWR0aCxcbiAgICAgICAgICBvcmlnSGVpZ2h0LFxuICAgICAgICAgIG9yaWdNYXhXaWR0aCxcbiAgICAgICAgICBvcmlnTWF4SGVpZ2h0LFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIHdpZHRoXyxcbiAgICAgICAgICBoZWlnaHRfLFxuICAgICAgICAgIG1heFdpZHRoXyxcbiAgICAgICAgICBtYXhIZWlnaHRfLFxuICAgICAgICAgIGlmcmFtZSxcbiAgICAgICAgICBib2R5O1xuXG4gICAgICAgIC8vIFJlc2V0IGRpbWVuc2lvbnMgc28gd2UgY291bGQgcmUtY2hlY2sgYWN0dWFsIHNpemVcbiAgICAgICAgd3JhcC5hZGQoc2tpbikuYWRkKGlubmVyKS53aWR0aCgnYXV0bycpLmhlaWdodCgnYXV0bycpLnJlbW92ZUNsYXNzKCdmYW5jeWJveC10bXAnKTtcblxuICAgICAgICB3UGFkZGluZyA9IGdldFNjYWxhcihza2luLm91dGVyV2lkdGgodHJ1ZSkgLSBza2luLndpZHRoKCkpO1xuICAgICAgICBoUGFkZGluZyA9IGdldFNjYWxhcihza2luLm91dGVySGVpZ2h0KHRydWUpIC0gc2tpbi5oZWlnaHQoKSk7XG5cbiAgICAgICAgLy8gQW55IHNwYWNlIGJldHdlZW4gY29udGVudCBhbmQgdmlld3BvcnQgKG1hcmdpbiwgcGFkZGluZywgYm9yZGVyLCB0aXRsZSlcbiAgICAgICAgd1NwYWNlID0gd01hcmdpbiArIHdQYWRkaW5nO1xuICAgICAgICBoU3BhY2UgPSBoTWFyZ2luICsgaFBhZGRpbmc7XG5cbiAgICAgICAgb3JpZ1dpZHRoID0gaXNQZXJjZW50YWdlKHdpZHRoKSA/ICh2aWV3cG9ydC53IC0gd1NwYWNlKSAqIGdldFNjYWxhcih3aWR0aCkgLyAxMDAgOiB3aWR0aDtcbiAgICAgICAgb3JpZ0hlaWdodCA9IGlzUGVyY2VudGFnZShoZWlnaHQpID8gKHZpZXdwb3J0LmggLSBoU3BhY2UpICogZ2V0U2NhbGFyKGhlaWdodCkgLyAxMDAgOiBoZWlnaHQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQudHlwZSA9PT0gJ2lmcmFtZScpIHtcbiAgICAgICAgICBpZnJhbWUgPSBjdXJyZW50LmNvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAoY3VycmVudC5hdXRvSGVpZ2h0ICYmIGlmcmFtZS5kYXRhKCdyZWFkeScpID09PSAxKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoaWZyYW1lWzBdLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpbm5lci53aWR0aChvcmlnV2lkdGgpLmhlaWdodCg5OTk5KTtcblxuICAgICAgICAgICAgICAgIGJvZHkgPSBpZnJhbWUuY29udGVudHMoKS5maW5kKCdib2R5Jyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsT3V0KSB7XG4gICAgICAgICAgICAgICAgICBib2R5LmNzcygnb3ZlcmZsb3cteCcsICdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcmlnSGVpZ2h0ID0gYm9keS5vdXRlckhlaWdodCh0cnVlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50LmF1dG9XaWR0aCB8fCBjdXJyZW50LmF1dG9IZWlnaHQpIHtcbiAgICAgICAgICBpbm5lci5hZGRDbGFzcygnZmFuY3lib3gtdG1wJyk7XG5cbiAgICAgICAgICAvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IGluIGNhc2Ugd2UgbmVlZCB0byBjYWxjdWxhdGUgb25seSBvbmUgZGltZW5zaW9uXG4gICAgICAgICAgaWYgKCFjdXJyZW50LmF1dG9XaWR0aCkge1xuICAgICAgICAgICAgaW5uZXIud2lkdGgob3JpZ1dpZHRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWN1cnJlbnQuYXV0b0hlaWdodCkge1xuICAgICAgICAgICAgaW5uZXIuaGVpZ2h0KG9yaWdIZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50LmF1dG9XaWR0aCkge1xuICAgICAgICAgICAgb3JpZ1dpZHRoID0gaW5uZXIud2lkdGgoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudC5hdXRvSGVpZ2h0KSB7XG4gICAgICAgICAgICBvcmlnSGVpZ2h0ID0gaW5uZXIuaGVpZ2h0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5uZXIucmVtb3ZlQ2xhc3MoJ2ZhbmN5Ym94LXRtcCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2lkdGggPSBnZXRTY2FsYXIob3JpZ1dpZHRoKTtcbiAgICAgICAgaGVpZ2h0ID0gZ2V0U2NhbGFyKG9yaWdIZWlnaHQpO1xuXG4gICAgICAgIHJhdGlvID0gb3JpZ1dpZHRoIC8gb3JpZ0hlaWdodDtcblxuICAgICAgICAvLyBDYWxjdWxhdGlvbnMgZm9yIHRoZSBjb250ZW50XG4gICAgICAgIG1pbldpZHRoID0gZ2V0U2NhbGFyKGlzUGVyY2VudGFnZShtaW5XaWR0aCkgPyBnZXRTY2FsYXIobWluV2lkdGgsICd3JykgLSB3U3BhY2UgOiBtaW5XaWR0aCk7XG4gICAgICAgIG1heFdpZHRoID0gZ2V0U2NhbGFyKGlzUGVyY2VudGFnZShtYXhXaWR0aCkgPyBnZXRTY2FsYXIobWF4V2lkdGgsICd3JykgLSB3U3BhY2UgOiBtYXhXaWR0aCk7XG5cbiAgICAgICAgbWluSGVpZ2h0ID0gZ2V0U2NhbGFyKGlzUGVyY2VudGFnZShtaW5IZWlnaHQpID8gZ2V0U2NhbGFyKG1pbkhlaWdodCwgJ2gnKSAtIGhTcGFjZSA6IG1pbkhlaWdodCk7XG4gICAgICAgIG1heEhlaWdodCA9IGdldFNjYWxhcihpc1BlcmNlbnRhZ2UobWF4SGVpZ2h0KSA/IGdldFNjYWxhcihtYXhIZWlnaHQsICdoJykgLSBoU3BhY2UgOiBtYXhIZWlnaHQpO1xuXG4gICAgICAgIC8vIFRoZXNlIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWYgd3JhcCBjYW4gZml0IGluIHRoZSB2aWV3cG9ydFxuICAgICAgICBvcmlnTWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgb3JpZ01heEhlaWdodCA9IG1heEhlaWdodDtcblxuICAgICAgICBpZiAoY3VycmVudC5maXRUb1ZpZXcpIHtcbiAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKHZpZXdwb3J0LncgLSB3U3BhY2UsIG1heFdpZHRoKTtcbiAgICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1pbih2aWV3cG9ydC5oIC0gaFNwYWNlLCBtYXhIZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF4V2lkdGhfID0gdmlld3BvcnQudyAtIHdNYXJnaW47XG4gICAgICAgIG1heEhlaWdodF8gPSB2aWV3cG9ydC5oIC0gaE1hcmdpbjtcblxuICAgICAgICBpZiAoY3VycmVudC5hc3BlY3RSYXRpbykge1xuICAgICAgICAgIGlmICh3aWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICB3aWR0aCA9IG1heFdpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gZ2V0U2NhbGFyKHdpZHRoIC8gcmF0aW8pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoZWlnaHQgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gZ2V0U2NhbGFyKGhlaWdodCAqIHJhdGlvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod2lkdGggPCBtaW5XaWR0aCkge1xuICAgICAgICAgICAgd2lkdGggPSBtaW5XaWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IGdldFNjYWxhcih3aWR0aCAvIHJhdGlvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGVpZ2h0IDwgbWluSGVpZ2h0KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBtaW5IZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IGdldFNjYWxhcihoZWlnaHQgKiByYXRpbyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2lkdGggPSBNYXRoLm1heChtaW5XaWR0aCwgTWF0aC5taW4od2lkdGgsIG1heFdpZHRoKSk7XG5cbiAgICAgICAgICBpZiAoY3VycmVudC5hdXRvSGVpZ2h0ICYmIGN1cnJlbnQudHlwZSAhPT0gJ2lmcmFtZScpIHtcbiAgICAgICAgICAgIGlubmVyLndpZHRoKHdpZHRoKTtcblxuICAgICAgICAgICAgaGVpZ2h0ID0gaW5uZXIuaGVpZ2h0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgobWluSGVpZ2h0LCBNYXRoLm1pbihoZWlnaHQsIG1heEhlaWdodCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJ5IHRvIGZpdCBpbnNpZGUgdmlld3BvcnQgKGluY2x1ZGluZyB0aGUgdGl0bGUpXG4gICAgICAgIGlmIChjdXJyZW50LmZpdFRvVmlldykge1xuICAgICAgICAgIGlubmVyLndpZHRoKHdpZHRoKS5oZWlnaHQoaGVpZ2h0KTtcblxuICAgICAgICAgIHdyYXAud2lkdGgod2lkdGggKyB3UGFkZGluZyk7XG5cbiAgICAgICAgICAvLyBSZWFsIHdyYXAgZGltZW5zaW9uc1xuICAgICAgICAgIHdpZHRoXyA9IHdyYXAud2lkdGgoKTtcbiAgICAgICAgICBoZWlnaHRfID0gd3JhcC5oZWlnaHQoKTtcblxuICAgICAgICAgIGlmIChjdXJyZW50LmFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICB3aGlsZSAoKHdpZHRoXyA+IG1heFdpZHRoXyB8fCBoZWlnaHRfID4gbWF4SGVpZ2h0XykgJiYgd2lkdGggPiBtaW5XaWR0aCAmJiBoZWlnaHQgPiBtaW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgaWYgKHN0ZXBzKysgPiAxOSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgobWluSGVpZ2h0LCBNYXRoLm1pbihtYXhIZWlnaHQsIGhlaWdodCAtIDEwKSk7XG4gICAgICAgICAgICAgIHdpZHRoID0gZ2V0U2NhbGFyKGhlaWdodCAqIHJhdGlvKTtcblxuICAgICAgICAgICAgICBpZiAod2lkdGggPCBtaW5XaWR0aCkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gbWluV2lkdGg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gZ2V0U2NhbGFyKHdpZHRoIC8gcmF0aW8pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IG1heFdpZHRoO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGdldFNjYWxhcih3aWR0aCAvIHJhdGlvKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlubmVyLndpZHRoKHdpZHRoKS5oZWlnaHQoaGVpZ2h0KTtcblxuICAgICAgICAgICAgICB3cmFwLndpZHRoKHdpZHRoICsgd1BhZGRpbmcpO1xuXG4gICAgICAgICAgICAgIHdpZHRoXyA9IHdyYXAud2lkdGgoKTtcbiAgICAgICAgICAgICAgaGVpZ2h0XyA9IHdyYXAuaGVpZ2h0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1heChtaW5XaWR0aCwgTWF0aC5taW4od2lkdGgsIHdpZHRoIC0gKHdpZHRoXyAtIG1heFdpZHRoXykpKTtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KG1pbkhlaWdodCwgTWF0aC5taW4oaGVpZ2h0LCBoZWlnaHQgLSAoaGVpZ2h0XyAtIG1heEhlaWdodF8pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjcm9sbE91dCAmJiBzY3JvbGxpbmcgPT09ICdhdXRvJyAmJiBoZWlnaHQgPCBvcmlnSGVpZ2h0ICYmICh3aWR0aCArIHdQYWRkaW5nICsgc2Nyb2xsT3V0KSA8IG1heFdpZHRoXykge1xuICAgICAgICAgIHdpZHRoICs9IHNjcm9sbE91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlubmVyLndpZHRoKHdpZHRoKS5oZWlnaHQoaGVpZ2h0KTtcblxuICAgICAgICB3cmFwLndpZHRoKHdpZHRoICsgd1BhZGRpbmcpO1xuXG4gICAgICAgIHdpZHRoXyA9IHdyYXAud2lkdGgoKTtcbiAgICAgICAgaGVpZ2h0XyA9IHdyYXAuaGVpZ2h0KCk7XG5cbiAgICAgICAgY2FuU2hyaW5rID0gKHdpZHRoXyA+IG1heFdpZHRoXyB8fCBoZWlnaHRfID4gbWF4SGVpZ2h0XykgJiYgd2lkdGggPiBtaW5XaWR0aCAmJiBoZWlnaHQgPiBtaW5IZWlnaHQ7XG4gICAgICAgIGNhbkV4cGFuZCA9IGN1cnJlbnQuYXNwZWN0UmF0aW8gPyAod2lkdGggPCBvcmlnTWF4V2lkdGggJiYgaGVpZ2h0IDwgb3JpZ01heEhlaWdodCAmJiB3aWR0aCA8IG9yaWdXaWR0aCAmJiBoZWlnaHQgPCBvcmlnSGVpZ2h0KSA6ICgod2lkdGggPCBvcmlnTWF4V2lkdGggfHwgaGVpZ2h0IDwgb3JpZ01heEhlaWdodCkgJiYgKHdpZHRoIDwgb3JpZ1dpZHRoIHx8IGhlaWdodCA8IG9yaWdIZWlnaHQpKTtcblxuICAgICAgICAkLmV4dGVuZChjdXJyZW50LCB7XG4gICAgICAgICAgZGltOiB7XG4gICAgICAgICAgICB3aWR0aDogZ2V0VmFsdWUod2lkdGhfKSxcbiAgICAgICAgICAgIGhlaWdodDogZ2V0VmFsdWUoaGVpZ2h0XylcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9yaWdXaWR0aDogb3JpZ1dpZHRoLFxuICAgICAgICAgIG9yaWdIZWlnaHQ6IG9yaWdIZWlnaHQsXG4gICAgICAgICAgY2FuU2hyaW5rOiBjYW5TaHJpbmssXG4gICAgICAgICAgY2FuRXhwYW5kOiBjYW5FeHBhbmQsXG4gICAgICAgICAgd1BhZGRpbmc6IHdQYWRkaW5nLFxuICAgICAgICAgIGhQYWRkaW5nOiBoUGFkZGluZyxcbiAgICAgICAgICB3cmFwU3BhY2U6IGhlaWdodF8gLSBza2luLm91dGVySGVpZ2h0KHRydWUpLFxuICAgICAgICAgIHNraW5TcGFjZTogc2tpbi5oZWlnaHQoKSAtIGhlaWdodFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWlmcmFtZSAmJiBjdXJyZW50LmF1dG9IZWlnaHQgJiYgaGVpZ2h0ID4gbWluSGVpZ2h0ICYmIGhlaWdodCA8IG1heEhlaWdodCAmJiAhY2FuRXhwYW5kKSB7XG4gICAgICAgICAgaW5uZXIuaGVpZ2h0KCdhdXRvJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9nZXRQb3NpdGlvbjogZnVuY3Rpb24gKG9ubHlBYnNvbHV0ZSkge1xuICAgICAgICB2YXIgY3VycmVudCA9IEYuY3VycmVudCxcbiAgICAgICAgICB2aWV3cG9ydCA9IEYuZ2V0Vmlld3BvcnQoKSxcbiAgICAgICAgICBtYXJnaW4gPSBjdXJyZW50Lm1hcmdpbixcbiAgICAgICAgICB3aWR0aCA9IEYud3JhcC53aWR0aCgpICsgbWFyZ2luWzFdICsgbWFyZ2luWzNdLFxuICAgICAgICAgIGhlaWdodCA9IEYud3JhcC5oZWlnaHQoKSArIG1hcmdpblswXSArIG1hcmdpblsyXSxcbiAgICAgICAgICByZXogPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHRvcDogbWFyZ2luWzBdLFxuICAgICAgICAgICAgbGVmdDogbWFyZ2luWzNdXG4gICAgICAgICAgfTtcblxuICAgICAgICBpZiAoY3VycmVudC5hdXRvQ2VudGVyICYmIGN1cnJlbnQuZml4ZWQgJiYgIW9ubHlBYnNvbHV0ZSAmJiBoZWlnaHQgPD0gdmlld3BvcnQuaCAmJiB3aWR0aCA8PSB2aWV3cG9ydC53KSB7XG4gICAgICAgICAgcmV6LnBvc2l0aW9uID0gJ2ZpeGVkJztcblxuICAgICAgICB9IGVsc2UgaWYgKCFjdXJyZW50LmxvY2tlZCkge1xuICAgICAgICAgIHJlei50b3AgKz0gdmlld3BvcnQueTtcbiAgICAgICAgICByZXoubGVmdCArPSB2aWV3cG9ydC54O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV6LnRvcCA9IGdldFZhbHVlKE1hdGgubWF4KHJlei50b3AsIHJlei50b3AgKyAoKHZpZXdwb3J0LmggLSBoZWlnaHQpICogY3VycmVudC50b3BSYXRpbykpKTtcbiAgICAgICAgcmV6LmxlZnQgPSBnZXRWYWx1ZShNYXRoLm1heChyZXoubGVmdCwgcmV6LmxlZnQgKyAoKHZpZXdwb3J0LncgLSB3aWR0aCkgKiBjdXJyZW50LmxlZnRSYXRpbykpKTtcblxuICAgICAgICByZXR1cm4gcmV6O1xuICAgICAgfSxcblxuICAgICAgX2FmdGVyWm9vbUluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gRi5jdXJyZW50O1xuXG4gICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIEYuaXNPcGVuID0gRi5pc09wZW5lZCA9IHRydWU7XG5cbiAgICAgICAgRi53cmFwLmNzcygnb3ZlcmZsb3cnLCAndmlzaWJsZScpLmFkZENsYXNzKCdmYW5jeWJveC1vcGVuZWQnKS5oaWRlKCkuc2hvdygwKTtcblxuICAgICAgICBGLnVwZGF0ZSgpO1xuXG4gICAgICAgIC8vIEFzc2lnbiBhIGNsaWNrIGV2ZW50XG4gICAgICAgIGlmIChjdXJyZW50LmNsb3NlQ2xpY2sgfHwgKGN1cnJlbnQubmV4dENsaWNrICYmIEYuZ3JvdXAubGVuZ3RoID4gMSkpIHtcbiAgICAgICAgICBGLmlubmVyLmNzcygnY3Vyc29yJywgJ3BvaW50ZXInKS5iaW5kKCdjbGljay5mYicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoISQoZS50YXJnZXQpLmlzKCdhJykgJiYgISQoZS50YXJnZXQpLnBhcmVudCgpLmlzKCdhJykpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgIEZbY3VycmVudC5jbG9zZUNsaWNrID8gJ2Nsb3NlJyA6ICduZXh0J10oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIGNsb3NlIGJ1dHRvblxuICAgICAgICBpZiAoY3VycmVudC5jbG9zZUJ0bikge1xuICAgICAgICAgICQoY3VycmVudC50cGwuY2xvc2VCdG4pLmFwcGVuZFRvKEYuc2tpbikuYmluZCgnY2xpY2suZmInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBGLmNsb3NlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgbmF2aWdhdGlvbiBhcnJvd3NcbiAgICAgICAgaWYgKGN1cnJlbnQuYXJyb3dzICYmIEYuZ3JvdXAubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGlmIChjdXJyZW50Lmxvb3AgfHwgY3VycmVudC5pbmRleCA+IDApIHtcbiAgICAgICAgICAgICQoY3VycmVudC50cGwucHJldikuYXBwZW5kVG8oRi5vdXRlcikuYmluZCgnY2xpY2suZmInLCBGLnByZXYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50Lmxvb3AgfHwgY3VycmVudC5pbmRleCA8IEYuZ3JvdXAubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgJChjdXJyZW50LnRwbC5uZXh0KS5hcHBlbmRUbyhGLm91dGVyKS5iaW5kKCdjbGljay5mYicsIEYubmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgRi50cmlnZ2VyKCdhZnRlclNob3cnKTtcblxuICAgICAgICAvLyBTdG9wIHRoZSBzbGlkZXNob3cgaWYgdGhpcyBpcyB0aGUgbGFzdCBpdGVtXG4gICAgICAgIGlmICghY3VycmVudC5sb29wICYmIGN1cnJlbnQuaW5kZXggPT09IGN1cnJlbnQuZ3JvdXAubGVuZ3RoIC0gMSkge1xuXG4gICAgICAgICAgRi5wbGF5KGZhbHNlKTtcblxuICAgICAgICB9IGVsc2UgaWYgKEYub3B0cy5hdXRvUGxheSAmJiAhRi5wbGF5ZXIuaXNBY3RpdmUpIHtcbiAgICAgICAgICBGLm9wdHMuYXV0b1BsYXkgPSBmYWxzZTtcblxuICAgICAgICAgIEYucGxheSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2FmdGVyWm9vbU91dDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBvYmogPSBvYmogfHwgRi5jdXJyZW50O1xuXG4gICAgICAgICQoJy5mYW5jeWJveC13cmFwJykudHJpZ2dlcignb25SZXNldCcpLnJlbW92ZSgpO1xuXG4gICAgICAgICQuZXh0ZW5kKEYsIHtcbiAgICAgICAgICBncm91cDoge30sXG4gICAgICAgICAgb3B0czoge30sXG4gICAgICAgICAgcm91dGVyOiBmYWxzZSxcbiAgICAgICAgICBjdXJyZW50OiBudWxsLFxuICAgICAgICAgIGlzQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICBpc09wZW5lZDogZmFsc2UsXG4gICAgICAgICAgaXNPcGVuOiBmYWxzZSxcbiAgICAgICAgICBpc0Nsb3Npbmc6IGZhbHNlLFxuICAgICAgICAgIHdyYXA6IG51bGwsXG4gICAgICAgICAgc2tpbjogbnVsbCxcbiAgICAgICAgICBvdXRlcjogbnVsbCxcbiAgICAgICAgICBpbm5lcjogbnVsbFxuICAgICAgICB9KTtcblxuICAgICAgICBGLnRyaWdnZXIoJ2FmdGVyQ2xvc2UnLCBvYmopO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLypcbiAgICAgKlx0RGVmYXVsdCB0cmFuc2l0aW9uc1xuICAgICAqL1xuXG4gICAgRi50cmFuc2l0aW9ucyA9IHtcbiAgICAgIGdldE9yaWdQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IEYuY3VycmVudCxcbiAgICAgICAgICBlbGVtZW50ID0gY3VycmVudC5lbGVtZW50LFxuICAgICAgICAgIG9yaWcgPSBjdXJyZW50Lm9yaWcsXG4gICAgICAgICAgcG9zID0ge30sXG4gICAgICAgICAgd2lkdGggPSA1MCxcbiAgICAgICAgICBoZWlnaHQgPSA1MCxcbiAgICAgICAgICBoUGFkZGluZyA9IGN1cnJlbnQuaFBhZGRpbmcsXG4gICAgICAgICAgd1BhZGRpbmcgPSBjdXJyZW50LndQYWRkaW5nLFxuICAgICAgICAgIHZpZXdwb3J0ID0gRi5nZXRWaWV3cG9ydCgpO1xuXG4gICAgICAgIGlmICghb3JpZyAmJiBjdXJyZW50LmlzRG9tICYmIGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICBvcmlnID0gZWxlbWVudC5maW5kKCdpbWc6Zmlyc3QnKTtcblxuICAgICAgICAgIGlmICghb3JpZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9yaWcgPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1F1ZXJ5KG9yaWcpKSB7XG4gICAgICAgICAgcG9zID0gb3JpZy5vZmZzZXQoKTtcblxuICAgICAgICAgIGlmIChvcmlnLmlzKCdpbWcnKSkge1xuICAgICAgICAgICAgd2lkdGggPSBvcmlnLm91dGVyV2lkdGgoKTtcbiAgICAgICAgICAgIGhlaWdodCA9IG9yaWcub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3MudG9wID0gdmlld3BvcnQueSArICh2aWV3cG9ydC5oIC0gaGVpZ2h0KSAqIGN1cnJlbnQudG9wUmF0aW87XG4gICAgICAgICAgcG9zLmxlZnQgPSB2aWV3cG9ydC54ICsgKHZpZXdwb3J0LncgLSB3aWR0aCkgKiBjdXJyZW50LmxlZnRSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChGLndyYXAuY3NzKCdwb3NpdGlvbicpID09PSAnZml4ZWQnIHx8IGN1cnJlbnQubG9ja2VkKSB7XG4gICAgICAgICAgcG9zLnRvcCAtPSB2aWV3cG9ydC55O1xuICAgICAgICAgIHBvcy5sZWZ0IC09IHZpZXdwb3J0Lng7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MgPSB7XG4gICAgICAgICAgdG9wOiBnZXRWYWx1ZShwb3MudG9wIC0gaFBhZGRpbmcgKiBjdXJyZW50LnRvcFJhdGlvKSxcbiAgICAgICAgICBsZWZ0OiBnZXRWYWx1ZShwb3MubGVmdCAtIHdQYWRkaW5nICogY3VycmVudC5sZWZ0UmF0aW8pLFxuICAgICAgICAgIHdpZHRoOiBnZXRWYWx1ZSh3aWR0aCArIHdQYWRkaW5nKSxcbiAgICAgICAgICBoZWlnaHQ6IGdldFZhbHVlKGhlaWdodCArIGhQYWRkaW5nKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9LFxuXG4gICAgICBzdGVwOiBmdW5jdGlvbiAobm93LCBmeCkge1xuICAgICAgICB2YXIgcmF0aW8sXG4gICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBwcm9wID0gZngucHJvcCxcbiAgICAgICAgICBjdXJyZW50ID0gRi5jdXJyZW50LFxuICAgICAgICAgIHdyYXBTcGFjZSA9IGN1cnJlbnQud3JhcFNwYWNlLFxuICAgICAgICAgIHNraW5TcGFjZSA9IGN1cnJlbnQuc2tpblNwYWNlO1xuXG4gICAgICAgIGlmIChwcm9wID09PSAnd2lkdGgnIHx8IHByb3AgPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgcmF0aW8gPSBmeC5lbmQgPT09IGZ4LnN0YXJ0ID8gMSA6IChub3cgLSBmeC5zdGFydCkgLyAoZnguZW5kIC0gZnguc3RhcnQpO1xuXG4gICAgICAgICAgaWYgKEYuaXNDbG9zaW5nKSB7XG4gICAgICAgICAgICByYXRpbyA9IDEgLSByYXRpbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYWRkaW5nID0gcHJvcCA9PT0gJ3dpZHRoJyA/IGN1cnJlbnQud1BhZGRpbmcgOiBjdXJyZW50LmhQYWRkaW5nO1xuICAgICAgICAgIHZhbHVlID0gbm93IC0gcGFkZGluZztcblxuICAgICAgICAgIEYuc2tpbltwcm9wXShnZXRTY2FsYXIocHJvcCA9PT0gJ3dpZHRoJyA/IHZhbHVlIDogdmFsdWUgLSAod3JhcFNwYWNlICogcmF0aW8pKSk7XG4gICAgICAgICAgRi5pbm5lcltwcm9wXShnZXRTY2FsYXIocHJvcCA9PT0gJ3dpZHRoJyA/IHZhbHVlIDogdmFsdWUgLSAod3JhcFNwYWNlICogcmF0aW8pIC0gKHNraW5TcGFjZSAqIHJhdGlvKSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB6b29tSW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBGLmN1cnJlbnQsXG4gICAgICAgICAgc3RhcnRQb3MgPSBjdXJyZW50LnBvcyxcbiAgICAgICAgICBlZmZlY3QgPSBjdXJyZW50Lm9wZW5FZmZlY3QsXG4gICAgICAgICAgZWxhc3RpYyA9IGVmZmVjdCA9PT0gJ2VsYXN0aWMnLFxuICAgICAgICAgIGVuZFBvcyA9ICQuZXh0ZW5kKHsgb3BhY2l0eTogMSB9LCBzdGFydFBvcyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIFwicG9zaXRpb25cIiBwcm9wZXJ0eSB0aGF0IGJyZWFrcyBvbGRlciBJRVxuICAgICAgICBkZWxldGUgZW5kUG9zLnBvc2l0aW9uO1xuXG4gICAgICAgIGlmIChlbGFzdGljKSB7XG4gICAgICAgICAgc3RhcnRQb3MgPSB0aGlzLmdldE9yaWdQb3NpdGlvbigpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQub3Blbk9wYWNpdHkpIHtcbiAgICAgICAgICAgIHN0YXJ0UG9zLm9wYWNpdHkgPSAwLjE7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoZWZmZWN0ID09PSAnZmFkZScpIHtcbiAgICAgICAgICBzdGFydFBvcy5vcGFjaXR5ID0gMC4xO1xuICAgICAgICB9XG5cbiAgICAgICAgRi53cmFwLmNzcyhzdGFydFBvcykuYW5pbWF0ZShlbmRQb3MsIHtcbiAgICAgICAgICBkdXJhdGlvbjogZWZmZWN0ID09PSAnbm9uZScgPyAwIDogY3VycmVudC5vcGVuU3BlZWQsXG4gICAgICAgICAgZWFzaW5nOiBjdXJyZW50Lm9wZW5FYXNpbmcsXG4gICAgICAgICAgc3RlcDogZWxhc3RpYyA/IHRoaXMuc3RlcCA6IG51bGwsXG4gICAgICAgICAgY29tcGxldGU6IEYuX2FmdGVyWm9vbUluXG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgem9vbU91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IEYuY3VycmVudCxcbiAgICAgICAgICBlZmZlY3QgPSBjdXJyZW50LmNsb3NlRWZmZWN0LFxuICAgICAgICAgIGVsYXN0aWMgPSBlZmZlY3QgPT09ICdlbGFzdGljJyxcbiAgICAgICAgICBlbmRQb3MgPSB7IG9wYWNpdHk6IDAuMSB9O1xuXG4gICAgICAgIGlmIChlbGFzdGljKSB7XG4gICAgICAgICAgZW5kUG9zID0gdGhpcy5nZXRPcmlnUG9zaXRpb24oKTtcblxuICAgICAgICAgIGlmIChjdXJyZW50LmNsb3NlT3BhY2l0eSkge1xuICAgICAgICAgICAgZW5kUG9zLm9wYWNpdHkgPSAwLjE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgRi53cmFwLmFuaW1hdGUoZW5kUG9zLCB7XG4gICAgICAgICAgZHVyYXRpb246IGVmZmVjdCA9PT0gJ25vbmUnID8gMCA6IGN1cnJlbnQuY2xvc2VTcGVlZCxcbiAgICAgICAgICBlYXNpbmc6IGN1cnJlbnQuY2xvc2VFYXNpbmcsXG4gICAgICAgICAgc3RlcDogZWxhc3RpYyA/IHRoaXMuc3RlcCA6IG51bGwsXG4gICAgICAgICAgY29tcGxldGU6IEYuX2FmdGVyWm9vbU91dFxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIGNoYW5nZUluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gRi5jdXJyZW50LFxuICAgICAgICAgIGVmZmVjdCA9IGN1cnJlbnQubmV4dEVmZmVjdCxcbiAgICAgICAgICBzdGFydFBvcyA9IGN1cnJlbnQucG9zLFxuICAgICAgICAgIGVuZFBvcyA9IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgIGRpcmVjdGlvbiA9IEYuZGlyZWN0aW9uLFxuICAgICAgICAgIGRpc3RhbmNlID0gMjAwLFxuICAgICAgICAgIGZpZWxkO1xuXG4gICAgICAgIHN0YXJ0UG9zLm9wYWNpdHkgPSAwLjE7XG5cbiAgICAgICAgaWYgKGVmZmVjdCA9PT0gJ2VsYXN0aWMnKSB7XG4gICAgICAgICAgZmllbGQgPSBkaXJlY3Rpb24gPT09ICdkb3duJyB8fCBkaXJlY3Rpb24gPT09ICd1cCcgPyAndG9wJyA6ICdsZWZ0JztcblxuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHN0YXJ0UG9zW2ZpZWxkXSA9IGdldFZhbHVlKGdldFNjYWxhcihzdGFydFBvc1tmaWVsZF0pIC0gZGlzdGFuY2UpO1xuICAgICAgICAgICAgZW5kUG9zW2ZpZWxkXSA9ICcrPScgKyBkaXN0YW5jZSArICdweCc7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRQb3NbZmllbGRdID0gZ2V0VmFsdWUoZ2V0U2NhbGFyKHN0YXJ0UG9zW2ZpZWxkXSkgKyBkaXN0YW5jZSk7XG4gICAgICAgICAgICBlbmRQb3NbZmllbGRdID0gJy09JyArIGRpc3RhbmNlICsgJ3B4JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjI3M1xuICAgICAgICBpZiAoZWZmZWN0ID09PSAnbm9uZScpIHtcbiAgICAgICAgICBGLl9hZnRlclpvb21JbigpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRi53cmFwLmNzcyhzdGFydFBvcykuYW5pbWF0ZShlbmRQb3MsIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBjdXJyZW50Lm5leHRTcGVlZCxcbiAgICAgICAgICAgIGVhc2luZzogY3VycmVudC5uZXh0RWFzaW5nLFxuICAgICAgICAgICAgY29tcGxldGU6IEYuX2FmdGVyWm9vbUluXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNoYW5nZU91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldmlvdXMgPSBGLnByZXZpb3VzLFxuICAgICAgICAgIGVmZmVjdCA9IHByZXZpb3VzLnByZXZFZmZlY3QsXG4gICAgICAgICAgZW5kUG9zID0geyBvcGFjaXR5OiAwLjEgfSxcbiAgICAgICAgICBkaXJlY3Rpb24gPSBGLmRpcmVjdGlvbixcbiAgICAgICAgICBkaXN0YW5jZSA9IDIwMDtcblxuICAgICAgICBpZiAoZWZmZWN0ID09PSAnZWxhc3RpYycpIHtcbiAgICAgICAgICBlbmRQb3NbZGlyZWN0aW9uID09PSAnZG93bicgfHwgZGlyZWN0aW9uID09PSAndXAnID8gJ3RvcCcgOiAnbGVmdCddID0gKGRpcmVjdGlvbiA9PT0gJ3VwJyB8fCBkaXJlY3Rpb24gPT09ICdsZWZ0JyA/ICctJyA6ICcrJykgKyAnPScgKyBkaXN0YW5jZSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91cy53cmFwLmFuaW1hdGUoZW5kUG9zLCB7XG4gICAgICAgICAgZHVyYXRpb246IGVmZmVjdCA9PT0gJ25vbmUnID8gMCA6IHByZXZpb3VzLnByZXZTcGVlZCxcbiAgICAgICAgICBlYXNpbmc6IHByZXZpb3VzLnByZXZFYXNpbmcsXG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQodGhpcykudHJpZ2dlcignb25SZXNldCcpLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgICpcdE92ZXJsYXkgaGVscGVyXG4gICAgICovXG5cbiAgICBGLmhlbHBlcnMub3ZlcmxheSA9IHtcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGNsb3NlQ2xpY2s6IHRydWUsICAgICAgLy8gaWYgdHJ1ZSwgZmFuY3lCb3ggd2lsbCBiZSBjbG9zZWQgd2hlbiB1c2VyIGNsaWNrcyBvbiB0aGUgb3ZlcmxheVxuICAgICAgICBzcGVlZE91dDogMjAwLCAgICAgICAvLyBkdXJhdGlvbiBvZiBmYWRlT3V0IGFuaW1hdGlvblxuICAgICAgICBzaG93RWFybHk6IHRydWUsICAgICAgLy8gaW5kaWNhdGVzIGlmIHNob3VsZCBiZSBvcGVuZWQgaW1tZWRpYXRlbHkgb3Igd2FpdCB1bnRpbCB0aGUgY29udGVudCBpcyByZWFkeVxuICAgICAgICBjc3M6IHt9LCAgICAgICAgLy8gY3VzdG9tIENTUyBwcm9wZXJ0aWVzXG4gICAgICAgIGxvY2tlZDogIWlzVG91Y2gsICAvLyBpZiB0cnVlLCB0aGUgY29udGVudCB3aWxsIGJlIGxvY2tlZCBpbnRvIG92ZXJsYXlcbiAgICAgICAgZml4ZWQ6IHRydWUgICAgICAgLy8gaWYgZmFsc2UsIHRoZSBvdmVybGF5IENTUyBwb3NpdGlvbiBwcm9wZXJ0eSB3aWxsIG5vdCBiZSBzZXQgdG8gXCJmaXhlZFwiXG4gICAgICB9LFxuXG4gICAgICBvdmVybGF5OiBudWxsLCAgICAgIC8vIGN1cnJlbnQgaGFuZGxlXG4gICAgICBmaXhlZDogZmFsc2UsICAgICAvLyBpbmRpY2F0ZXMgaWYgdGhlIG92ZXJsYXkgaGFzIHBvc2l0aW9uIFwiZml4ZWRcIlxuICAgICAgZWw6ICQoJ2h0bWwnKSwgLy8gZWxlbWVudCB0aGF0IGNvbnRhaW5zIFwidGhlIGxvY2tcIlxuXG4gICAgICAvLyBQdWJsaWMgbWV0aG9kc1xuICAgICAgY3JlYXRlOiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICB2YXIgcGFyZW50O1xuXG4gICAgICAgIG9wdHMgPSAkLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0cywgb3B0cyk7XG5cbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheSkge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudCA9IEYuY29taW5nID8gRi5jb21pbmcucGFyZW50IDogb3B0cy5wYXJlbnQ7XG5cbiAgICAgICAgdGhpcy5vdmVybGF5ID0gJCgnPGRpdiBjbGFzcz1cImZhbmN5Ym94LW92ZXJsYXlcIj48L2Rpdj4nKS5hcHBlbmRUbyhwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA/IHBhcmVudCA6ICdib2R5Jyk7XG4gICAgICAgIHRoaXMuZml4ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAob3B0cy5maXhlZCAmJiBGLmRlZmF1bHRzLmZpeGVkKSB7XG4gICAgICAgICAgdGhpcy5vdmVybGF5LmFkZENsYXNzKCdmYW5jeWJveC1vdmVybGF5LWZpeGVkJyk7XG5cbiAgICAgICAgICB0aGlzLmZpeGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb3BlbjogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIG9wdHMgPSAkLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0cywgb3B0cyk7XG5cbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheSkge1xuICAgICAgICAgIHRoaXMub3ZlcmxheS51bmJpbmQoJy5vdmVybGF5Jykud2lkdGgoJ2F1dG8nKS5oZWlnaHQoJ2F1dG8nKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY3JlYXRlKG9wdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmZpeGVkKSB7XG4gICAgICAgICAgVy5iaW5kKCdyZXNpemUub3ZlcmxheScsICQucHJveHkodGhpcy51cGRhdGUsIHRoaXMpKTtcblxuICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5jbG9zZUNsaWNrKSB7XG4gICAgICAgICAgdGhpcy5vdmVybGF5LmJpbmQoJ2NsaWNrLm92ZXJsYXknLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCQoZS50YXJnZXQpLmhhc0NsYXNzKCdmYW5jeWJveC1vdmVybGF5JykpIHtcbiAgICAgICAgICAgICAgaWYgKEYuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBGLmNsb3NlKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhhdC5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdmVybGF5LmNzcyhvcHRzLmNzcykuc2hvdygpO1xuICAgICAgfSxcblxuICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVy51bmJpbmQoJ3Jlc2l6ZS5vdmVybGF5Jyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZWwuaGFzQ2xhc3MoJ2ZhbmN5Ym94LWxvY2snKSkge1xuICAgICAgICAgICQoJy5mYW5jeWJveC1tYXJnaW4nKS5yZW1vdmVDbGFzcygnZmFuY3lib3gtbWFyZ2luJyk7XG5cbiAgICAgICAgICB0aGlzLmVsLnJlbW92ZUNsYXNzKCdmYW5jeWJveC1sb2NrJyk7XG5cbiAgICAgICAgICBXLnNjcm9sbFRvcCh0aGlzLnNjcm9sbFYpLnNjcm9sbExlZnQodGhpcy5zY3JvbGxIKTtcbiAgICAgICAgfVxuXG4gICAgICAgICQoJy5mYW5jeWJveC1vdmVybGF5JykucmVtb3ZlKCkuaGlkZSgpO1xuXG4gICAgICAgICQuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgIGZpeGVkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIFByaXZhdGUsIGNhbGxiYWNrc1xuXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gJzEwMCUnLCBvZmZzZXRXaWR0aDtcblxuICAgICAgICAvLyBSZXNldCB3aWR0aC9oZWlnaHQgc28gaXQgd2lsbCBub3QgbWVzc1xuICAgICAgICB0aGlzLm92ZXJsYXkud2lkdGgod2lkdGgpLmhlaWdodCgnMTAwJScpO1xuXG4gICAgICAgIC8vIGpRdWVyeSBkb2VzIG5vdCByZXR1cm4gcmVsaWFibGUgcmVzdWx0IGZvciBJRVxuICAgICAgICBpZiAoSUUpIHtcbiAgICAgICAgICBvZmZzZXRXaWR0aCA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aCwgZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCk7XG5cbiAgICAgICAgICBpZiAoRC53aWR0aCgpID4gb2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gRC53aWR0aCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKEQud2lkdGgoKSA+IFcud2lkdGgoKSkge1xuICAgICAgICAgIHdpZHRoID0gRC53aWR0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdmVybGF5LndpZHRoKHdpZHRoKS5oZWlnaHQoRC5oZWlnaHQoKSk7XG4gICAgICB9LFxuXG4gICAgICAvLyBUaGlzIGlzIHdoZXJlIHdlIGNhbiBtYW5pcHVsYXRlIERPTSwgYmVjYXVzZSBsYXRlciBpdCB3b3VsZCBjYXVzZSBpZnJhbWVzIHRvIHJlbG9hZFxuICAgICAgb25SZWFkeTogZnVuY3Rpb24gKG9wdHMsIG9iaikge1xuICAgICAgICB2YXIgb3ZlcmxheSA9IHRoaXMub3ZlcmxheTtcblxuICAgICAgICAkKCcuZmFuY3lib3gtb3ZlcmxheScpLnN0b3AodHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKCFvdmVybGF5KSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGUob3B0cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5sb2NrZWQgJiYgdGhpcy5maXhlZCAmJiBvYmouZml4ZWQpIHtcbiAgICAgICAgICBvYmoubG9ja2VkID0gdGhpcy5vdmVybGF5LmFwcGVuZChvYmoud3JhcCk7XG4gICAgICAgICAgb2JqLmZpeGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5zaG93RWFybHkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJlZm9yZVNob3cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgYmVmb3JlU2hvdzogZnVuY3Rpb24gKG9wdHMsIG9iaikge1xuICAgICAgICBpZiAob2JqLmxvY2tlZCAmJiAhdGhpcy5lbC5oYXNDbGFzcygnZmFuY3lib3gtbG9jaycpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZml4UG9zaXRpb24gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAkKCcqJykuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICgkKHRoaXMpLmNzcygncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJyAmJiAhJCh0aGlzKS5oYXNDbGFzcyhcImZhbmN5Ym94LW92ZXJsYXlcIikgJiYgISQodGhpcykuaGFzQ2xhc3MoXCJmYW5jeWJveC13cmFwXCIpKTtcbiAgICAgICAgICAgIH0pLmFkZENsYXNzKCdmYW5jeWJveC1tYXJnaW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmVsLmFkZENsYXNzKCdmYW5jeWJveC1tYXJnaW4nKTtcblxuICAgICAgICAgIHRoaXMuc2Nyb2xsViA9IFcuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgdGhpcy5zY3JvbGxIID0gVy5zY3JvbGxMZWZ0KCk7XG5cbiAgICAgICAgICB0aGlzLmVsLmFkZENsYXNzKCdmYW5jeWJveC1sb2NrJyk7XG5cbiAgICAgICAgICBXLnNjcm9sbFRvcCh0aGlzLnNjcm9sbFYpLnNjcm9sbExlZnQodGhpcy5zY3JvbGxIKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3BlbihvcHRzKTtcbiAgICAgIH0sXG5cbiAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5maXhlZCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGFmdGVyQ2xvc2U6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBvdmVybGF5IGlmIGV4aXN0cyBhbmQgZmFuY3lCb3ggaXMgbm90IG9wZW5pbmdcbiAgICAgICAgLy8gKGUuZy4sIGl0IGlzIG5vdCBiZWluZyBvcGVuIHVzaW5nIGFmdGVyQ2xvc2UgY2FsbGJhY2spXG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXkgJiYgIUYuY29taW5nKSB7XG4gICAgICAgICAgdGhpcy5vdmVybGF5LmZhZGVPdXQob3B0cy5zcGVlZE91dCwgJC5wcm94eSh0aGlzLmNsb3NlLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICAgKlx0VGl0bGUgaGVscGVyXG4gICAgICovXG5cbiAgICBGLmhlbHBlcnMudGl0bGUgPSB7XG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICB0eXBlOiAnZmxvYXQnLCAvLyAnZmxvYXQnLCAnaW5zaWRlJywgJ291dHNpZGUnIG9yICdvdmVyJyxcbiAgICAgICAgcG9zaXRpb246ICdib3R0b20nIC8vICd0b3AnIG9yICdib3R0b20nXG4gICAgICB9LFxuXG4gICAgICBiZWZvcmVTaG93OiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICB2YXIgY3VycmVudCA9IEYuY3VycmVudCxcbiAgICAgICAgICB0ZXh0ID0gY3VycmVudC50aXRsZSxcbiAgICAgICAgICB0eXBlID0gb3B0cy50eXBlLFxuICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgIHRhcmdldDtcblxuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuY2FsbChjdXJyZW50LmVsZW1lbnQsIGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyh0ZXh0KSB8fCAkLnRyaW0odGV4dCkgPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGl0bGUgPSAkKCc8ZGl2IGNsYXNzPVwiZmFuY3lib3gtdGl0bGUgZmFuY3lib3gtdGl0bGUtJyArIHR5cGUgKyAnLXdyYXBcIj4nICsgdGV4dCArICc8L2Rpdj4nKTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgICAgICAgdGFyZ2V0ID0gRi5za2luO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdvdXRzaWRlJzpcbiAgICAgICAgICAgIHRhcmdldCA9IEYud3JhcDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnb3Zlcic6XG4gICAgICAgICAgICB0YXJnZXQgPSBGLmlubmVyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OiAvLyAnZmxvYXQnXG4gICAgICAgICAgICB0YXJnZXQgPSBGLnNraW47XG5cbiAgICAgICAgICAgIHRpdGxlLmFwcGVuZFRvKCdib2R5Jyk7XG5cbiAgICAgICAgICAgIGlmIChJRSkge1xuICAgICAgICAgICAgICB0aXRsZS53aWR0aCh0aXRsZS53aWR0aCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGl0bGUud3JhcElubmVyKCc8c3BhbiBjbGFzcz1cImNoaWxkXCI+PC9zcGFuPicpO1xuXG4gICAgICAgICAgICAvL0luY3JlYXNlIGJvdHRvbSBtYXJnaW4gc28gdGhpcyB0aXRsZSB3aWxsIGFsc28gZml0IGludG8gdmlld3BvcnRcbiAgICAgICAgICAgIEYuY3VycmVudC5tYXJnaW5bMl0gKz0gTWF0aC5hYnMoZ2V0U2NhbGFyKHRpdGxlLmNzcygnbWFyZ2luLWJvdHRvbScpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRpdGxlWyhvcHRzLnBvc2l0aW9uID09PSAndG9wJyA/ICdwcmVwZW5kVG8nIDogJ2FwcGVuZFRvJyldKHRhcmdldCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGpRdWVyeSBwbHVnaW4gaW5pdGlhbGl6YXRpb25cbiAgICAkLmZuLmZhbmN5Ym94ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbmRleCxcbiAgICAgICAgdGhhdCA9ICQodGhpcyksXG4gICAgICAgIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciB8fCAnJyxcbiAgICAgICAgcnVuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgd2hhdCA9ICQodGhpcykuYmx1cigpLCBpZHggPSBpbmRleCwgcmVsVHlwZSwgcmVsVmFsO1xuXG4gICAgICAgICAgaWYgKCEoZS5jdHJsS2V5IHx8IGUuYWx0S2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5KSAmJiAhd2hhdC5pcygnLmZhbmN5Ym94LXdyYXAnKSkge1xuICAgICAgICAgICAgcmVsVHlwZSA9IG9wdGlvbnMuZ3JvdXBBdHRyIHx8ICdkYXRhLWZhbmN5Ym94LWdyb3VwJztcbiAgICAgICAgICAgIHJlbFZhbCA9IHdoYXQuYXR0cihyZWxUeXBlKTtcblxuICAgICAgICAgICAgaWYgKCFyZWxWYWwpIHtcbiAgICAgICAgICAgICAgcmVsVHlwZSA9ICdyZWwnO1xuICAgICAgICAgICAgICByZWxWYWwgPSB3aGF0LmdldCgwKVtyZWxUeXBlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbFZhbCAmJiByZWxWYWwgIT09ICcnICYmIHJlbFZhbCAhPT0gJ25vZm9sbG93Jykge1xuICAgICAgICAgICAgICB3aGF0ID0gc2VsZWN0b3IubGVuZ3RoID8gJChzZWxlY3RvcikgOiB0aGF0O1xuICAgICAgICAgICAgICB3aGF0ID0gd2hhdC5maWx0ZXIoJ1snICsgcmVsVHlwZSArICc9XCInICsgcmVsVmFsICsgJ1wiXScpO1xuICAgICAgICAgICAgICBpZHggPSB3aGF0LmluZGV4KHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRpb25zLmluZGV4ID0gaWR4O1xuXG4gICAgICAgICAgICAvLyBTdG9wIGFuIGV2ZW50IGZyb20gYnViYmxpbmcgaWYgZXZlcnl0aGluZyBpcyBmaW5lXG4gICAgICAgICAgICBpZiAoRi5vcGVuKHdoYXQsIG9wdGlvbnMpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIGluZGV4ID0gb3B0aW9ucy5pbmRleCB8fCAwO1xuXG4gICAgICBpZiAoIXNlbGVjdG9yIHx8IG9wdGlvbnMubGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhhdC51bmJpbmQoJ2NsaWNrLmZiLXN0YXJ0JykuYmluZCgnY2xpY2suZmItc3RhcnQnLCBydW4pO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBELnVuZGVsZWdhdGUoc2VsZWN0b3IsICdjbGljay5mYi1zdGFydCcpLmRlbGVnYXRlKHNlbGVjdG9yICsgXCI6bm90KCcuZmFuY3lib3gtaXRlbSwgLmZhbmN5Ym94LW5hdicpXCIsICdjbGljay5mYi1zdGFydCcsIHJ1bik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmlsdGVyKCdbZGF0YS1mYW5jeWJveC1zdGFydD0xXScpLnRyaWdnZXIoJ2NsaWNrJyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBUZXN0cyB0aGF0IG5lZWQgYSBib2R5IGF0IGRvYyByZWFkeVxuICAgIEQucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHcxLCB3MjtcblxuICAgICAgaWYgKCQuc2Nyb2xsYmFyV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBodHRwOi8vYmVuYWxtYW4uY29tL3Byb2plY3RzL2pxdWVyeS1taXNjLXBsdWdpbnMvI3Njcm9sbGJhcndpZHRoXG4gICAgICAgICQuc2Nyb2xsYmFyV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9ICQoJzxkaXYgc3R5bGU9XCJ3aWR0aDo1MHB4O2hlaWdodDo1MHB4O292ZXJmbG93OmF1dG9cIj48ZGl2Lz48L2Rpdj4nKS5hcHBlbmRUbygnYm9keScpLFxuICAgICAgICAgICAgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW4oKSxcbiAgICAgICAgICAgIHdpZHRoID0gY2hpbGQuaW5uZXJXaWR0aCgpIC0gY2hpbGQuaGVpZ2h0KDk5KS5pbm5lcldpZHRoKCk7XG5cbiAgICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG5cbiAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICgkLnN1cHBvcnQuZml4ZWRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICQuc3VwcG9ydC5maXhlZFBvc2l0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZWxlbSA9ICQoJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjpmaXhlZDt0b3A6MjBweDtcIj48L2Rpdj4nKS5hcHBlbmRUbygnYm9keScpLFxuICAgICAgICAgICAgZml4ZWQgPSAoZWxlbVswXS5vZmZzZXRUb3AgPT09IDIwIHx8IGVsZW1bMF0ub2Zmc2V0VG9wID09PSAxNSk7XG5cbiAgICAgICAgICBlbGVtLnJlbW92ZSgpO1xuXG4gICAgICAgICAgcmV0dXJuIGZpeGVkO1xuICAgICAgICB9KCkpO1xuICAgICAgfVxuXG4gICAgICAkLmV4dGVuZChGLmRlZmF1bHRzLCB7XG4gICAgICAgIHNjcm9sbGJhcldpZHRoOiAkLnNjcm9sbGJhcldpZHRoKCksXG4gICAgICAgIGZpeGVkOiAkLnN1cHBvcnQuZml4ZWRQb3NpdGlvbixcbiAgICAgICAgcGFyZW50OiAkKCdib2R5JylcbiAgICAgIH0pO1xuXG4gICAgICAvL0dldCByZWFsIHdpZHRoIG9mIHBhZ2Ugc2Nyb2xsLWJhclxuICAgICAgdzEgPSAkKHdpbmRvdykud2lkdGgoKTtcblxuICAgICAgSC5hZGRDbGFzcygnZmFuY3lib3gtbG9jay10ZXN0Jyk7XG5cbiAgICAgIHcyID0gJCh3aW5kb3cpLndpZHRoKCk7XG5cbiAgICAgIEgucmVtb3ZlQ2xhc3MoJ2ZhbmN5Ym94LWxvY2stdGVzdCcpO1xuXG4gICAgICAkKFwiPHN0eWxlIHR5cGU9J3RleHQvY3NzJz4uZmFuY3lib3gtbWFyZ2lue21hcmdpbi1yaWdodDpcIiArICh3MiAtIHcxKSArIFwicHg7fTwvc3R5bGU+XCIpLmFwcGVuZFRvKFwiaGVhZFwiKTtcbiAgICB9KTtcblxuICB9KHdpbmRvdywgZG9jdW1lbnQsIGpRdWVyeSkpO1xufSkoKTtcbiIsIihmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IG1lc3VyZXdpZHRoID0gaXRlbSA9PiB7XG4gICAgbGV0IHJlcUl0ZW1XaWR0aCA9IDA7XG5cbiAgICBjb25zdCBzY3JlZW5XaWR0aCA9ICQod2luZG93KS53aWR0aCgpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGl0ZW0uY2xvc2VzdChcIi5jYXRhbG9nc19fbGlzdFwiKTtcbiAgICBjb25zdCB0aXRsZUJsb2NrcyA9IGNvbnRhaW5lci5maW5kKFwiLmNhdGFsb2dzX19idG5cIik7XG4gICAgY29uc3QgdGl0bGVXaWR0aCA9IHRpdGxlQmxvY2tzLndpZHRoKCkgKiB0aXRsZUJsb2Nrcy5sZW5ndGg7XG5cbiAgICBjb25zdCB0ZXh0Q29udGFpbmVyID0gaXRlbS5maW5kKFwiLmNhdGFsb2dzX19jb250YWluZXJcIik7XG4gICAgY29uc3QgcGFkZGluZ0xlZnQgPSBwYXJzZUludCh0ZXh0Q29udGFpbmVyLmNzcyhcInBhZGRpbmctbGVmdFwiKSk7XG4gICAgY29uc3QgcGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQodGV4dENvbnRhaW5lci5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpKTtcblxuICAgIGNvbnN0IGlzTW9iaWxlID0gd2luZG93Lm1hdGNoTWVkaWEoXCIobWF4LXdpZHRoOiA3NjhweClcIikubWF0Y2hlcztcblxuICAgIGlmIChpc01vYmlsZSkge1xuICAgICAgcmVxSXRlbVdpZHRoID0gc2NyZWVuV2lkdGggLSB0aXRsZVdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXFJdGVtV2lkdGggPSA1MDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRhaW5lcjogcmVxSXRlbVdpZHRoLFxuICAgICAgdGV4dENvbnRhaW5lcjogcmVxSXRlbVdpZHRoIC0gcGFkZGluZ1JpZ2h0IC0gcGFkZGluZ0xlZnRcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY2xvc2VFdmVyeUl0ZW1Db250YWluZXIgPSBjb250YWluZXIgPT4ge1xuICAgIGNvbnN0IGl0ZW1zID0gY29udGFpbmVyLmZpbmQoXCIuY2F0YWxvZ3NfX2l0ZW1cIik7XG4gICAgY29uc3QgY29udGVudCA9IGNvbnRhaW5lci5maW5kKFwiLmNhdGFsb2dzX19jb250ZW50XCIpO1xuXG4gICAgaXRlbXMucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgY29udGVudC53aWR0aCgwKTtcbiAgfVxuXG4gIGNvbnN0IG9wZW5JdGVtID0gKGl0ZW0pID0+IHtcbiAgICBjb25zdCBoaWRkZW5Db250ZW50ID0gaXRlbS5maW5kKFwiLmNhdGFsb2dzX19jb250ZW50XCIpO1xuICAgIGNvbnN0IHJlcVdpZHRoID0gbWVzdXJld2lkdGgoaXRlbSk7XG4gICAgY29uc3QgdGV4dEJsb2NrID0gaXRlbS5maW5kKFwiLmNhdGFsb2dzX19jb250YWluZXJcIik7XG5cbiAgICBpdGVtLmFkZENsYXNzKFwiYWN0aXZlXCIpO1xuICAgIGhpZGRlbkNvbnRlbnQud2lkdGgocmVxV2lkdGguY29udGFpbmVyKTtcbiAgICB0ZXh0QmxvY2sud2lkdGgocmVxV2lkdGgudGV4dENvbnRhaW5lcik7XG4gIH07XG5cbiAgJChcIi5jYXRhbG9nc19fYnRuXCIpLm9uKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgJHRoaXMgPSAkKGUuY3VycmVudFRhcmdldCk7XG4gICAgY29uc3QgaXRlbSA9ICR0aGlzLmNsb3Nlc3QoXCIuY2F0YWxvZ3NfX2l0ZW1cIik7XG4gICAgY29uc3QgaXRlbU9wZW5lZCA9IGl0ZW0uaGFzQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgY29uc3QgY29udGFpbmVyID0gJHRoaXMuY2xvc2VzdChcIi5jYXRhbG9nc19fbGlzdFwiKTtcblxuICAgIGlmIChpdGVtT3BlbmVkKSB7XG4gICAgICBjbG9zZUV2ZXJ5SXRlbUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZUV2ZXJ5SXRlbUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgb3Blbkl0ZW0oaXRlbSk7XG4gICAgfVxuICB9KTtcblxuICAkKFwiLmNhdGFsb2dzX19idG4tY2xvc2VcIikub24oXCJjbGlja1wiLCBlID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjbG9zZUV2ZXJ5SXRlbUNvbnRhaW5lcigkKFwiLmNhdGFsb2dzX19saXN0XCIpKTtcbiAgfSlcblxufSkoKTtcbiIsIihmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHZhbGlkYXRlRmllbGRzID0gKGZvcm0sIGZpZWxkc0FycmF5KSA9PiB7XG5cbiAgICBmaWVsZHNBcnJheS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgZmllbGQucmVtb3ZlQ2xhc3MoXCJpbnB1dC1lcnJvclwiKTtcbiAgICAgIGlmIChmaWVsZC52YWwoKS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgZmllbGQuYWRkQ2xhc3MoXCJpbnB1dC1lcnJvclwiKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGVycm9yRmllbGRzID0gZm9ybS5maW5kKFwiLmlucHV0LWVycm9yXCIpO1xuXG4gICAgcmV0dXJuIGVycm9yRmllbGRzLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAkKFwiLmZvcm1cIikuc3VibWl0KGUgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IGZvcm0gPSAkKGUuY3VycmVudFRhcmdldCk7XG4gICAgY29uc3QgbmFtZSA9IGZvcm0uZmluZChcIltuYW1lPSd1c2VybmFtZSddXCIpO1xuICAgIGNvbnN0IHBob25lID0gZm9ybS5maW5kKFwiW25hbWU9J3VzZXJ0ZWwnXVwiKTtcbiAgICBjb25zdCBjb21tZW50ID0gZm9ybS5maW5kKFwiW25hbWU9J3VzZXJtZXNzYWdlJ11cIik7XG4gICAgY29uc3QgdG8gPSBmb3JtLmZpbmQoXCJbbmFtZT0ndG8nXVwiKTtcblxuICAgIGNvbnN0IHBvcHVwRm9ybSA9ICQoXCIjcG9wdXAtZm9ybVwiKTtcbiAgICBjb25zdCBjb250ZW50ID0gcG9wdXBGb3JtLmZpbmQoXCIucG9wdXAtZm9ybV9fY29udGVudFwiKTtcbiAgICBwb3B1cEZvcm0ucmVtb3ZlQ2xhc3MoXCJlcnJvci1wb3B1cC1mb3JtXCIpO1xuXG4gICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRlRmllbGRzKGZvcm0sIFtuYW1lLCBwaG9uZSwgY29tbWVudCwgdG9dKTtcblxuICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gJC5hamF4KHtcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vd2ViZGV2LWFwaS5sb2Z0c2Nob29sLmNvbS9zZW5kbWFpbFwiLFxuICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgbmFtZTogbmFtZS52YWwoKSxcbiAgICAgICAgICBwaG9uZTogcGhvbmUudmFsKCksXG4gICAgICAgICAgY29tbWVudDogY29tbWVudC52YWwoKSxcbiAgICAgICAgICB0bzogdG8udmFsKCksXG4gICAgICAgIH0sXG5cbiAgICAgIH0pO1xuXG4gICAgICByZXF1ZXN0LmRvbmUoZGF0YSA9PiB7XG4gICAgICAgIGNvbnRlbnQudGV4dChkYXRhLm1lc3NhZ2UpO1xuICAgICAgICAkKCcuZm9ybScpWzBdLnJlc2V0KCk7XG4gICAgICB9KTtcblxuICAgICAgcmVxdWVzdC5mYWlsKGRhdGEgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZGF0YS5yZXNwb25zZUpTT04ubWVzc2FnZTtcbiAgICAgICAgY29udGVudC50ZXh0KG1lc3NhZ2UpO1xuICAgICAgICBwb3B1cEZvcm0uYWRkQ2xhc3MoXCJlcnJvci1wb3B1cC1mb3JtXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIHJlcXVlc3QuYWx3YXlzKCgpID0+IHtcbiAgICAgICAgJC5mYW5jeWJveC5vcGVuKHtcbiAgICAgICAgICBzcmM6IFwiI3BvcHVwLWZvcm1cIixcbiAgICAgICAgICB0eXBlOiBcImlubGluZVwiXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgJChcIi5hcHAtc3VibWl0LWJ0blwiKS5jbGljayhlID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAkLmZhbmN5Ym94LmNsb3NlKCk7XG4gIH0pO1xufSkoKTtcbiIsIihmdW5jdGlvbiAoKSB7XG4gIGxldCBteU1hcDtcblxuICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgIG15TWFwID0gbmV3IHltYXBzLk1hcChcIm1hcFwiLCB7XG4gICAgICBjZW50ZXI6IFs1NS43NCwgMzcuNjFdLFxuICAgICAgem9vbTogMTQsXG4gICAgICBjb250cm9sczogW11cbiAgICB9KTtcbiAgICBjb29yZHMgPSBbXG4gICAgICBbNTUuNzQ5NTM5LCAzNy42MDM1OTFdXG4gICAgXTtcblxuICAgIGNvbnN0IG15Q29sbGVjdGlvbiA9IG5ldyB5bWFwcy5HZW9PYmplY3RDb2xsZWN0aW9uKHt9LCB7XG4gICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgaWNvbkxheW91dDogJ2RlZmF1bHQjaW1hZ2UnLFxuICAgICAgaWNvbkltYWdlSHJlZjogJy4vaW1nL21hcmtlci5zdmcnLFxuICAgICAgaWNvbkltYWdlU2l6ZTogWzcwLCA4MF0sXG4gICAgICBpY29uSW1hZ2VPZmZzZXQ6IFstMzUsIC01Ml1cbiAgICB9KTtcblxuICAgIGNvb3Jkcy5mb3JFYWNoKGNvb3JkID0+IHtcbiAgICAgIG15Q29sbGVjdGlvbi5hZGQobmV3IHltYXBzLlBsYWNlbWFyayhjb29yZCkpO1xuICAgIH0pXG5cbiAgICBteU1hcC5nZW9PYmplY3RzLmFkZChteUNvbGxlY3Rpb24pO1xuICAgIG15TWFwLmJlaGF2aW9ycy5kaXNhYmxlKCdzY3JvbGxab29tJyk7XG4gIH07XG5cbiAgeW1hcHMucmVhZHkoaW5pdCk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uICgpIHtcbiAgbGV0IGhhbWJ1cmdlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5oYW1idXJnZXInKTtcbiAgbGV0IHBvcHVwTWVudSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wb3B1cC1tZW51Jyk7XG4gIGxldCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gIGxldCBsaW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wb3B1cC1tZW51X19saW5rJyk7XG5cbiAgbGlua3MuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0b2dnbGVNZW51KTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdG9nZ2xlTWVudSgpIHtcbiAgICBoYW1idXJnZXIuY2xhc3NMaXN0LnRvZ2dsZSgnaGFtYnVyZ2VyLS1hY3RpdmUnKTtcbiAgICBwb3B1cE1lbnUuY2xhc3NMaXN0LnRvZ2dsZSgncG9wdXAtbWVudS0tYWN0aXZlJyk7XG4gICAgYm9keS5jbGFzc0xpc3QudG9nZ2xlKCdib2R5LS1hY3RpdmUtbWVudScpO1xuICB9O1xuXG4gIGhhbWJ1cmdlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRvZ2dsZU1lbnUpO1xufSkoKTtcbiIsIihmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGZpbmRCbG9ja0J5QWxpYXMgPSBhbGlhcyA9PiB7XG4gICAgcmV0dXJuICQoXCIucmV2aWV3c19faXRlbVwiKS5maWx0ZXIoKG5keCwgaXRlbSkgPT4ge1xuICAgICAgcmV0dXJuICQoaXRlbSkuYXR0cihcImRhdGEtbGlua2VkLXdpdGhcIikgPT09IGFsaWFzO1xuICAgIH0pO1xuICB9O1xuXG4gICQoXCIucmV2aWV3c19fYnRuXCIpLmNsaWNrKGUgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0ICR0aGlzID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuICAgIGNvbnN0IHRhcmdldCA9ICR0aGlzLmF0dHIoXCJkYXRhLW9wZW5cIik7XG4gICAgY29uc3QgaXRlbVRvU2hvdyA9IGZpbmRCbG9ja0J5QWxpYXModGFyZ2V0KTtcbiAgICBjb25zdCBjdXJJdGVtID0gJHRoaXMuY2xvc2VzdChcIi5yZXZpZXdzX19tZW51LWl0ZW1cIik7XG5cbiAgICBpdGVtVG9TaG93LmFkZENsYXNzKFwicmV2aWV3c19faXRlbS0tYWN0aXZlXCIpLnNpYmxpbmdzKCkucmVtb3ZlQ2xhc3MoXCJyZXZpZXdzX19pdGVtLS1hY3RpdmVcIik7XG4gICAgY3VySXRlbS5hZGRDbGFzcyhcInJldmlld3NfX21lbnUtaXRlbS0tYWN0aXZlXCIpLnNpYmxpbmdzKCkucmVtb3ZlQ2xhc3MoXCJyZXZpZXdzX19tZW51LWl0ZW0tLWFjdGl2ZVwiKTtcbiAgfSk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uICgpIHtcblxuICBjb25zdCBzZWN0aW9ucyA9ICQoXCJzZWN0aW9uXCIpO1xuICBjb25zdCBkaXNwbGF5ID0gJChcIi5tYWluY29udGVudFwiKTtcbiAgY29uc3Qgc2lkZU1lbnUgPSAkKFwiLmZpeGVkLW1lbnVcIik7XG4gIGNvbnN0IG1lbnVJdGVtcyA9IHNpZGVNZW51LmZpbmQoXCIuZml4ZWQtbWVudV9faXRlbVwiKTtcblxuICBsZXQgaW5TY3JvbGwgPSBmYWxzZTtcblxuICBzZWN0aW9ucy5maXJzdCgpLmFkZENsYXNzKFwiYWN0aXZlXCIpO1xuXG4gIGNvbnN0IGNvdW50U2VjdGlvblBvc2l0aW9uID0gc2VjdGlvbkVxID0+IHtcbiAgICByZXR1cm4gc2VjdGlvbkVxICogLTEwMDtcbiAgfTtcblxuICBjb25zdCBjaGFuZ2VNZW51VGhlbWVGb3JTZWN0aW9uID0gc2VjdGlvbkVxID0+IHtcblxuICAgIGNvbnN0IGN1cnJlbnRTZWN0aW9uID0gc2VjdGlvbnMuZXEoc2VjdGlvbkVxKTtcbiAgICBjb25zdCBtZW51VGhlbWUgPSBjdXJyZW50U2VjdGlvbi5hdHRyKFwiZGF0YS1zaWRlbWVudS10aGVtZVwiKTtcbiAgICBjb25zdCBhY3RpdmVDbGFzcyA9IFwiZml4ZWQtbWVudS0tc2hhZG93ZWRcIjtcblxuICAgIGlmIChtZW51VGhlbWUgPT09IFwiYmxhY2tcIikge1xuICAgICAgc2lkZU1lbnUuYWRkQ2xhc3MoYWN0aXZlQ2xhc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWRlTWVudS5yZW1vdmVDbGFzcyhhY3RpdmVDbGFzcyk7XG4gICAgfVxuXG4gIH07XG5cbiAgY29uc3QgcmVzZXRBY3RpdmVDbGFzc0Zvckl0ZW0gPSAoaXRlbXMsIGl0ZW1FcSwgYWN0aXZlQ2xhc3MpID0+IHtcbiAgICBpdGVtcy5lcShpdGVtRXEpLmFkZENsYXNzKGFjdGl2ZUNsYXNzKS5zaWJsaW5ncygpLnJlbW92ZUNsYXNzKGFjdGl2ZUNsYXNzKTtcbiAgfVxuXG4gIGNvbnN0IHBlcmZvcm1UcmFuc2l0aW9uID0gKHNlY3Rpb25FcSkgPT4ge1xuXG4gICAgaWYgKGluU2Nyb2xsKSByZXR1cm47XG5cbiAgICBjb25zdCB0cmFuc2l0aW9uT3ZlciA9IDEwMDA7XG4gICAgY29uc3QgbW91c2VJbmVydGlhT3ZlciA9IDMwMDtcblxuICAgIGluU2Nyb2xsID0gdHJ1ZTtcblxuICAgIGNvbnN0IHBvc2l0aW9uID0gY291bnRTZWN0aW9uUG9zaXRpb24oc2VjdGlvbkVxKTtcblxuICAgIGNoYW5nZU1lbnVUaGVtZUZvclNlY3Rpb24oc2VjdGlvbkVxKTtcblxuICAgIGRpc3BsYXkuY3NzKHtcbiAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVkoJHtwb3NpdGlvbn0lKWBcbiAgICB9KTtcblxuICAgIHJlc2V0QWN0aXZlQ2xhc3NGb3JJdGVtKHNlY3Rpb25zLCBzZWN0aW9uRXEsIFwiYWN0aXZlXCIpO1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpblNjcm9sbCA9IGZhbHNlO1xuICAgICAgcmVzZXRBY3RpdmVDbGFzc0Zvckl0ZW0obWVudUl0ZW1zLCBzZWN0aW9uRXEsIFwiZml4ZWQtbWVudV9faXRlbS0tYWN0aXZlXCIpO1xuICAgIH0sIHRyYW5zaXRpb25PdmVyICsgbW91c2VJbmVydGlhT3Zlcik7XG5cblxuICB9O1xuXG4gIGNvbnN0IHNjcm9sbFZpZXdwb3J0ID0gZGlyZWN0aW9uID0+IHtcbiAgICBjb25zdCBhY3RpdmVTZWN0aW9uID0gc2VjdGlvbnMuZmlsdGVyKFwiLmFjdGl2ZVwiKTtcbiAgICBjb25zdCBuZXh0U2VjdGlvbiA9IGFjdGl2ZVNlY3Rpb24ubmV4dCgpO1xuICAgIGNvbnN0IHByZXZTZWN0aW9uID0gYWN0aXZlU2VjdGlvbi5wcmV2KCk7XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcIm5leHRcIiAmJiBuZXh0U2VjdGlvbi5sZW5ndGgpIHtcbiAgICAgIHBlcmZvcm1UcmFuc2l0aW9uKG5leHRTZWN0aW9uLmluZGV4KCkpO1xuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwicHJldlwiICYmIHByZXZTZWN0aW9uLmxlbmd0aCkge1xuICAgICAgcGVyZm9ybVRyYW5zaXRpb24ocHJldlNlY3Rpb24uaW5kZXgoKSk7XG4gICAgfVxuICB9O1xuXG4gICQod2luZG93KS5vbihcIndoZWVsXCIsIGUgPT4ge1xuICAgIGNvbnN0IGRlbHRhWSA9IGUub3JpZ2luYWxFdmVudC5kZWx0YVk7XG5cbiAgICBpZiAoZGVsdGFZID4gMCkge1xuICAgICAgc2Nyb2xsVmlld3BvcnQoXCJuZXh0XCIpO1xuICAgIH1cblxuICAgIGlmIChkZWx0YVkgPCAwKSB7XG4gICAgICBzY3JvbGxWaWV3cG9ydChcInByZXZcIik7XG4gICAgfVxuXG4gIH0pO1xuXG4gICQod2luZG93KS5vbihcImtleWRvd25cIiwgZSA9PiB7XG5cbiAgICBjb25zdCB0YWdOYW1lID0gZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHVzZXJUeXBpbmdJbklucHV0cyA9IHRhZ05hbWUgPT09IFwiaW5wdXRcIiB8fCB0YWdOYW1lID09PSBcInRleHRhcmVhXCI7XG5cbiAgICBpZiAodXNlclR5cGluZ0luSW5wdXRzKSByZXR1cm47XG5cbiAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgc2Nyb2xsVmlld3BvcnQoXCJwcmV2XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDA6XG4gICAgICAgIHNjcm9sbFZpZXdwb3J0KFwibmV4dFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gIH0pO1xuXG4gICQoXCJbZGF0YS1zY3JvbGwtdG9dXCIpLmNsaWNrKGUgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0ICR0aGlzID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuICAgIGNvbnN0IHRhcmdldCA9ICR0aGlzLmF0dHIoXCJkYXRhLXNjcm9sbC10b1wiKTtcbiAgICBjb25zdCByZXFTZWN0aW9uID0gJChgW2RhdGEtc2VjdGlvbi1pZD0ke3RhcmdldH1dYCk7XG5cbiAgICBwZXJmb3JtVHJhbnNpdGlvbihyZXFTZWN0aW9uLmluZGV4KCkpO1xuICB9KTtcblxufSkoKTtcbiIsIihmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGxlZnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2xlZnRcIik7XG4gIGNvbnN0IHJpZ2h0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNyaWdodFwiKTtcbiAgY29uc3QgaXRlbXNMaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpdGVtc1wiKTtcblxuICBjb25zdCBsb29wID0gKGRpcmVjdGlvbiwgZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwicmlnaHRcIikge1xuICAgICAgaXRlbXNMaXN0LmFwcGVuZENoaWxkKGl0ZW1zTGlzdC5maXJzdEVsZW1lbnRDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW1zTGlzdC5pbnNlcnRCZWZvcmUoaXRlbXNMaXN0Lmxhc3RFbGVtZW50Q2hpbGQsIGl0ZW1zLmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICB9XG4gIH07XG5cbiAgcmlnaHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgbG9vcChcInJpZ2h0XCIsIGUpO1xuICB9KTtcblxuICBsZWZ0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgIGxvb3AoXCJsZWZ0XCIsIGUpO1xuICB9KTtcbn0pKCk7XG4iLCIoZnVuY3Rpb24gKCkge1xuICBjb25zdCBvcGVuSXRlbSA9IGl0ZW0gPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGl0ZW0uY2xvc2VzdChcIi50ZWFtc19faXRlbVwiKTtcbiAgICBjb25zdCBjb250ZW50QmxvY2sgPSBjb250YWluZXIuZmluZChcIi50ZWFtX19jb250ZW50XCIpO1xuICAgIGNvbnN0IHRleHRCbG9jayA9IGNvbnRlbnRCbG9jay5maW5kKFwiLnRlYW1fX2NvbnRlbnQtYmxvY2tcIik7XG4gICAgY29uc3QgcmVxSGVpZ2h0ID0gdGV4dEJsb2NrLmhlaWdodCgpO1xuXG4gICAgY29udGFpbmVyLmFkZENsYXNzKFwidGVhbS0tYWN0aXZlXCIpO1xuICAgIGNvbnRlbnRCbG9jay5oZWlnaHQocmVxSGVpZ2h0KTtcbiAgfTtcblxuICBjb25zdCBjbG9zZUV2ZXJ5SXRlbSA9IChjb250YWluZXIpID0+IHtcbiAgICBjb25zdCBpdGVtcyA9IGNvbnRhaW5lci5maW5kKFwiLnRlYW1fX2NvbnRlbnRcIik7XG4gICAgY29uc3QgaXRlbUNvbnRhaW5lciA9IGNvbnRhaW5lci5maW5kKFwiLnRlYW1zX19pdGVtXCIpO1xuXG4gICAgaXRlbUNvbnRhaW5lci5yZW1vdmVDbGFzcyhcInRlYW0tLWFjdGl2ZVwiKTtcbiAgICBpdGVtcy5oZWlnaHQoMCk7XG4gIH07XG5cbiAgJChcIi50ZWFtX19idG5cIikuY2xpY2soZSA9PiB7XG4gICAgY29uc3QgJHRoaXMgPSAkKGUuY3VycmVudFRhcmdldCk7XG4gICAgY29uc3QgY29udGFpbmVyID0gJHRoaXMuY2xvc2VzdChcIi50ZWFtc19fbGlzdFwiKTtcbiAgICBjb25zdCBlbGVtQ29udGFpbmVyID0gJHRoaXMuY2xvc2VzdChcIi50ZWFtc19faXRlbVwiKTtcblxuICAgIGlmIChlbGVtQ29udGFpbmVyLmhhc0NsYXNzKFwidGVhbS0tYWN0aXZlXCIpKSB7XG4gICAgICBjbG9zZUV2ZXJ5SXRlbShjb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZUV2ZXJ5SXRlbShjb250YWluZXIpO1xuICAgICAgb3Blbkl0ZW0oJHRoaXMpO1xuICAgIH1cblxuICB9KTtcbn0pKCk7XG4iLCIiXX0=
